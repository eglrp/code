#include "FocalSearcher.h"
#include "SysTools.h"
#include <cstdio>
#include <unistd.h>
#include <cstring>
#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <chrono>
#include <random>
#include <functional>
#include <sys/inotify.h>

#define MIN_AZI_SIZE 10
#define MAX_EVENTS 64 /*Max. number of events to process at one go*/

struct FocalSearcher::FSimpl {

   float MisfitS( AziData& dat, AziData& predl, AziData& predh, float per ) {
      float misG, misP, A;
      if( predl.azi != predh.azi ) {
         float factor = (dat.azi-predl.azi)/(predh.azi-predl.azi);
         misG = predl.misG + (predh.misG-predl.misG) * factor;
         misP = predl.misP + (predh.misP-predl.misP) * factor;
         A = predl.A + (predh.A-predl.A) * factor;
      }
      else { misG = predl.misG; misP = predl.misP; A = predl.A; }
      //abs misfit
      float mis1 = dat.misG-misG, mis2 = dat.misP-misP, mis3 = dat.A-A;
      //correct misP for 2pis
      mis2 = fabs(mis2);
      while( mis2 > per ) mis2 -= per;
      //chi-square
      mis1 = mis1*mis1/dat.varG; mis2 = mis2*mis2/dat.varP; mis3 = mis3*mis3/dat.varA;
      //std::cerr<<mis1<<" "<<dat.varG<<"  "<<mis2<<" "<<dat.varP<<"  "<<mis3<<" "<<dat.varA<<"   "<<dat.A<<" "<<A<<std::endl;
      return mis1*0.2+mis2*0.2+mis3*0.6;
   }

   bool Accept(float E, float Enew, double T) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
      std::default_random_engine generator (timeseed);
      std::uniform_real_distribution<float> distribution(0., 1.);
      auto rand = std::bind ( distribution, generator );
      if(Enew<E) return true;
      if(rand()<exp((E-Enew)/T)) return true;
      return false;
   }

   FocalInfo Neighbour( const FocalInfo& finfo ) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
/*
      // random number generator 1
      std::default_random_engine generator1 (timeseed);
      std::uniform_int_distribution<int> distributionU(0, 3);
      auto randintu3 = std::bind ( distributionU, generator1 );
*/
      // random number generator 2. (apply different generator type to avoid correlated random numbers!!!)
      std::mt19937 generator2 (timeseed);
      std::normal_distribution<double> distributionN(0.0,1.0);
      auto randnorm = std::bind ( distributionN, generator2 );
   
      FocalInfo finfonew = finfo;
      int depthmax = 60;

      finfonew.strike += (int)floor(randnorm()*36+0.5);
      if( finfonew.strike < 0 ) finfonew.strike += 360;
      if( finfonew.strike >= 360 ) finfonew.strike -= 360;
      finfonew.dip += (int)floor(randnorm()*9+0.5);
      if( finfonew.dip < 0 ) finfonew.dip = 0;
      if( finfonew.dip > 90 ) finfonew.dip = 90;
      finfonew.rake += (int)floor(randnorm()*36+0.5);
      if( finfonew.rake < -180 ) finfonew.rake += 360;
      if( finfonew.rake > 180 ) finfonew.rake -= 360;
      finfonew.depth += (int)floor(randnorm()*0.1*depthmax+0.5);
      if( finfonew.depth < 0 ) finfonew.depth = 0;
      if( finfonew.depth >= depthmax ) finfonew.depth = depthmax;
/*
      int shift = 0;
      switch( randintu3() ) {
         case 0:
	    while( shift == 0 ) shift = (int)floor(randnorm()*36+0.5);
	    finfonew.strike += shift;
	    if( finfonew.strike < 0 ) finfonew.strike += 360;
	    if( finfonew.strike >= 360 ) finfonew.strike -= 360;
	    break;
         case 1:
	    while( shift == 0 ) shift = (int)floor(randnorm()*9+0.5);
	    finfonew.dip += shift;
            if( finfonew.dip < 0 ) finfonew.dip = 0;
            if( finfonew.dip > 90 ) finfonew.dip = 90;
            break;
         case 2:
	    while( shift == 0 ) shift = (int)floor(randnorm()*36+0.5);
	    finfonew.rake += shift;
            if( finfonew.rake < -180 ) finfonew.rake += 360;
            if( finfonew.rake > 180 ) finfonew.rake -= 360;
            break;
         case 3:
	    while( shift == 0 ) shift = (int)floor(randnorm()*0.1*depthmax+0.5);
	    finfonew.depth += shift;
            if( finfonew.depth < 0 ) finfonew.depth = 0;
            if( finfonew.depth >= depthmax ) finfonew.depth = depthmax;
            break;
         defalut:
	    std::cerr<<"Error(Neighbour) !!!"<<std::endl;
	    exit(0);
      }
*/
      return finfonew;
   }

};



FocalSearcher::FocalSearcher( std::vector<PerDazi> &perlistin, std::vector< std::vector<AziData> > &per_azi_data_in,
			      const char *feignamein, const char *fphvnamein, const char *radexein )
   : perlist(perlistin), per_azi_data(per_azi_data_in)
   , feigname(feignamein), fphvname(fphvnamein)
   , radexe(radexein), pimpl(new FSimpl) {
   // check per size
   if( perlist.size() != per_azi_data.size() ) {
      std::cerr<<"Error(FocalSearcher::FocalSearcher): size of perlist and per_azi_data doesn't match!"<<std::endl;
      exit(0);
   }

   // azi size
   for(int iper=0; iper<perlist.size(); iper++) { 
      int nazi = 0;
      for(int iazi=0; iazi<per_azi_data.at(iper).size(); iazi++) if( per_azi_data.at(iper).at(iazi).azi != -12345. ) nazi++;
      if( nazi < MIN_AZI_SIZE ) {
	 perlist.erase( perlist.begin() + iper );
	 per_azi_data.erase( per_azi_data.begin() + iper );
      }
   }
   if( perlist.size() == 0 ) {
      std::cerr<<"Error(FocalSearcher::FocalSearcher): data matrix is empty after erasing!"<<std::endl;
      exit(0);
   }

   // insert sort perlist and per_azi_data
   //for(int i=0; i<perlist.size(); i++) std::cerr<<perlist.at(i).per<<" "<<per_azi_data.at(i).at(0).amp<<std::endl;
   for(int i=1; i<perlist.size(); i++) {
      if( perlist.at(i).per >= perlist.at(i-1).per ) continue;
      PerDazi pdtmp = perlist.at(i);
      std::vector<AziData> Vadtmp = per_azi_data.at(i);
      int j;
      for(j=i; j>0 && pdtmp.per<perlist.at(j-1).per; j--) {
	 perlist.at(j) = perlist.at(j-1);
	 per_azi_data.at(j) = per_azi_data.at(j-1);
      }
      perlist.at(j) = pdtmp;
      per_azi_data.at(j) = Vadtmp;
   }

}

FocalSearcher::~FocalSearcher() {}

bool FocalSearcher::SearchFocal() {
   // simulated annealing parameters
   int kmax = 1000;
   float E, Emax = 0;
   finfo.Set( 218, 31, -94, 10 ); 
   // start search
   if( ! Energy(finfo, E) ) return false;
   float T=E*0.5, alpha=0.99;
   std::cout<<"Initial Misfit**2 for "<<finfo<<" = "<<E<<" T="<<T<<std::endl;
   FocalInfo finfobest = finfo;
   float Ebest = E;
   int nrej = 0;
   for( int k=0; k<kmax && E>Emax; k++ ) {
      FocalInfo finfonew = pimpl->Neighbour( finfo );
      float Enew = -12345.;
      if( ! Energy( finfonew, Enew ) ) return false;
      if( pimpl->Accept(E, Enew, T) ) {
	 finfo = finfonew;
	 E = Enew;
         std::cout<<"Misfit**2 for "<<finfonew<<" = "<<Enew<<" (accepted)  T="
		  <<T<<"  k="<<k<<"/"<<kmax<<std::endl;
	 nrej = 0;
      }
      else { nrej++; std::cout<<"( nrejects = "<<nrej<<" )"<<std::endl<<"\x1b[A"; }//std::cout<<"Misfit**2 for "<<finfonew<<" = "<<Enew<<" (rejected)  T="<<T<<"  k="<<k<<"/"<<kmax<<std::endl;
      if( Enew < Ebest ) {
	 finfobest = finfonew;
	 Ebest = Enew;
      }
      T *= alpha;
   }
   finfo = finfobest;
}


bool FocalSearcher::Energy( FocalInfo finfo, float& E ) {
   // check radexe and feigname
   if( access( feigname.c_str(), F_OK) == -1 ) return false;
   if( access( radexe.c_str(), F_OK) == -1 ) return false;
   // generate and make working directory
   unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
   std::default_random_engine generator (timeseed);
   std::uniform_real_distribution<float> distribution(0., 1.);
   auto rand = std::bind ( distribution, generator );
   std::string tdir = "Working_" + std::to_string(rand());
   while( ! MKDir(tdir.c_str()) ) tdir = "Working_" + std::to_string(rand());

   // copy feig and fphv into the working directory
   std::string newfeigname = tdir + "/" + feigname;
   Copy(feigname.c_str(), newfeigname.c_str());
   std::string newfphvname = tdir + "/" + fphvname;
   Copy(fphvname.c_str(), newfphvname.c_str());

   // produce per.list
   std::string perlstname = tdir + "/per.list";
   std::ofstream fout( perlstname );
   if( ! fout ) {
      std::cerr<<"Error(DepthSearcher::SearchDepth): Cannot write to file "<<perlstname<<std::endl;
      exit(0);
   }
   for(int i=0; i<perlist.size(); i++) fout<<perlist.at(i).per<<std::endl;
   fout.close();

   // watch the working directory for new files
   int iid = inotify_init();
   if( iid < 0 ) return false;
   int wid = inotify_add_watch( iid, tdir.c_str(), IN_CREATE ); 
   if( wid == -1 ) return false;      

   std::string command = radexe + " " + newfeigname + " " + perlstname + " ";
   command += std::to_string(finfo.strike) + " " + std::to_string(finfo.dip);
   command += " " + std::to_string(finfo.rake) + " " + std::to_string(finfo.depth) + " >& /dev/null";
   system(command.c_str());

   // search for group, phase, and amp prediction among the newly created files
   std::string grTfname, phafname, ampfname;
   int event_size = sizeof (struct inotify_event); /*size of one event*/
   int buff_size = MAX_EVENTS * ( event_size + 150 ); /*size of buffer to store the data of events*/
   char buffer[buff_size];
   int length = read( iid, buffer, buff_size );
   if( length < 0 ) return false;
   for( int i=0; i<length; ) {
      struct inotify_event *event = ( struct inotify_event * ) &buffer[i];
      if ( event->mask == IN_CREATE ) {
	 bool isCurrent = strstr(event->name, feigname.c_str()) && 
			  strstr(event->name, std::to_string(finfo.strike).c_str()) && 
			  strstr(event->name, std::to_string(finfo.dip).c_str()) &&
			  strstr(event->name, std::to_string(finfo.rake).c_str()) && 
			  strstr(event->name, std::to_string(finfo.depth).c_str());
	 if( isCurrent && strstr(event->name, "_T_") ) grTfname = tdir + "/" + event->name;
	 else if( isCurrent && strstr(event->name, "_CORR_") ) phafname = tdir + "/" + event->name;
	 else if( isCurrent && strstr(event->name, "_AMP_") ) ampfname = tdir + "/" + event->name;
	 else { std::string stmp = tdir + "/" + event->name; fRemove(stmp.c_str()); }
      }
      i += event_size + event->len;
   }
   if( grTfname.empty() || phafname.empty() || ampfname.empty()  ) {
      std::cerr<<"one/more of the files is/are not found!"<<std::endl;
      std::cerr<<command<<std::endl;
      return false;
   }

   // close watch
   inotify_rm_watch( iid, wid );
   close( iid );
 
   // perlst from perlist
   std::vector<float> perlst;
   for(int i=0; i<perlist.size(); i++) perlst.push_back(perlist.at(i).per);
   // initialize prediction matrix
   std::vector< std::vector<AziData> > per_azi_pred;
   per_azi_pred.resize( perlist.size() );
   for(int i=0; i<per_azi_data.size(); i++) per_azi_pred.at(i).resize( per_azi_data.at(i).size() );

   // read in data from all 3 files
   std::ifstream fin(grTfname);
   if( ! fin ) { std::cerr<<"Cannot open file "<<grTfname<<std::endl; return false; }
   // compute dazi and resize the per_azi_pred table
   float dazi, azitmp1, azitmp2;
   std::string line;
   std::getline(fin, line);
   sscanf(line.c_str(), "%f", &azitmp1);
   std::getline(fin, line);
   sscanf(line.c_str(), "%f", &azitmp2);
   dazi = azitmp2-azitmp1;
   int nazi = (int)ceil(360/dazi) + 1;
   for(int i=0; i<per_azi_data.size(); i++) per_azi_pred.at(i).resize( nazi );
   fin.clear(); fin.seekg(0);

   // group delays
   int iper = 0;
   float perold = -12345.;
   for(std::string line; std::getline(fin, line); ) {
      // read in 3 params each line
      float azi, dat, per;
      if( sscanf(line.c_str(), "%f %f %f", &azi, &dat, &per) != 3 ) continue;
      // find iper
      if( per != perold ) {
	 int ipertmp = std::lower_bound(perlst.begin(), perlst.end(), per) - perlst.begin();
	 if( ipertmp>=perlst.size() || perlst.at(ipertmp) != per ) {
	    std::cerr<<"Warning(FocalSearcher::Energy) useless prediction detected!"<<std::endl;
	    continue;
	 }
	 iper = ipertmp; perold = per;
      }
      // find iazi
      int iazi = azi/dazi;
      if( iazi != (float)azi/dazi ) {
	 std::cerr<<"Warning(FocalSearcher::Energy): pred azimuth ("<<azi<<") doesn't fit into any azi grid!"<<std::endl;
	 continue;
      }
      per_azi_pred.at(iper).at(iazi).azi = azi;
      per_azi_pred.at(iper).at(iazi).misG = dat;
   }
   fin.close();

   // phase
   fin.clear(); fin.open(phafname);
   if( ! fin ) return false;
   perold = -12345.;
   for(std::string line; std::getline(fin, line); ) {
      //read in 3 params each line
      float azi, dat, per;
      if( sscanf(line.c_str(), "%f %f %f", &azi, &dat, &per) != 3 ) continue;
      // find iper
      if( per != perold ) {
	 int ipertmp = std::lower_bound(perlst.begin(), perlst.end(), per) - perlst.begin();
	 if( ipertmp>=perlst.size() || perlst.at(ipertmp) != per ) {
            std::cerr<<"Warning(FocalSearcher::Energy) useless prediction detected!"<<std::endl;
            continue;
         }
         iper = ipertmp; perold = per;
      }
      // find iazi
      int iazi = azi/dazi;
      if( iazi != (float)azi/dazi ) {
         std::cerr<<"Warning(FocalSearcher::Energy): pred azimuth ("<<azi<<") doesn't fit into any azi grid!"<<std::endl;
         continue;
      }
      per_azi_pred.at(iper).at(iazi).misP = dat;
   }
   fin.close();

   // amplitude
   fin.clear(); fin.open(ampfname);
   if( ! fin ) return false;
   perold = -12345.;
   for(std::string line; std::getline(fin, line); ) {
      //read in 3 params each line
      float azi, dat, per;
      if( sscanf(line.c_str(), "%f %f %f", &azi, &dat, &per) != 3 ) continue;
      // find iper
      if( per != perold ) {
	 int ipertmp = std::lower_bound(perlst.begin(), perlst.end(), per) - perlst.begin();
	 if( ipertmp>=perlst.size() || perlst.at(ipertmp) != per ) {
            std::cerr<<"Warning(FocalSearcher::Energy) useless prediction detected!"<<std::endl;
            continue;
         }
         iper = ipertmp; perold = per;
      }
      // find iazi
      int iazi = azi/dazi;
      if( iazi != (float)azi/dazi ) {
         std::cerr<<"Warning(FocalSearcher::Energy): pred azimuth ("<<azi<<") doesn't fit into any azi grid!"<<std::endl;
         continue;
      }
      per_azi_pred.at(iper).at(iazi).A = dat;
   }
   fin.close();

   // cleanup files
   dRemove( tdir.c_str() );

   /* check prediction
   int iiper = 2;
   for(int i=0; i<per_azi_pred.at(iiper).size(); i++) {
      AziData adtmp = per_azi_pred.at(iiper).at(i);
      std::cerr<< perlst.at(iiper)<<" "<<adtmp.azi<<" "<<adtmp.misG<<" "<<adtmp.misP<<" "<<adtmp.amp<<std::endl;
   }
   */

   // invalidate incomplete azimuths and points around 0 amplitudes
   for( int iper=0; iper<perlst.size(); iper++ )
      for( int ipred=0; ipred < per_azi_pred.at(iper).size(); ipred++ ) {
	 AziData &adtmp = per_azi_pred.at(iper).at(ipred);
	 if( adtmp.azi == -12345. ) continue;
	 if( adtmp.misG==-12345 || adtmp.misP==-12345 || adtmp.A==-12345 ) adtmp.azi = -12345.;
	 else if( adtmp.A < 0.01 ) {
	    int jpredlow = ipred, jpredhigh = ipred;
	    while( jpredlow>0 && per_azi_pred.at(iper).at(jpredlow).azi>adtmp.azi-20 ) jpredlow--;
	    while( jpredhigh<per_azi_pred.at(iper).size() && per_azi_pred.at(iper).at(jpredhigh).azi<adtmp.azi+20 ) jpredhigh++;
	    for(int jpred=jpredlow; jpred<jpredhigh; jpred++) per_azi_pred.at(iper).at(jpred).azi = -12345.;
	 }
      }

 
   // rescale observed amplitude by predicted average
   long double ampD = 0., ampP = 0.;
   for( int iper=0; iper<perlst.size(); iper++ ) {
      int itmp = 0;
      long double ldtmp = 0.;
      for( int idata=0; idata < per_azi_data.at(iper).size(); idata++ )
	 if( per_azi_data.at(iper).at(idata).azi != -12345 ) { ldtmp += per_azi_data.at(iper).at(idata).A; itmp++; }
      ampD += ldtmp / itmp;
      itmp = 0; ldtmp = 0.;
      for( int ipred=0; ipred < per_azi_pred.at(iper).size(); ipred++ ) 
	 if( per_azi_pred.at(iper).at(ipred).azi != -12345 ) { ldtmp += per_azi_pred.at(iper).at(ipred).A; itmp++; }
      ampP += ldtmp / itmp;
   }
   long double factor = ampP/ampD, factor2 = factor*factor;
   for( int iper=0; iper<perlst.size(); iper++ ) {
      for( int idata=0; idata < per_azi_data.at(iper).size(); idata++ ) 
	 if( per_azi_data.at(iper).at(idata).azi != -12345 ) {
	    per_azi_data.at(iper).at(idata).A *= factor;
	    per_azi_data.at(iper).at(idata).varA *= factor2;
	 }
   }
   //

   // compute misfit at each period
   E = 0.;
   for( int iper=0; iper<perlst.size(); iper++ ) {
      int ipred = 0, nvalid=0;
      float Ecur = 0.;
      for( int idata=0; idata < per_azi_data.at(iper).size(); idata++ ) {
 	 AziData adtmp = per_azi_data.at(iper).at(idata);
         if( adtmp.azi == -12345. ) continue;
	 int ninvalid = 0;
	 int ipredlow = (int)floor(adtmp.azi/dazi);
	 while( ipredlow>=0 && per_azi_pred.at(iper).at(ipredlow).azi == -12345. ) { ipredlow--; ninvalid++; }
	 int ipredhigh = (int)ceil(adtmp.azi/dazi);
	 while( ipredhigh<per_azi_pred.at(iper).size() && per_azi_pred.at(iper).at(ipredhigh).azi == -12345. ) { ipredhigh++; ninvalid++; }
	 if( ipredlow < 0 || ipredhigh >= per_azi_pred.at(iper).size() || ninvalid>5 ) continue;
	 Ecur += pimpl->MisfitS( adtmp, per_azi_pred.at(iper).at(ipredlow), per_azi_pred.at(iper).at(ipredhigh), perlst.at(iper) );
	 nvalid++;
      }
      if( nvalid < MIN_AZI_SIZE ) {
	 std::cerr<<"Warning(FocalSearcher::Energy): no enough data point for the current period!"<<std::endl;
	 continue;
      }
      else E += Ecur/nvalid;
   }

   return true;
}



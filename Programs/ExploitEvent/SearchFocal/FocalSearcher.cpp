#include "FocalSearcher.h"
#include "SysTools.h"
#include <cstdio>
#include <unistd.h>
#include <cstring>
#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <chrono>
#include <random>
#include <functional>
#include <sys/inotify.h>
#include <omp.h>

#define MIN_AZI_SIZE 10
#define MAX_EVENTS 64 /*Max. number of events to process at one go*/

extern"C" {
   void rad_pattern_r_(char *eig_fname, int *eig_namelen, char *phv_fname, int *phv_namelen,
                       float *strike, float *dip, float *rake, float *depth, float *per, int *nper,
                       float *azi, float grT[][181], float phT[][181], float amp[][181]);
}
struct FocalSearcher::FSimpl {

   float MisfitS( AziData& dat, AziData& predl, AziData& predh, float per ) {
      float misG, misP, A;
      if( predl.azi != predh.azi ) {
         float factor = (dat.azi-predl.azi)/(predh.azi-predl.azi);
         misG = predl.misG + (predh.misG-predl.misG) * factor;
         misP = predl.misP + (predh.misP-predl.misP) * factor;
         A = predl.A + (predh.A-predl.A) * factor;
      }
      else { misG = predl.misG; misP = predl.misP; A = predl.A; }
      //abs misfit
      float mis1 = dat.misG-misG, mis2 = dat.misP-misP, mis3 = dat.A-A;
      //correct misP for 2pis
      mis2 = fabs(mis2);
      while( mis2 > per ) mis2 -= per;
      //chi-square
      mis1 = mis1*mis1/dat.varG; mis2 = mis2*mis2/dat.varP; mis3 = mis3*mis3/dat.varA;
      //std::cerr<<mis1<<" "<<dat.varG<<"  "<<mis2<<" "<<dat.varP<<"  "<<mis3<<" "<<dat.varA<<"   "<<dat.A<<" "<<A<<std::endl;
      return mis1*0.3+mis2*0.3+mis3*0.4;
   }

   bool Accept(float E, float Enew, double T) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
      std::default_random_engine generator (timeseed);
      std::uniform_real_distribution<float> distribution(0., 1.);
      auto rand = std::bind ( distribution, generator );
      if(Enew<E) return true;
      if(rand()<exp((E-Enew)/T)) return true;
      return false;
   }

   FocalInfo Neighbour( const FocalInfo& finfo ) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
/*
      // random number generator 1
      std::default_random_engine generator1 (timeseed);
      std::uniform_int_distribution<int> distributionU(0, 3);
      auto randintu3 = std::bind ( distributionU, generator1 );
*/
      // random number generator 2. (apply different generator type to avoid correlated random numbers!!!)
      std::mt19937 generator2 (timeseed);
      std::normal_distribution<double> distributionN(0.0,1.0);
      auto randnorm = std::bind ( distributionN, generator2 );
   
      FocalInfo finfonew = finfo;
      int depthmax = 60;

      finfonew.strike += (int)floor(randnorm()*36+0.5);
      if( finfonew.strike < 0 ) finfonew.strike += 360;
      if( finfonew.strike >= 360 ) finfonew.strike -= 360;
      finfonew.dip += (int)floor(randnorm()*9+0.5);
      if( finfonew.dip < 0 ) finfonew.dip = 0;
      if( finfonew.dip > 90 ) finfonew.dip = 90;
      finfonew.rake += (int)floor(randnorm()*36+0.5);
      if( finfonew.rake < -180 ) finfonew.rake += 360;
      if( finfonew.rake > 180 ) finfonew.rake -= 360;
      finfonew.depth += (int)floor(randnorm()*0.1*depthmax+0.5);
      if( finfonew.depth < 0 ) finfonew.depth = 0;
      if( finfonew.depth >= depthmax ) finfonew.depth = depthmax;
/*
      int shift = 0;
      switch( randintu3() ) {
         case 0:
	    while( shift == 0 ) shift = (int)floor(randnorm()*36+0.5);
	    finfonew.strike += shift;
	    if( finfonew.strike < 0 ) finfonew.strike += 360;
	    if( finfonew.strike >= 360 ) finfonew.strike -= 360;
	    break;
         case 1:
	    while( shift == 0 ) shift = (int)floor(randnorm()*9+0.5);
	    finfonew.dip += shift;
            if( finfonew.dip < 0 ) finfonew.dip = 0;
            if( finfonew.dip > 90 ) finfonew.dip = 90;
            break;
         case 2:
	    while( shift == 0 ) shift = (int)floor(randnorm()*36+0.5);
	    finfonew.rake += shift;
            if( finfonew.rake < -180 ) finfonew.rake += 360;
            if( finfonew.rake > 180 ) finfonew.rake -= 360;
            break;
         case 3:
	    while( shift == 0 ) shift = (int)floor(randnorm()*0.1*depthmax+0.5);
	    finfonew.depth += shift;
            if( finfonew.depth < 0 ) finfonew.depth = 0;
            if( finfonew.depth >= depthmax ) finfonew.depth = depthmax;
            break;
         defalut:
	    std::cerr<<"Error(Neighbour) !!!"<<std::endl;
	    exit(0);
      }
*/
      return finfonew;
   }

   bool RadPatternR( const std::string& feigname, const std::string& fphvname, const FocalInfo& finfo,
		     std::vector<float>& perlst, std::vector< std::vector<AziData> >& per_azi_pred ) {
      char eigname[feigname.size()], phvname[fphvname.size()];
      strcpy(eigname, feigname.c_str()); strcpy(phvname, fphvname.c_str());
      int nper = perlst.size(), eiglen = feigname.size(), phvlen = fphvname.size();
      float strike = finfo.strike, dip = finfo.dip, rake = finfo.rake, depth = finfo.depth;
      float azi[181], grT[nper][181], phT[nper][181], amp[nper][181];
std::ifstream fin( feigname.c_str() );
fin.seekg(0, std::ios::end);
int feig_len = fin.tellg();
//std::string feig_buff;
//feig_buff.resize(fin.tellg());
char *feig_buff = new char[feig_len];
fin.seekg(0,std::ios::beg);
fin.read(feig_buff, feig_len);
fin.close();

fin.clear(); fin.open( fphvname.c_str() );
fin.seekg(0, std::ios::end);
int fphv_len = fin.tellg();
//std::string feig_buff;
//feig_buff.resize(fin.tellg());
char *fphv_buff = new char[fphv_len];
fin.seekg(0,std::ios::beg);
fin.read(fphv_buff, fphv_len);
fin.close();

      rad_pattern_r_( feig_buff, &feig_len, fphv_buff, &fphv_len,
                      &(strike), &(dip), &(rake), &(depth),
		      &(perlst.at(0)), &nper, azi, grT, phT, amp );
free(feig_buff); free(fphv_buff);
      for(int i=0; i<per_azi_pred.size(); i++) {
	 per_azi_pred.at(i).resize( 181 );
	 for(int iazi=0; iazi<181; iazi++) {
	    if( azi[iazi] != iazi*2 ) return false;
	    per_azi_pred.at(i).at(iazi) = AziData( azi[iazi], grT[i][iazi], phT[i][iazi], amp[i][iazi] );
	 }
      }

      return true;
   }
};



FocalSearcher::FocalSearcher( std::vector<PerDazi> &perlistin, std::vector< std::vector<AziData> > &per_azi_data_in,
			      const char *feignamein, const char *fphvnamein, const char *radexein )
   : perlist(perlistin), per_azi_data(per_azi_data_in)
   , feigname(feignamein), fphvname(fphvnamein)
   , radexe(radexein), pimpl(new FSimpl) {
   // check per size
   if( perlist.size() != per_azi_data.size() ) {
      std::cerr<<"Error(FocalSearcher::FocalSearcher): size of perlist and per_azi_data doesn't match!"<<std::endl;
      exit(0);
   }

   // azi size
   for(int iper=0; iper<perlist.size(); iper++) { 
      int nazi = 0;
      for(int iazi=0; iazi<per_azi_data.at(iper).size(); iazi++) if( per_azi_data.at(iper).at(iazi).azi != -12345. ) nazi++;
      if( nazi < MIN_AZI_SIZE ) {
	 perlist.erase( perlist.begin() + iper );
	 per_azi_data.erase( per_azi_data.begin() + iper );
      }
   }
   if( perlist.size() == 0 ) {
      std::cerr<<"Error(FocalSearcher::FocalSearcher): data matrix is empty after erasing!"<<std::endl;
      exit(0);
   }

   // insert sort perlist and per_azi_data
   //for(int i=0; i<perlist.size(); i++) std::cerr<<perlist.at(i).per<<" "<<per_azi_data.at(i).at(0).amp<<std::endl;
   for(int i=1; i<perlist.size(); i++) {
      if( perlist.at(i).per >= perlist.at(i-1).per ) continue;
      PerDazi pdtmp = perlist.at(i);
      std::vector<AziData> Vadtmp = per_azi_data.at(i);
      int j;
      for(j=i; j>0 && pdtmp.per<perlist.at(j-1).per; j--) {
	 perlist.at(j) = perlist.at(j-1);
	 per_azi_data.at(j) = per_azi_data.at(j-1);
      }
      perlist.at(j) = pdtmp;
      per_azi_data.at(j) = Vadtmp;
   }

}

FocalSearcher::~FocalSearcher() {}

bool FocalSearcher::SearchFocal() {
   // simulated annealing parameters
   int nsearch = 1000;
   float E;
   finfo.Set( 218, 31, -94, 10 ); 
   // start search
   if( ! Energy(finfo, E) ) return false;
   float T=E*0.5, alpha=0.99;
   std::cout<<"Initial Misfit**2 for "<<finfo<<" = "<<E<<" T="<<T<<std::endl;
   FocalInfo finfobest = finfo;
   float Ebest = E;
   int nrej = 0;
   int isearch = 0;
   #pragma omp parallel for
   for( int i=0; i<nsearch; i++ ) {
      FocalInfo finfonew = pimpl->Neighbour( finfo );
      float Enew = -12345.;
      if( ! Energy( finfonew, Enew ) ) continue;//return false;
     #pragma omp critical
     { // critical start
      if( pimpl->Accept(E, Enew, T) ) {
	 finfo = finfonew;
	 E = Enew;
         std::cout<<"Misfit**2 for "<<finfonew<<" = "<<Enew<<" (accepted)  T="
		  <<T<<"  isearch="<<isearch<<"/"<<nsearch<<std::endl;
	 nrej = 0;
      }
      else { nrej++; std::cout<<"( nrejects = "<<nrej<<" )"<<"  ithread="<<omp_get_thread_num()<<"   "<<std::endl<<"\x1b[A"; }
      T *= alpha;
      if( Enew < Ebest ) {
	 finfobest = finfonew;
	 Ebest = Enew;
      }
      isearch++;
     } // critical end
   }
   finfo = finfobest;
}


bool FocalSearcher::Energy( FocalInfo finfo, float& E ) {
   // check radexe and feigname
   if( access( feigname.c_str(), F_OK) == -1 ) return false;
   if( access( fphvname.c_str(), F_OK) == -1 ) return false;
   if( access( radexe.c_str(), F_OK) == -1 ) return false;

   // perlst from perlist
   std::vector<float> perlst;
   for(int i=0; i<perlist.size(); i++) perlst.push_back(perlist.at(i).per);


   // initialize prediction matrix
   std::vector< std::vector<AziData> > per_azi_pred;
   per_azi_pred.resize( perlist.size() );

   // run rad_pattern_r
   pimpl->RadPatternR( feigname, fphvname, finfo, perlst, per_azi_pred );
   // compute dazi and resize the per_azi_pred table
   int nazi = per_azi_pred.at(0).size();
   float dazi = per_azi_pred.at(0).at(1).azi - per_azi_pred.at(0).at(0).azi;

   // invalidate incomplete azimuths and points around 0 amplitudes
   for( int iper=0; iper<perlst.size(); iper++ )
      for( int ipred=0; ipred < per_azi_pred.at(iper).size(); ipred++ ) {
	 AziData &adtmp = per_azi_pred.at(iper).at(ipred);
	 if( adtmp.azi == -12345. ) continue;
	 if( adtmp.misG==-12345 || adtmp.misP==-12345 || adtmp.A==-12345 ) adtmp.azi = -12345.;
	 else if( adtmp.A < 0.01 ) {
	    int jpredlow = ipred, jpredhigh = ipred;
	    while( jpredlow>0 && per_azi_pred.at(iper).at(jpredlow).azi>adtmp.azi-20 ) jpredlow--;
	    while( jpredhigh<per_azi_pred.at(iper).size() && per_azi_pred.at(iper).at(jpredhigh).azi<adtmp.azi+20 ) jpredhigh++;
	    for(int jpred=jpredlow; jpred<jpredhigh; jpred++) per_azi_pred.at(iper).at(jpred).azi = -12345.;
	 }
      }

 
   // rescale observed amplitude by predicted average
   long double ampD = 0., ampP = 0.;
   for( int iper=0; iper<perlst.size(); iper++ ) {
      int itmp = 0;
      long double ldtmp = 0.;
      for( int idata=0; idata < per_azi_data.at(iper).size(); idata++ )
	 if( per_azi_data.at(iper).at(idata).azi != -12345 ) { ldtmp += per_azi_data.at(iper).at(idata).A; itmp++; }
      ampD += ldtmp / itmp;
      itmp = 0; ldtmp = 0.;
      for( int ipred=0; ipred < per_azi_pred.at(iper).size(); ipred++ ) 
	 if( per_azi_pred.at(iper).at(ipred).azi != -12345 ) { ldtmp += per_azi_pred.at(iper).at(ipred).A; itmp++; }
      ampP += ldtmp / itmp;
   }
   long double factor = ampP/ampD, factor2 = factor*factor;
   for( int iper=0; iper<perlst.size(); iper++ ) {
      for( int idata=0; idata < per_azi_data.at(iper).size(); idata++ ) 
	 if( per_azi_data.at(iper).at(idata).azi != -12345 ) {
	    per_azi_data.at(iper).at(idata).A *= factor;
	    per_azi_data.at(iper).at(idata).varA *= factor2;
	 }
   }

   // compute misfit at each period
   E = 0.;
   for( int iper=0; iper<perlst.size(); iper++ ) {
      int ipred = 0, nvalid=0;
      float Ecur = 0.;
      for( int idata=0; idata < per_azi_data.at(iper).size(); idata++ ) {
 	 AziData adtmp = per_azi_data.at(iper).at(idata);
         if( adtmp.azi == -12345. ) continue;
	 int ninvalid = 0;
	 int ipredlow = (int)floor(adtmp.azi/dazi);
	 while( ipredlow>=0 && per_azi_pred.at(iper).at(ipredlow).azi == -12345. ) { ipredlow--; ninvalid++; }
	 int ipredhigh = (int)ceil(adtmp.azi/dazi);
	 while( ipredhigh<per_azi_pred.at(iper).size() && per_azi_pred.at(iper).at(ipredhigh).azi == -12345. ) { ipredhigh++; ninvalid++; }
	 if( ipredlow < 0 || ipredhigh >= per_azi_pred.at(iper).size() || ninvalid>5 ) continue;
	 Ecur += pimpl->MisfitS( adtmp, per_azi_pred.at(iper).at(ipredlow), per_azi_pred.at(iper).at(ipredhigh), perlst.at(iper) );
	 nvalid++;
      }
      if( nvalid < MIN_AZI_SIZE ) {
	 std::cerr<<"Warning(FocalSearcher::Energy): no enough data point for the current period!"<<std::endl;
	 continue;
      }
      else E += Ecur/nvalid;
   }

   return true;
}



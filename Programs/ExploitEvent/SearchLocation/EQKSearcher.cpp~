#include "EQKSearcher.h"
#include "DisAzi.h"
#include "Map.h"
#include <cstdlib>
#include <unistd.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <chrono>
#include <random>
#include <algorithm>
#include <omp.h>

struct EQKSearcher::EQimpl {
   std::string fparam;
   std::string outname_mis;
   std::vector< std::string > outlist_RF, outlist_LF;
   std::vector<float> perRtmp, perLtmp;
   std::string fReigname, fRphvname;
   std::string fLeigname, fLphvname;
   std::vector< std::array<std::string, 3> > fRlist, fLlist;
   std::vector<float> perRlist, perLlist;
   std::vector< std::vector<StaData> > per_sta_data_R, per_sta_data_L;
   std::vector< std::vector<AziData> > per_azi_pred_R, per_azi_pred_L;
   float clon, clat, Rs;
   float Rt, Rlon, Rlat;
   EpicInfo einfo;


   EQimpl( const char* fparamin = NULL, float clonin = -12345.,
	   float clatin = -12345., float Rsin = -12345. )
      : fparam(fparamin), clon(clonin), clat(clatin), Rs(Rsin), Rt(20.) {
      Initialize();
   }

   // set search ranges
   bool Initialize() {
      if( Rs>0 && clon!=-12345 && clat!=-12345 ) {
	 double dist;
	 calc_dist(clat, clon, clat, clon+1, &dist);
	 Rlon = Rs / dist;
	 calc_dist(clat, clon, clat+1, clon, &dist);
	 Rlat = Rs / dist;
	 einfo = EpicInfo(clon, clat, 0.);
	 return true;
      }
      else {
	 Rlon = Rlat = -12345.;
	 return false;
      }
   }

   // accept criterion for simulated annealing
   bool Accept(float E, float Enew, double T) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
      std::default_random_engine generator (timeseed);
      std::uniform_real_distribution<float> distribution(0., 1.);
      auto rand = std::bind ( distribution, generator );
      if(Enew<E) return true;
      if(rand()<exp((E-Enew)/T)) return true;
      return false;
   }

   // perturb model parameters
   EpicInfo Neighbour( const EpicInfo& einfo ) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
      // random number generator 
      std::default_random_engine generator2 (timeseed);
      //std::mt19937 generator2 (timeseed);
      std::normal_distribution<double> distributionN(0.0,1.0);
      auto randnorm = std::bind ( distributionN, generator2 );
   
      EpicInfo einfonew = einfo;

      float ht = Rt * 0.05;
      float hlon = Rlon * 0.05, hlat = Rlat * 0.05;

      while( float dltlon = randnorm()*hlon ) {
	 float lonnew = einfonew.lon + dltlon;
	 if( lonnew < clon + Rlon && lonnew > clon - Rlon ) {
	    einfonew.lon = lonnew;
	    break;
	 }
      }
      while( float dltlat = randnorm()*hlat ) {
	 float latnew = einfonew.lat + dltlat;
	 if( latnew < clat + Rlat && latnew > clat - Rlat ) {
	    einfonew.lat = latnew;
	    break;
	 }
      }
      while( float dltt = randnorm()*ht ) {
	 float tnew = einfonew.t0 + dltt;
	 if( tnew < Rt && tnew > -Rt ) {
	    einfonew.t0 = tnew;
	    break;
	 }
      }

      return einfonew;
   }

   // compute azimuth and distance for each station based on the input epicenter location
   void UpdateAziDis( EpicInfo& einfoin, std::vector< std::vector<StaData> >& datain ) {
      float srclon = einfoin.lon, srclat = einfoin.lat;

      for(int iper=0; iper<datain.size(); iper++) {
	 for(int idata=0; idata<datain.at(iper).size(); idata++) {
	    StaData& sdtmp = datain[iper][idata];
	    double azi, dist;
	    calc_dist(srclat, srclon, sdtmp.lat, sdtmp.lon, &dist);
	    calc_azimuth(srclat, srclon, sdtmp.lat, sdtmp.lon, &azi);
	    sdtmp.azi = azi;
	    sdtmp.dist = dist;
	 }
      }
/*
      for(int iper=0; iper<dataL.size(); iper++) {
	 for(int idata=0; idata<dataL.at(iper).size(); idata++) {
	    StaData& sdtmp = dataL[iper][idata];
	    double azi, dist;
	    calc_dist(srclat, srclon, sdtmp.lat, sdtmp.lon, &dist);
	    calc_azimuth(srclat, srclon, sdtmp.lat, sdtmp.lon, &azi);
	    sdtmp.azi = azi;
	    sdtmp.dist = dist;

	 }
      }
*/
   }

   // update focal corrections for rayleigh wave measurements
   bool UpdateFocalCorrR( EpicInfo& einfoin, std::vector< std::vector<StaData> >& datain ) {
      if( datain.size()==0 ) return false;
      if( datain.size() != per_azi_pred_R.size() ) return false;

      // check Rayleigh source input
      //if( (fReigname.empty() || fRphvname.empty()) ) return false;

      /* ------ Corrections for Rayleigh wave ----- */
      // initialize prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      //per_azi_pred.resize( perRlist.size() );

      //RadPatternR( fReigname, fRphvname, finfo, perRlist, per_azi_pred );

      for(int iper=0; iper<datain.size(); iper++) {
	 std::vector< AziData >& adlist = per_azi_pred_R.at(iper);
	 for(int idata=0; idata<datain.at(iper).size(); idata++) {
	    StaData& sdtmp = datain[iper][idata];
	    /* binary search for sdtmp.azi in per_azi_pred list */
	    int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp, CompareAziA ) - adlist.begin();
	    //int ipredh = 1;
	    //while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh-1;
	    if( ipredl == -1 ) ipredl = adlist.size() - 1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float factor = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    sdtmp.misG = adlist.at(ipredl).misG + (adlist.at(ipredh).misG-adlist.at(ipredl).misG) * factor;
	    sdtmp.misP = adlist.at(ipredl).misP + (adlist.at(ipredh).misP-adlist.at(ipredl).misP) * factor;
	    //if(iper==3) std::cerr<<sdtmp.azi<<" "<<sdtmp.misG<<" "<<sdtmp.misP<<std::endl;
	 }
      }


      return true;
   }

   bool UpdateFocalCorrL( EpicInfo& einfoin, std::vector< std::vector<StaData> >& datain ) {
      if( datain.size()==0 ) return false;
      if( datain.size() != per_azi_pred_L.size() ) return false;

      // check Love source input
      //if( (fLeigname.empty() || fLphvname.empty()) ) return false;

      /* ------ Corrections for Love wave ----- */
      // initialize prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      //per_azi_pred.resize( perLlist.size() );

      //RadPatternR( fLeigname, fLphvname, finfo, perLlist, per_azi_pred );

      for(int iper=0; iper<datain.size(); iper++) {
	 std::vector< AziData >& adlist = per_azi_pred_L.at(iper);
	 for(int idata=0; idata<datain.at(iper).size(); idata++) {
	    StaData& sdtmp = datain[iper][idata];
	    int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp, CompareAziA ) - adlist.begin();
	    //int ipredh = 1;
	    //while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh-1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float factor = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    sdtmp.misG = adlist.at(ipredl).misG + (adlist.at(ipredh).misG-adlist.at(ipredl).misG) * factor;
	    sdtmp.misP = adlist.at(ipredl).misP + (adlist.at(ipredh).misP-adlist.at(ipredl).misP) * factor;
	 }
      }

      return true;
   }

   inline static bool CompareAziA( AziData sta1, AziData sta2 ) { return (sta1.azi<sta2.azi); }
   inline static bool CompareAziS( StaData sta1, StaData sta2 ) { return (sta1.azi<sta2.azi); }

   bool DataAvg( std::vector<float>& data, std::vector<float>& weight, float& mean2, float& var2 ) {
      if( data.size() != weight.size() ) return false;
      // compute mean 1
      float V1 = 0., mean1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 mean1 += data[i] * weight[i];
	 V1 += weight[i];
      }
      mean1 /= V1;
      // compute std1
      float V2 = 0., std1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 float ftmp = data[i]-mean1;
	 std1 += ftmp * ftmp * weight[i];
	 V2 += weight[i] * weight[i];
      }
      std1 = sqrt( std1 * V1 / (V1*V1-V2) );
      // compute mean 2
      float lbound = mean1 - 2.*std1, ubound = mean1 + 2.*std1;
      mean2 = 0.; V1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 if( data[i]<lbound || data[i]>ubound ) continue;
         mean2 += data[i] * weight[i];
         V1 += weight[i];
      }
      mean2 /= V1;
      // compute var2
      V2 = 0., var2 = 0.;
      for(int i=0; i<data.size(); i++) {
	 if( data[i]<lbound || data[i]>ubound ) continue;
	 float ftmp = data[i]-mean2;
	 var2 += ftmp * ftmp * weight[i];
	 V2 += weight[i] * weight[i];
      }
      var2 *= V1 / (V1*V1-V2);

      return true;
   }

   // assume the input data is sorted by azimuth
   bool BinAverage( std::vector<StaData>& datain, float binstep, float binhwidth, std::vector<AziData>& result, float per ) {
      if( datain.size() < MIN_AZI_SIZE ) return false;
      float binwidth = binhwidth * 2;
      std::vector<StaData> data;
      // prepend measurements with azi>360-binhwidth*2 to the beginning
      StaData sdbound; sdbound.azi = 360-binwidth;
      std::vector<StaData>::iterator sdIbound = std::upper_bound( datain.begin(), datain.end(), sdbound, CompareAziS );
      for(std::vector<StaData>::iterator sdI=sdIbound; sdI<datain.end(); sdI++) {
	 StaData sdtmp = *sdI;
	 sdtmp.azi -= 360.;
	 data.push_back( sdtmp );
      }
      // copy datain in the middle
      size_t presize = data.size();
      data.resize( presize + datain.size() );
      std::copy( datain.begin(), datain.end(), data.begin() + presize );
      // append measurements with azi<binhwidth*2 to the end
      sdbound.azi = binwidth;
      sdIbound = std::lower_bound( datain.begin(), datain.end(), sdbound, CompareAziS );
      for(std::vector<StaData>::iterator sdI=datain.begin(); sdI<sdIbound; sdI++) {
	 StaData sdtmp = *sdI;
	 sdtmp.azi += 360;
	 data.push_back( sdtmp );
      }
      // compute average in each bin
      int nbin = (int)ceil(360 / binstep);
      result.clear(); result.resize(nbin);
      std::vector<StaData>::iterator sdI_lbound, sdI_ubound;
      sdI_lbound = sdI_ubound = data.begin();
      float alpha = -0.5/(binhwidth*binhwidth);
      for(float iazi=0; iazi<nbin; iazi++) {
	 float azi = iazi * binstep;
	 StaData sd_lbound, sd_ubound;
	 sd_lbound.azi = azi-binwidth; sd_ubound.azi = azi+binwidth;
	 sdI_lbound = std::upper_bound( sdI_lbound, data.end(), sd_lbound, CompareAziS );
	 sdI_ubound = std::lower_bound( sdI_ubound, data.end(), sd_ubound, CompareAziS );
	 if( sdI_ubound - sdI_lbound < MIN_BAZI_SIZE ) {
	    result[iazi].azi = -12345.;
if( per == 30 ) std::cerr<<"Invalid azimuth = "<<azi<<std::endl;
	    continue;
	 }
	 std::vector<float> dataG, dataP, dataA;
	 std::vector<float >weitG, weitP, weitA;
	 for(std::vector<StaData>::iterator sdI=sdI_lbound; sdI<sdI_ubound; sdI++) {
	    float ftmp = azi-(*sdI).azi;
	    float weight = exp(alpha*ftmp*ftmp);
	    if( (*sdI).misG != -12345. ) {
		weitG.push_back( weight );
		dataG.push_back( (*sdI).misG );
	    }
	    if( (*sdI).misP != -12345. ) {
		weitP.push_back( weight );
		dataP.push_back( (*sdI).misP );
	    }
	    if( (*sdI).A != -12345. ) {
		weitA.push_back( weight );
		dataA.push_back( (*sdI).A );
	    }
	 }
	 result[iazi].azi = azi;
	 if( ! DataAvg( dataG, weitG, result[iazi].misG, result[iazi].varG ) ) return false;
	 if( ! DataAvg( dataP, weitP, result[iazi].misP, result[iazi].varP ) ) return false;
	 if( ! DataAvg( dataA, weitA, result[iazi].A, result[iazi].varA ) ) return false;
      }
      return true;
   }

};

EQKSearcher::EQKSearcher( const char* fparamin ) 
   : pimplES( new EQimpl(fparamin) ) {
   if( ! LoadParams( pimplES->fparam.c_str() ) ) {
      std::cerr<<"ERROR(EQKSearcher::EQKSearcher): Failed to load parameters from file "<<pimplES->fparam<<std::endl;
      exit(0);
   }
}

EQKSearcher::~EQKSearcher() {}

const EpicInfo& EQKSearcher::EInfo() const { return pimplES->einfo; }
      EpicInfo& EQKSearcher::EInfo() { return pimplES->einfo; }

const std::string& EQKSearcher::FREigName() const { return pimplES->fReigname; }
      std::string& EQKSearcher::FREigName() { return pimplES->fReigname; }
const std::string& EQKSearcher::FRPhvName() const { return pimplES->fRphvname; }
      std::string& EQKSearcher::FRPhvName() { return pimplES->fRphvname; }

const std::string& EQKSearcher::FLEigName() const { return pimplES->fLeigname; }
      std::string& EQKSearcher::FLEigName() { return pimplES->fLeigname; }
const std::string& EQKSearcher::FLPhvName() const { return pimplES->fLphvname; }
      std::string& EQKSearcher::FLPhvName() { return pimplES->fLphvname; }

bool EQKSearcher::LoadParams( const char* fname ) {
   std::ifstream fin(fname);
   if( ! fin ) return false;
   int nparam = 0;
   for( std::string stmp; std::getline(fin, stmp); ) {
      int retval = Set( stmp.c_str() );
      if( retval == -3 ) continue; // reapeated period in fRlist or fLlist
      else if( retval == -2 ) continue; // empty input
      else if( retval == -1 ) continue;// std::cerr<<"Warning(EQKSearcher::Load): Unknown parameter name: "<<stmp<<std::endl;
      else if( retval == 0 ) continue;// std::cerr<<"Warning(EQKSearcher::Load): Empty parameter field for "<<stmp<<std::endl;
      else nparam++;
   }
   fin.close();

   std::cout<<"### "<<nparam<<" succed loads from param file "<<fname<<". ###"<<std::endl;
   // synchronize focal-output vectors with input-measurement vectors
   if( pimplES->outlist_RF.size() != pimplES->perRtmp.size() ) return false;
   int Rsize = pimplES->perRlist.size();
   if( pimplES->outlist_RF.size() > 0 && Rsize > 0 ) {
      std::vector< std::string > strVtmp( pimplES->outlist_RF );
      pimplES->outlist_RF.clear();
      pimplES->outlist_RF.resize( Rsize );
      for(int iper=0; iper<Rsize; iper++) {
	 int iol;
	 for(iol=0; iol<strVtmp.size(); iol++) {
	    if( pimplES->perRtmp[iol] == pimplES->perRlist[iper] ) break;
	 }
	 if( iol == strVtmp.size() ) continue;
	 pimplES->outlist_RF.at(iper) = strVtmp.at(iol);
      }
      pimplES->perRtmp.clear();
   }
   if( pimplES->outlist_LF.size() != pimplES->perLtmp.size() ) return false;
   int Lsize = pimplES->perLlist.size();
   if( pimplES->outlist_LF.size() > 0 && Lsize > 0 ) {
      std::vector< std::string > strVtmp( pimplES->outlist_LF );
      pimplES->outlist_LF.clear();
      pimplES->outlist_LF.resize( Lsize );
      for(int iper=0; iper<Lsize; iper++) {
	 int iol;
	 for(iol=0; iol<strVtmp.size(); iol++) {
	    if( pimplES->perLtmp[iol] == pimplES->perLlist[iper] ) break;
	 }
	 if( iol == strVtmp.size() ) continue;
	 pimplES->outlist_LF.at(iper) = strVtmp.at(iol);
      }
      pimplES->perLtmp.clear();
   }

   if( pimplES->Initialize() ) return true;
   return false;
}

int EQKSearcher::Set( const char *input ) {
   std::istringstream buff(input);
   std::string stmp;
   if( ! (buff>>stmp) ) return -2;
   bool succeed;
   if( stmp == "clon" ) { 
      succeed = buff >> pimplES->clon; 
      if( succeed && pimplES->clon<0.) pimplES->clon += 360.; 
   }
   else if( stmp == "clat" ) succeed = buff >> pimplES->clat;
   else if( stmp == "Rs") succeed = buff >> pimplES->Rs;
   else if( stmp == "strike" ) succeed = buff >> FInfo().strike;
   else if( stmp == "dip" ) succeed = buff >> FInfo().dip;
   else if( stmp == "rake" ) succeed = buff >> FInfo().rake;
   else if( stmp == "depth" ) succeed = buff >> FInfo().depth;
   else if( stmp == "fRm" ) {
      std::string stmp1, stmp2, stmp3;
      float per;
      succeed = buff >> stmp1 >> stmp2 >> stmp3 >> per;
      if( succeed ) {
	 for(int iper=0; iper<pimplES->perRlist.size(); iper++) 
	    if(pimplES->perRlist.at(iper) == per) return -3;
	 pimplES->fRlist.push_back( std::array<std::string, 3>{ {stmp1, stmp2, stmp3} } );
	 pimplES->perRlist.push_back( per );
      }
   }
   else if( stmp == "fLm" ) {
      std::string stmp1, stmp2, stmp3;
      float per;
      succeed = buff >> stmp1 >> stmp2 >> stmp3 >> per;
      if( succeed ) {
	 for(int iper=0; iper<pimplES->perLlist.size(); iper++) 
	    if(pimplES->perLlist.at(iper) == per) return -3;
	 pimplES->fLlist.push_back( std::array<std::string, 3>{ {stmp1, stmp2, stmp3} } );
	 pimplES->perLlist.push_back( per );
      }
   }
   else if( stmp == "fmisL" ) {
      std::string& outname = pimplES->outname_mis;
      succeed = buff >> outname;
      if( succeed && access(outname.c_str(), F_OK) == 0 ) {
	 std::string oldname = outname + "_old";
	 std::cerr<<"Warning(EQKSearcher::Set): outfile "<<outname<<" already exists. Moving to "<<oldname<<std::endl;
	 rename(outname.c_str(), oldname.c_str());
      }
   }
   else if( stmp == "fmisF" ) {
      std::string& outname = FMisF();
      succeed = buff >> outname;
      if( succeed && access(outname.c_str(), F_OK) == 0 ) {
	 std::string oldname = outname + "_old";
	 std::cerr<<"Warning(EQKSearcher::Set): outfile "<<outname<<" already exists. Moving to "<<oldname<<std::endl;
	 rename(outname.c_str(), oldname.c_str());
      }
   }
   else if( stmp == "fRF" ) {
      std::string outname;
      float per;
      succeed = buff >> outname >> per;
      if( succeed ) {
	 if( access(outname.c_str(), F_OK) == 0 ) {
	    std::string oldname = outname + "_old";
	    std::cerr<<"Warning(EQKSearcher::Set): outfile "<<outname<<" already exists. Moving to "<<oldname<<std::endl;
	    rename(outname.c_str(), oldname.c_str());
	 }
	 pimplES->outlist_RF.push_back(outname);
	 pimplES->perRtmp.push_back(per);
      }
   }
   else if( stmp == "fLF" ) {
      std::string outname;
      float per;
      succeed = buff >> outname >> per;
      if( succeed ) {
	 if( access(outname.c_str(), F_OK) == 0 ) {
	    std::string oldname = outname + "_old";
	    std::cerr<<"Warning(EQKSearcher::Set): outfile "<<outname<<" already exists. Moving to "<<oldname<<std::endl;
	    rename(outname.c_str(), oldname.c_str());
	 }
	 pimplES->outlist_LF.push_back(outname);
	 pimplES->perLtmp.push_back(per);
      }
   }
   else return -1;
   if( succeed ) return 1;
   return 0;
}

bool EQKSearcher::LoadData() {
   int nfail = 0;

   for(int ifile=0; ifile<pimplES->fRlist.size(); ifile++) {
      std::ifstream fin(pimplES->fRlist.at(ifile).at(0).c_str());
      if( ! fin ) { nfail++; continue; }
      pimplES->per_sta_data_R.resize( pimplES->per_sta_data_R.size() + 1 );
      for(std::string line; std::getline(fin, line); ) {
	 pimplES->per_sta_data_R.at(ifile).push_back( StaData(line.c_str()) );
      }
      fin.close();
   }

   for(int ifile=0; ifile<pimplES->fLlist.size(); ifile++) {
      std::ifstream fin(pimplES->fLlist.at(ifile).at(0).c_str());
      if( ! fin ) { nfail++; continue; }
      pimplES->per_sta_data_L.resize( pimplES->per_sta_data_L.size() + 1 );
      for(std::string line; std::getline(fin, line); ) {
	 pimplES->per_sta_data_L.at(ifile).push_back( StaData(line.c_str()) );
      }
      fin.close();
   }


   if( nfail > 0 ) {
      std::cerr<<"Warning(EQKSearcher::LoadData): failed to load "<<nfail<<" of the data files!"<<std::endl;
      return false;
   }
   std::cout<<"### "<<pimplES->fRlist.size() + pimplES->fLlist.size()<<" data file(s) loaded. ###"<<std::endl;
   return true;
}


bool EQKSearcher::UpdateAziDis() {
   // check params and data
   if( pimplES->einfo.lon == -12345. || pimplES->einfo.lat == -12345. ) return false;
   if( pimplES->per_sta_data_R.size() == 0 && pimplES->per_sta_data_L.size() == 0 ) return false;
   // compute azimuths and distances
   pimplES->UpdateAziDis( pimplES->einfo, pimplES->per_sta_data_R);
   pimplES->UpdateAziDis( pimplES->einfo, pimplES->per_sta_data_L);
   // sort by azimuth
   std::vector< std::vector<StaData> >& dataR = pimplES->per_sta_data_R;
   for(int iper=0; iper<dataR.size(); iper++) {
      std::sort( dataR[iper].begin(), dataR[iper].end(), pimplES->CompareAziS );
   }
   std::vector< std::vector<StaData> >& dataL = pimplES->per_sta_data_L;
   for(int iper=0; iper<dataL.size(); iper++) {
      std::sort( dataL[iper].begin(), dataL[iper].end(), pimplES->CompareAziS );
   }

   int iper = 3;
}


bool EQKSearcher::UpdateFocalCorr() {
   if( pimplES->perRlist.size()==0 && pimplES->perLlist.size()==0 ) return false;

   // check Rayleigh source input
   if( pimplES->perRlist.size() != 0 &&
      (FREigName().empty() || FRPhvName().empty()) ) return false;
   
   // check Love source input
   if( pimplES->perLlist.size() != 0 &&
      (FLEigName().empty() || FLPhvName().empty()) ) return false;

   /* ------ Corrections for Rayleigh wave ----- */
   if( pimplES->perRlist.size() > 0 ) {
      //std::vector<float> perRlst;
      //for(int i=0; i<pimplES->perRlist.size(); i++) perRlst.push_back(pimplES->perRlist.at(i));
      std::vector<float>& perRlst = pimplES->perRlist;

      // initialize/reset prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      pimplES->per_azi_pred_R.clear();
      pimplES->per_azi_pred_R.resize( perRlst.size() );

      RadPatternR( FREigName(), FRPhvName(), FInfo(), perRlst, pimplES->per_azi_pred_R );

      for(int iper=0; iper<pimplES->per_sta_data_R.size(); iper++) {
	 std::vector< AziData >& adlist = pimplES->per_azi_pred_R.at(iper);
	 for(int idata=0; idata<pimplES->per_sta_data_R.at(iper).size(); idata++) {
	    StaData& sdtmp = pimplES->per_sta_data_R[iper][idata];
	    int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp, pimplES->CompareAziA )
		         - adlist.begin();
	    //int ipredh = 1;
	    //while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh-1;
	    if( ipredl == -1 ) ipredl = adlist.size() - 1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float factor = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    sdtmp.misG = adlist.at(ipredl).misG + (adlist.at(ipredh).misG-adlist.at(ipredl).misG) * factor;
	    sdtmp.misP = adlist.at(ipredl).misP + (adlist.at(ipredh).misP-adlist.at(ipredl).misP) * factor;
	    sdtmp.Apred = adlist.at(ipredl).A + (adlist.at(ipredh).A-adlist.at(ipredl).A) * factor;
	     //if(iper==3) std::cerr<<sdtmp.azi<<" "<<sdtmp.misG<<" "<<sdtmp.misP<<std::endl;
	 }
      }

   }

   /* ------ Corrections for Love wave ----- */
   if( pimplES->perLlist.size() > 0 ) {
      //std::vector<float> perLlst;
      //for(int i=0; i<pimplES->perLlist.size(); i++) perLlst.push_back(pimplES->perLlist.at(i).per);
      std::vector<float>& perLlst = pimplES->perLlist;

      // initialize prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      pimplES->per_azi_pred_L.clear();
      pimplES->per_azi_pred_L.resize( perLlst.size() );

      RadPatternR( FLEigName(), FLPhvName(), FInfo(), perLlst, pimplES->per_azi_pred_L );

      for(int iper=0; iper<pimplES->per_sta_data_L.size(); iper++) {
	 std::vector< AziData >& adlist = pimplES->per_azi_pred_L.at(iper);
	 for(int idata=0; idata<pimplES->per_sta_data_L.at(iper).size(); idata++) {
	    StaData& sdtmp = pimplES->per_sta_data_L.at(iper).at(idata);
	    int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp, pimplES->CompareAziA )
		         - adlist.begin();
	    //int ipredh = 1;
	    //while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh-1;
	    if( ipredl == -1 ) ipredl = adlist.size() - 1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float factor = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    sdtmp.misG = adlist.at(ipredl).misG + (adlist.at(ipredh).misG-adlist.at(ipredl).misG) * factor;
	    sdtmp.misP = adlist.at(ipredl).misP + (adlist.at(ipredh).misP-adlist.at(ipredl).misP) * factor;
	    sdtmp.Apred = adlist.at(ipredl).A + (adlist.at(ipredh).A-adlist.at(ipredl).A) * factor;
	 }
      }

   }

   return true;
}

bool EQKSearcher::OutputFocal() {
   // check data existence
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) return false;
   // check epicenter location
   EpicInfo& einfo = pimplES->einfo;
   if( einfo.lon==-12345. || einfo.lat==-12345. || einfo.t0==-12345. ) return false;
   // check vel pred maps
   if( pimplES->fRlist.size()!=Rsize || pimplES->fLlist.size()!=Lsize ) return false;
   for(int iper=0; iper<Rsize; iper++) {
      if( pimplES->outlist_RF.at(iper).empty() ) continue;
      if( access(pimplES->fRlist.at(iper).at(1).c_str(), R_OK) == -1 ) return false;
      if( access(pimplES->fRlist.at(iper).at(2).c_str(), R_OK) == -1 ) return false;
   }
   for(int iper=0; iper<Lsize; iper++) {
      if( pimplES->outlist_LF.at(iper).empty() ) continue;
      if( access(pimplES->fLlist.at(iper).at(1).c_str(), R_OK) == -1 ) return false;
      if( access(pimplES->fLlist.at(iper).at(2).c_str(), R_OK) == -1 ) return false;
   }

   // output misfit ( measured + t0 - predicted ) and focal_corrections for Rayleigh
   float srclon = einfo.lon, srclat = einfo.lat, srct0 = einfo.t0;
   for(int iper=0; iper<Rsize; iper++) {
      // open output file 
      std::string outname = pimplES->outlist_RF.at(iper);
      if( outname.empty() ) continue;
      //outname += "_" + std::string(label);
      std::ofstream fout( outname, std::ofstream::app );
      // read in vel maps
      std::string& fname1 = pimplES->fRlist.at(iper).at(1);
      if( access(fname1.c_str(), R_OK) == -1 ) return false;
      Map map1(fname1.c_str(), Point<float>(srclon, srclat));
      std::string& fname2 = pimplES->fRlist.at(iper).at(2);
      if( access(fname2.c_str(), R_OK) == -1 ) return false;
      Map map2(fname2.c_str(), Point<float>(srclon, srclat));
      // period and wavelength
      float per = pimplES->perRlist.at(iper), lamda = per*3.;
      fout<<"# [ epic = "<<EInfo()<<"  focal = "<<FInfo()<<" ]"<<std::endl;
      for(int idat=0; idat<pimplES->per_sta_data_R.at(iper).size(); idat++) {
	 StaData& sdcur = pimplES->per_sta_data_R[iper][idat];
	 float percG, percP;
	 float misG = sdcur.grT + srct0 - sdcur.dist/
		      map1.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda, percG );
	 float misP = sdcur.phT + srct0 - sdcur.dist/
		      map2.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda, percP );
	 if( percG < 0.9 || percP < 0.9 ) continue;
	 // correct 2pi
	 misP -= sdcur.misP;
	 while( misP > 0.5*per ) misP -= per;
	 while( misP < -0.5*per ) misP += per;
	 misP += sdcur.misP;
	 fout<<sdcur.azi<<"   "<<misG<<" "<<sdcur.misG<<"   "<<misP<<" "
	     <<sdcur.misP<<"   "<<sdcur.A<<" "<<sdcur.Apred<<std::endl;
      }
      fout<<std::endl<<std::endl; fout.close();
   }

   // output misfit ( measured + t0 - predicted ) and focal_corrections for Love
   for(int iper=0; iper<Lsize; iper++) {
      // open output file 
      std::string outname = pimplES->outlist_LF.at(iper);
      if( outname.empty() ) continue;
      //outname += "_" + std::string(label);
      std::ofstream fout( outname, std::ofstream::app );
      // read in vel maps
      std::string& fname1 = pimplES->fLlist.at(iper).at(1);
      if( access(fname1.c_str(), R_OK) == -1 ) return false;
      Map map1(fname1.c_str(), Point<float>(srclon, srclat));
      std::string& fname2 = pimplES->fLlist.at(iper).at(2);
      if( access(fname2.c_str(), R_OK) == -1 ) return false;
      Map map2(fname2.c_str(), Point<float>(srclon, srclat));
      // period and wavelength
      float per = pimplES->perLlist.at(iper), lamda = per*3.;
      fout<<"# [ epic = "<<EInfo()<<"  focal = "<<FInfo()<<" ]"<<std::endl;
      for(int idat=0; idat<pimplES->per_sta_data_L.at(iper).size(); idat++) {
	 StaData& sdcur = pimplES->per_sta_data_L[iper][idat];
	 float percG, percP;
	 float misG = sdcur.grT + srct0 - sdcur.dist/
		      map1.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda, percG );
	 float misP = sdcur.phT + srct0 - sdcur.dist/
		      map2.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda, percP );
	 if( percG < 0.9 || percP < 0.9 ) continue;
	 // correct 2pi
	 misP -= sdcur.misP;
	 while( misP > 0.5*per ) misP -= per;
	 while( misP < -0.5*per ) misP += per;
	 misP += sdcur.misP;
	 fout<<sdcur.azi<<"   "<<misG<<" "<<sdcur.misG<<"   "<<misP<<" "
	     <<sdcur.misP<<"   "<<sdcur.A<<" "<<sdcur.Apred<<std::endl;
      }
      fout<<std::endl<<std::endl; fout.close();
   }

   return true;
}

bool EQKSearcher::Energy( EpicInfo& einfo, float& E ) {

   // check input params
   if( einfo.lon==-12345. || einfo.lat==-12345. || einfo.t0==-12345. ) return false;
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) return false;

   E = 0.;
   float srclon = einfo.lon, srclat = einfo.lat, srct0 = einfo.t0;

   // compute misfit (measured + t0 - predicted - focal_correction ) for Rayleigh maps
   std::vector< std::vector<StaData> > dataR = pimplES->per_sta_data_R;
   pimplES->UpdateAziDis( einfo, dataR );
   pimplES->UpdateFocalCorrR( einfo, dataR );
   for(int iper=0; iper<Rsize; iper++) {
      std::string& fname1 = pimplES->fRlist.at(iper).at(1);
      if( access(fname1.c_str(), R_OK) == -1 ) return false;
      Map map1(fname1.c_str(), Point<float>(srclon, srclat));

      std::string& fname2 = pimplES->fRlist.at(iper).at(2);
      if( access(fname2.c_str(), R_OK) == -1 ) return false;
      Map map2(fname2.c_str(), Point<float>(srclon, srclat));

      // compute azimuthally average
      //float binstep = 5, binhwidth = 8;
      //std::vector<AziData> dataAzi;
      float per = pimplES->perRlist.at(iper), lamda = per*3.;
      //if( ! pimplES->BinAverage( dataR[iper], binstep, binhwidth, dataAzi, per ) ) return false;
      std::vector<float> misGV, misPV;
      for( int idat=0; idat<dataR[iper].size(); idat++ ) {
	 StaData& sdcur = dataR[iper][idat];
	 float percG, percP;
	 float misG = sdcur.grT + srct0 - sdcur.misG - 
		      sdcur.dist/map1.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda, percG );
	 float misP = sdcur.phT + srct0 - sdcur.misP - 
		      sdcur.dist/map2.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda, percP );
	 while( misP > 0.5*per ) misP -= per;
	 while( misP < -0.5*per ) misP += per;
	 if( percG > 0.9 ) misGV.push_back( misG*misG );
	 if( percP > 0.9 ) misPV.push_back( misP*misP);
	 //if( iper==3 && percG>0.9 && percP>0.9 ) std::cerr<<sdcur.azi<<" "<<sdcur.grT + srct0 - sdcur.dist/map1.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda )<<" "<<sdcur.misG<<"   "<<sdcur.phT + srct0 - sdcur.dist/map2.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda )<<std::endl;
	 //if(iper==3 && percG>0.9 && percP>0.9) std::cerr<<sdcur.azi<<" "<<misG<<" "<<misP<<std::endl;
      }
      // compute average misfit square (excluding bad data)
      float EG, EP, var;
      std::vector<float> weit;
      weit.resize(misGV.size(), 1);
      if( ! pimplES->DataAvg( misGV, weit, EG, var ) ) return false;
      weit.resize(misPV.size(), 1);
      if( ! pimplES->DataAvg( misPV, weit, EP, var ) ) return false;
      E += EG*0.2 + EP*0.8;// / dataR[iper].size() );
   }

   // compute misfit (measured + t0 - predicted - focal_correction) for Love maps
   std::vector< std::vector<StaData> > dataL = pimplES->per_sta_data_L;
   pimplES->UpdateAziDis( einfo, dataL );
   pimplES->UpdateFocalCorrL( einfo, dataL );
   for(int iper=0; iper<Lsize; iper++) {
      std::string& fname1 = pimplES->fLlist.at(iper).at(1);
      if( access(fname1.c_str(), R_OK) == -1 ) return false;
      Map map1(fname1.c_str(), Point<float>(srclon, srclat));
      std::string& fname2 = pimplES->fLlist.at(iper).at(2);
      if( access(fname2.c_str(), R_OK) == -1 ) return false;
      Map map2(fname2.c_str(), Point<float>(srclon, srclat));

      float per = pimplES->perLlist.at(iper), lamda = per*3.;
      std::vector<float> misGV, misPV;
      for( int idat=0; idat<dataL[iper].size(); idat++ ) {
	 StaData& sdcur = dataL[iper][idat];
	 float percG, percP;
	 float misG = sdcur.grT + srct0 - sdcur.misG - 
		      sdcur.dist/map1.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda, percG );
	 float misP = sdcur.phT + srct0 - sdcur.misP - 
		      sdcur.dist/map2.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda, percP );
	 while( misP > 0.5*per ) misP -= per;
	 while( misP < -0.5*per ) misP += per;
	 if( percG > 0.9 ) misGV.push_back( misG*misG );
	 if( percP > 0.9 ) misPV.push_back( misP*misP);
      }
      // compute average misfit square (excluding bad data)
      float EG, EP, var;
      std::vector<float> weit;
      weit.resize(misGV.size(), 1);
      if( ! pimplES->DataAvg( misGV, weit, EG, var ) ) return false;
      weit.resize(misPV.size(), 1);
      if( ! pimplES->DataAvg( misPV, weit, EP, var ) ) return false;
      E += EG*0.2 + EP*0.8;
   }

   E /= (Rsize + Lsize);

   return true;
}

bool EQKSearcher::PrepareFocalData() {
   // check source files
   if( pimplES->fReigname.empty() || pimplES->fRphvname.empty() ) return false;
   FEigName() = pimplES->fReigname;
   FPhvName() = pimplES->fRphvname;

   // check einfo
   EpicInfo einfo = pimplES->einfo;
   if( einfo.lon==-12345. || einfo.lat==-12345. || einfo.t0==-12345. ) return false;
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) return false;

   float srclon = einfo.lon, srclat = einfo.lat, srct0 = einfo.t0;

   // compute misfit (measured + t0 - predicted) for Rayleigh maps
   std::vector< std::vector<StaData> > dataR = pimplES->per_sta_data_R;
   pimplES->UpdateAziDis( einfo, dataR );
   //pimplES->UpdateFocalCorrR( einfo, dataR );
   Per_Azi_Data().clear(); Per_Azi_Data().resize(Rsize);
   PerList().clear(); PerList().resize(Rsize);
   for(int iper=0; iper<Rsize; iper++) {
      std::string& fname1 = pimplES->fRlist.at(iper).at(1);
      if( access(fname1.c_str(), R_OK) == -1 ) return false;
      Map map1(fname1.c_str(), Point<float>(srclon, srclat));

      std::string& fname2 = pimplES->fRlist.at(iper).at(2);
      if( access(fname2.c_str(), R_OK) == -1 ) return false;
      Map map2(fname2.c_str(), Point<float>(srclon, srclat));

      float per = pimplES->perRlist.at(iper), lamda = per*3.;
      // compute misfits and store in a vector for bin-average later
      for( int idat=0; idat<dataR[iper].size(); idat++ ) {
	 StaData& sdcur = dataR[iper][idat];
	 float percG, percP;
	 sdcur.misG = sdcur.grT + srct0 - 
		      sdcur.dist/map1.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda, percG );
	 float misP = sdcur.phT + srct0 - sdcur.misP -
		      sdcur.dist/map2.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda, percP );
	 if( percG < 0.9 ) sdcur.misG = -12345.;
	 if( percP < 0.9 ) {
	    sdcur.misP = -12345.;
	 }
	 else {
	    while( misP > 0.5*per ) misP -= per;
	    while( misP < -0.5*per ) misP += per;
	    sdcur.misP = misP + sdcur.misP;
	 }
	 //Ecur += misG*misG*0.5 + misP*misP*0.5;
      }
      std::sort( dataR[iper].begin(), dataR[iper].end(), pimplES->CompareAziS );
      // bin average 
      float binstep = 5., binhwidth = 8.;
      if( ! pimplES->BinAverage( dataR[iper], binstep, binhwidth, Per_Azi_Data().at(iper), per ) ) return false;
      PerList().at(iper) = PerDazi( per, binhwidth );
      for( int idat=0; idat<dataR[iper].size(); idat++ ) {
	 StaData& sdcur = dataR[iper][idat];
      }
      //E += Ecur;// / dataR[iper].size() );
   }


   return true;
}


bool EQKSearcher::SearchLocation( int nsearch, float alpha, float Tfactor ) {
   // check parameters
   if( pimplES->clon==-12345. || pimplES->clat==-12345. || pimplES->Rs==-12345. ) return false;
   // check input measurements
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) return false;
   if( pimplES->perRlist.size() != Rsize || pimplES->perLlist.size() != Lsize ) return false;
   // check vel maps
   for(int iper=0; iper<Rsize; iper++) {
      if( access(pimplES->fRlist.at(iper).at(1).c_str(), R_OK) == -1 ) return false;
      if( access(pimplES->fRlist.at(iper).at(2).c_str(), R_OK) == -1 ) return false;
   }
   for(int iper=0; iper<Lsize; iper++) {
      if( access(pimplES->fLlist.at(iper).at(1).c_str(), R_OK) == -1 ) return false;
      if( access(pimplES->fLlist.at(iper).at(2).c_str(), R_OK) == -1 ) return false;
   }

   // simulated annealing
   float E;
   if( ! Energy(pimplES->einfo, E) ) return false;
   float T = E * Tfactor;
   std::cout<<"### SearchLocation: Initial Misfit**2 for "<<pimplES->einfo<<" = "<<E<<" T="<<T<<" ###"<<std::endl;
   EpicInfo einfobest = pimplES->einfo;
   float Ebest = E;
   int nrej = 0;
   int isearch = 0;
   std::ofstream fout;
   bool output_mis = ! pimplES->outname_mis.empty();
   if( output_mis ) fout.open(  pimplES->outname_mis.c_str(), std::ofstream::app );
   
   fout<<"# [ epic = "<<EInfo()<<" ]"<<std::endl;
   fout<< "-1\t" << E << "\t" << T << std::endl;
   #pragma omp parallel for
   for( int i=0; i<nsearch; i++ ) {
      EpicInfo einfonew = pimplES->Neighbour( pimplES->einfo );
      float Enew = -12345.;
      if( ! Energy(einfonew, Enew) ) continue;
      if( pimplES->Accept(E, Enew, T) ) {
	 pimplES->einfo = einfonew;
	 E = Enew;
	 if( output_mis ) {
	#pragma omp critical
	{ // critical start
	    fout<< isearch << "\t" << Enew << "\t" << T << std::endl;
	    fout.flush();
	} // critical end
	 }
	 std::cout<<"   Misfit**2 for "<<einfonew<<" = "<<Enew<<" (accepted)  T="
		  <<T<<"  isearch="<<isearch<<"/"<<nsearch<<std::endl;
	 nrej = 0;
      }
      else { nrej++; std::cout<<"( nrejects = "<<nrej<<" )"<<"  ithread="<<omp_get_thread_num()<<"                  "<<std::endl<<"\x1b[A"; }
     #pragma omp critical
     { // critical start
      T *= alpha;
      if( Enew < Ebest ) {
	 einfobest = einfonew;
	 Ebest = Enew;
      }
      isearch++;
     } // critical end
   }
   fout<< isearch << "\t" << Ebest << "\t" << T << std::endl;
   fout<<std::endl<<std::endl; fout.close();
   std::cout<<"                                   "<<std::endl;
   pimplES->einfo = einfobest;

   return true;
}

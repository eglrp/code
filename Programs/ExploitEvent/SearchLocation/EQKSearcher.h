#ifndef EQKSEARCHER_H
#define EQKSEARCHER_H
#include "FocalSearcher.h"
#include "ModelSpace.h"
#include "RadPattern.h"
#include "Exceptions.h"
#include "FileName.h"
#include <memory>
#include <fstream>


/* Location, travel_time, amplitude, misfit, and
 * corrections on a single station, derived from AziData */
struct StaData : public AziData {
   float lon, lat;
   float dist;
   float grT, phT, Apred;

   StaData()
      : AziData() 
      , lon(NaN), lat(NaN), dist(NaN), grT(NaN), phT(NaN) {}

   StaData( float lonin, float latin, float distin, float grTin,
	    float phTin, float aziin, float misGin, float misPin, float ampin )
      : AziData( aziin, misGin, misPin, ampin )
      , lon(lonin), lat(latin), dist(distin), grT(grTin), phT(phTin) {}

   StaData( const char *input, float ph_shift = 0. ) 
      : AziData() {
      sscanf(input, "%f %f %f %f %f", &lon, &lat, &grT, &phT, &A);
		phT += ph_shift;
   }

	bool isComplete() const { return ( lon!=NaN && lat!=NaN && grT!=NaN && phT!=NaN && A!=NaN );	}

	void streamTo ( std::ofstream& fout, int nformat = 1 ) const {
		if( nformat == 1 ) {
			fout<<azi<<"   "<<varG<<" "<<misG<<"   "
				 <<varP<<" "<<misP<<"   "<<A<<" "<<Apred<<"\n";
		} else if( nformat == 2 ) {
			fout<<lon<<" "<<lat<<"   "<<grT-varG<<" "<<varG<<"   "
				 <<phT-varP<<" "<<varP<<"   "<<Apred<<" "<<A<<"   "
				 <<dist<<"   "<<azi<<"\n";
		}
	}

   friend std::ostream& operator<< ( std::ostream& o, const StaData& sd ) {
      o<<"( "<<sd.lon<<", "<<sd.lat<<" ): dist = "<<sd.dist
       <<" grT = "<<sd.grT<<" phT = "<<sd.phT<<"    "<<sd.azi;
      return o;
   }

};


/* Earthquake-source searcher, derived from the focal searcher.
 * Can either search for EpicInfo with a fixed FocalInfo
 * or search for FocalInfo with a fixed EpicInfo */
/* a better structure, however, would be:
class EQKSearcher {
	FocalSearcher fSearcher;
	LocationSearcher lSearcher;
} */
class EQKSearcher : public FocalSearcher {
public:
   /* con/destructors and operators */
   EQKSearcher();
   EQKSearcher( const std::string, bool MoveExistF = true );
   EQKSearcher( const EQKSearcher& );
   EQKSearcher( EQKSearcher&& );
   EQKSearcher& operator= ( const EQKSearcher& );
   EQKSearcher& operator= ( EQKSearcher&& );
   ~EQKSearcher();

   /* getter for the current Focal & Epic Info */
   const FocalInfo<ftype>& FInfo() const;
   const EpicInfo& EInfo() const;

   /* prepare database */
   void LoadParams( const FileName&, const bool MoveExistF = true );
   int Set( const char*, const bool MoveExistF = true );
	void CheckParams();
   void LoadData();

   /* output misfit-v.s.-focal_corrections
    * should always be called after UpdateAziDis() and UpdateFocalCorr() */
	enum OutType { FIT, MAP };
   void Output( bool excludeBad = false, const OutType otype = FIT );
	/* compute and output misfits, separately, for group, phase, and amplitudes */
	void ComputeMisfitsAll();

   /* compute rms-misfit square */
   std::string EnergyL( const EpicInfo& einfo, float& E );
   void chiSquareL( const EpicInfo& einfo, float& chiS, float& wSum, int& N, std::string& sDValid );
   /* search for the location assuming fixed focal corrections */
   void SearchLocation( int nsearch, float alpha, float Tfactor );

   /* extended version of the focal searcher
    * which prepares AziData from the StaData prior to searching */
   void SearchFocal( int nsearch, float alpha, float Tfactor );

   /* compute chi-square misfit at the current einfo and finfo */
   void EnergyMC( const ModelInfo&, float& chiS, int& Ndata );
   /* search for the posterior distribution around the current einfo and finfo 
		(search in the entire focal space instead when freeFocal==true) */
   void SearchPosterior( const int nsearch1, const int nsearch2, int niter2 );
   void SearchPosterior( const int nsearch1, const int nsearch2, const bool freeFocal = false );

protected:
   /* define class scope constants */
   static constexpr int MIN_BAZI_SIZE = 4;		/* allowed min number of measurements in each azimuth bin */
   static constexpr float BINSTEP = 20;			/* bin averaging step size */
   static constexpr float BINHWIDTH = 10;			/* bin averaging half width */

   static constexpr float Min_Perc = 0.95;		/* allowed min fraction of path length in the vel map */
   static constexpr float Lfactor = 2.;			/* define lamda = per * Lfactor for PathAvg */

   static constexpr float DISMIN = 0.;				/* allowed min */
   static constexpr float DISMAX = 9999.;			/* and max event-station distance for location searching */

   static constexpr float varGmin = 0.1;			/* the lowerbound of GroupT, */
   static constexpr float varPmin = 0.01;			/* PhaseT, */
   static constexpr float varAmin = 2.0e-5;		/* and Amplitude (as fraction of the amplitude!) variances */

   static constexpr float Pthreshold = 0.005;	/* the threshold for probability in searching for parameter
																	sensitivity prior to the Monte Carlo search, */
   static constexpr float Sfactor = 0.1;			/* and the step half-length for the search as a fraction
																	of (ub-lb) decided by Pthreshold */

	static constexpr int pio4_R = 0;					/* for initial phase test. normaly be 0. */
	static constexpr int pio4_L = 0;					/* is added to the FTAN coefficient piover4 */

	/* protected methods that might be useful for future extensions */

   /* update azimuth, distance, and corrections for each station 
      based on the current location and focal information 
      for both Rayleigh and Love waves */
   void UpdateAziDis();
   void UpdateFocalPred();
	void UpdateTrvtPred( const bool c2pi );
	void UpdateTrvtPred( const EpicInfo&, std::vector< std::vector<StaData> >& dataR, 
								std::vector< std::vector<StaData> >& dataL, const bool c2pi );

	/* read fitting results from the result file */
	bool ReadResults( const FileName& fname, std::vector<AziData>& FitResults );
	void ComputeMisfits( const std::vector<AziData>& FitResults, AziData& results );

   /* compute azimuthally averaged misfits */
   void FillFocalSearcher();
   void PrepareAziData ( std::vector< std::vector<AziData> >& AziDataR, std::vector<PerDazi>& perRlst,
								 std::vector< std::vector<AziData> >& AziDataL, std::vector<PerDazi>& perLlst ) const;
	void PrepareAziData( const std::vector< std::vector<StaData> >& dataR, const std::vector<float>& perRlstin,
								const std::vector< std::vector<StaData> >& dataL, const std::vector<float>& perLlstin,
								std::vector< std::vector<AziData> >& resultR, std::vector<PerDazi>& perRlst,
								std::vector< std::vector<AziData> >& resultL, std::vector<PerDazi>& perLlst ) const;
   void MonteCarloSearch( int nsearch, ModelSpace&, std::vector< SearchInfo<ModelInfo> >&, bool outflag=false );
   float SearchBound( ModelInfo& minfo, float& key, float bound, float Pthsd, float Emin, int nsearch );

private:
	/* pointer to implementation details */
   struct EQimpl;
   std::unique_ptr<EQimpl> pimplES;
};

#endif

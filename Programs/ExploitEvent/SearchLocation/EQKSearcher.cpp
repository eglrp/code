#include "EQKSearcher.h"
#include "RadPattern.h"
#include "DisAzi.h"
#include "Map.h"
#include "FileName.h"
#include <cstdlib>
#include <unistd.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <algorithm>
//#include <omp.h>
#include "MyOMP.h"


/* -------------------- implimentation details -------------------- */
struct EQKSearcher::EQimpl {

   float clon, clat, Rs;
   float Rt, Rlon, Rlat;
   EpicInfo einfo;

   FileName fparam;					// parameter file
   FileName outname_misF;				// filename for output focal misfit
   FileName outname_misL;				// filename for output location misfit
   FileName outname_pos;				// filename for output posterior distribution
   FileName fReigname, fRphvname;			// input eigen-function file
   FileName fLeigname, fLphvname;			// input phase-velocity file
   std::vector< FileName > outlist_RF, outlist_LF;	// filename for output focal_fit
   std::vector< std::vector<FileName> > fRlist, fLlist;

   std::vector<float> perRtmp, perLtmp;			// tmp period list
   std::vector<float> perRlist, perLlist;		// period list for rayleigh and love waves
   /* It's perfectly OK to use vector of vector here as the data for each
    * period are accessed independently. Consider changing to Array2D if 
    * the access pattern is changed somehow */
   std::vector< std::vector<StaData> > per_sta_data_R, per_sta_data_L;
   std::vector< std::vector<AziData> > per_azi_pred_R, per_azi_pred_L;

   RadPattern rpR, rpL;

   Rand randO;

   //number of data points for EnergyMC
   int NC;


   EQimpl( const char* fparamin = "", float clonin = -12345.,
	   float clatin = -12345., float Rsin = -12345. )
      : fparam(fparamin), clon(clonin), clat(clatin), Rs(Rsin), Rt(20.), NC(-12345) {
      Initialize();
   }

   // set search ranges
   bool Initialize() {
      if( Rs>0 && clon!=-12345 && clat!=-12345 ) {
	 double dist;
	 //calc_dist(clat, clon, clat, clon+1, &dist);
	 dist = Path<double>(clon, clat, clon+1., clat).Dist();
	 Rlon = Rs / dist;
	 //calc_dist(clat, clon, clat+1, clon, &dist);
	 dist = Path<double>(clon, clat, clon, clat+1.).Dist();
	 Rlat = Rs / dist;
	 einfo = EpicInfo(clon, clat, 0.);
	 return true;
      }
      else {
	 Rlon = Rlat = -12345.;
	 return false;
      }
   }

   // check parameters 
   inline void CheckSearchArea() const {
      if( clon==-12345. || clat==-12345. || Rs==-12345. )
	 throw ErrorFS::BadParam(FuncName, "invalid clon || clat || Rs");
   }
   inline void CheckEInfo() const { CheckEInfo(this->einfo); }
   inline void CheckEInfo(const EpicInfo& einfoin) const {
      if( einfoin.lon==-12345. || einfoin.lat==-12345. || einfoin.t0==-12345. )
	 throw ErrorFS::BadParam(FuncName, "invalid einfo.lon || einfo.lat || einfo.t0");
   }

   inline void AziFactor( AziData& dat_l, AziData& dat_m, AziData& dat_h, float& azifactor ) {
      float azi_l = dat_l.azi, azi_m = dat_m.azi, azi_h = dat_h.azi;
      if( azi_m == azi_l ) { azifactor = 0.; return; }
      if( azi_m == azi_h ) { azifactor = 1.; return; }
      if( azi_l > azi_h ) {
	 azi_h += 360.;
	 if( azi_m < azi_l ) azi_m += 360.;
      }
      if( azi_l>azi_m || azi_m>azi_h )
	 throw std::runtime_error( std::to_string(azi_l)+" - "+std::to_string(azi_m)+" - "+std::to_string(azi_h) );
      azifactor = (dat_m.azi - dat_l.azi) / (dat_h.azi - dat_l.azi);
   }

   // accept criterion for simulated annealing
   bool Accept(float E, float Enew, double T) {
      /*
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
      std::default_random_engine generator (timeseed);
      std::uniform_real_distribution<float> distribution(0., 1.);
      auto rand = std::bind ( distribution, generator );
      */
      bool accept;
      if(Enew<E) {
	 accept = true;
      } else if(randO.Uniform()<exp((E-Enew)/T)) {
	 accept = true;
      } else {
	 accept = false;
      }
      //std::cerr<<"E="<<E<<" Enew="<<Enew<<"  accept="<<accept<<" "<<ftmp<<" "<<exp((E-Enew)/T)<<std::endl;
      return accept;
   }

   inline float Neighbour_Reflect( float valold, float hlen, float lb, float ub ) {
      float range = ub - lb;
      float shift = randO.Normal() * hlen;
      if( shift > range ) shift = range;
      else if( shift < -range ) shift = -range;
      float valnew = valold + shift;
      if( valnew >= ub ) { valnew = 2.*ub-valnew; }
      else if( valnew < lb ) { valnew = 2.*lb-valnew; }
      return valnew;
   }

   // perturb model parameters
   EpicInfo Neighbour( const EpicInfo& einfo ) {

      EpicInfo einfonew;// = einfo;

      float ht = Rt * 0.1;
      float hlon = Rlon * 0.1, hlat = Rlat * 0.1;

      einfonew.lon = Neighbour_Reflect(einfo.lon, hlon, clon-Rlon, clon+Rlon);
      einfonew.lat = Neighbour_Reflect(einfo.lat, hlat, clat-Rlat, clat+Rlat);
      einfonew.t0  = Neighbour_Reflect(einfo.t0, ht, -Rt, Rt);

      return einfonew;
   }

   void PerturbModel( const FocalInfo<ftype>& finfoin, const EpicInfo& einfoin,
		      FocalInfo<ftype>& finfonew, EpicInfo& einfonew, 
		      const FocalInfo<ftype>& finfoc, const EpicInfo& einfoc, 
		      float Rlon, float Rlat, float Rtim, 
		      ftype Rstk, ftype Rdip, ftype Rrak, ftype Rdep) {
      float sfactor = 0.1; // step length as percentage of the range

      finfonew.strike = Neighbour_Reflect(finfoin.strike, Rstk*sfactor, finfoc.strike-Rstk, finfoc.strike+Rstk);
      while( finfonew.strike >= 360. ) finfonew.strike -= 360.;
      while( finfonew.strike < 0. ) finfonew.strike += 360.;

      float lb = finfoc.dip-Rdip, ub = finfoc.dip+Rdip;
      if( lb < 0. ) lb = 0.;
      if( ub > 90. ) ub = 90.;
      finfonew.dip = Neighbour_Reflect(finfoin.dip, Rdip*sfactor, lb, ub);

      finfonew.rake = Neighbour_Reflect(finfoin.rake, Rrak*sfactor, finfoc.rake-Rrak, finfoc.rake+Rrak);
      while( finfonew.rake >= 180. ) finfonew.rake -= 360.;
      while( finfonew.rake < -180. ) finfonew.rake += 360.;

      lb = finfoc.depth-Rdep; ub = finfoc.depth+Rdep;
      if( lb < 0. ) lb = 0.;
      finfonew.depth = Neighbour_Reflect(finfoin.depth, Rdep*sfactor, lb, ub);

      einfonew.lon = Neighbour_Reflect(einfoin.lon, Rlon*sfactor, einfoc.lon-Rlon, einfoc.lon+Rlon);

      einfonew.lat = Neighbour_Reflect(einfoin.lat, Rlat*sfactor, einfoc.lat-Rlat, einfoc.lat+Rlat);

      einfonew.t0 = Neighbour_Reflect(einfoin.t0, Rtim*sfactor, einfoc.t0-Rtim, einfoc.t0+Rtim);

   }


   // compute azimuth and distance for each station based on the input epicenter location
   void UpdateAziDis( const EpicInfo& einfoin, std::vector< std::vector<StaData> >& datain ) {
      float srclon = einfoin.lon, srclat = einfoin.lat;

      for(int iper=0; iper<datain.size(); iper++) {
	 for(int idata=0; idata<datain.at(iper).size(); idata++) {
	    StaData& sdtmp = datain[iper][idata];
	    //double azi, dist;
	    //calc_dist(srclat, srclon, sdtmp.lat, sdtmp.lon, &dist);
	    //calc_azimuth(srclat, srclon, sdtmp.lat, sdtmp.lon, &azi);
	    Path<double> pathcur(srclon, srclat, sdtmp.lon, sdtmp.lat);
	    sdtmp.dist = pathcur.Dist();
	    sdtmp.azi = pathcur.Azi1();
	    sdtmp.valid = true;
	    //if( azi<210 && azi>160 ) sdtmp.valid = false;
	 }
      }
   }

   // update focal corrections for rayleigh or Love wave measurements
   // !!! Note that this only updates corrections for each station based on the new source location,
   // the focal predictions are not updated !!!
   void UpdateFocalCorr( const EpicInfo& einfoin, std::vector< std::vector<StaData> >& datain, 
						  std::vector< std::vector<AziData> >& Mpred ) {
      if( datain.size()==0 ) throw ErrorFS::EmptyData(FuncName);
      if( datain.size() != Mpred.size() ) throw ErrorFS::SizeMismatch(FuncName, "datain - Mpred");

      for(int iper=0; iper<datain.size(); iper++) {
	 std::vector< AziData >& adlist = Mpred.at(iper);
	 for(int idata=0; idata<datain.at(iper).size(); idata++) {
	    StaData& sdtmp = datain[iper][idata];
	    if( ! sdtmp.valid ) continue;
	    /* binary search for sdtmp.azi in per_azi_pred list */
	    int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp, CompareAziA ) - adlist.begin();
	    //int ipredh = 1;
	    //while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh==0 ? adlist.size()-1:ipredh-1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float azifactor;// = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    try {
		AziFactor(adlist[ipredl], sdtmp, adlist[ipredh], azifactor);
	    } catch( std::runtime_error& eazi ) {
		throw ErrorFS::BadAzi(FuncName, eazi.what());
	    }
	    sdtmp.misG = adlist[ipredl].misG + (adlist[ipredh].misG-adlist[ipredl].misG) * azifactor;
	    sdtmp.misP = adlist[ipredl].misP + (adlist[ipredh].misP-adlist[ipredl].misP) * azifactor;
	    //if(iper==3) std::cerr<<sdtmp.azi<<" "<<sdtmp.misG<<" "<<sdtmp.misP<<std::endl;
	 }
      }

   }

/*
   // update focal corrections for Love wave measurements
   void UpdateFocalCorrL( const EpicInfo& einfoin, std::vector< std::vector<StaData> >& datain ) {
      if( datain.size()==0 ) throw ErrorFS::EmptyData(FuncName);
      if( datain.size() != per_azi_pred_L.size() ) throw ErrorFS::SizeMismatch(FuncName, "datain - per_azi_pred_L");

      for(int iper=0; iper<datain.size(); iper++) {
	 std::vector< AziData >& adlist = per_azi_pred_L.at(iper);
	 for(int idata=0; idata<datain.at(iper).size(); idata++) {
	    StaData& sdtmp = datain[iper][idata];
	    if( ! sdtmp.valid ) continue;
	    int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp, CompareAziA ) - adlist.begin();
	    //int ipredh = 1;
	    //while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh==0 ? adlist.size()-1:ipredh-1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float azifactor;// = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    try {
		AziFactor(adlist[ipredl], sdtmp, adlist[ipredh], azifactor);
	    } catch( std::runtime_error& eazi ) {
		throw ErrorFS::BadAzi(FuncName, eazi.what());
	    }
	    sdtmp.misG = adlist[ipredl].misG + (adlist[ipredh].misG-adlist[ipredl].misG) * azifactor;
	    sdtmp.misP = adlist[ipredl].misP + (adlist[ipredh].misP-adlist[ipredl].misP) * azifactor;
	 }
      }

   }
*/

   // erase (from a vector) data that are larger than mean + 2 sigma
   bool ExcludeLarge( std::vector<float>& data, std::vector<float>& weight ) {
      if( data.size() != weight.size() ) return false;
      // compute mean 1
      float V1 = 0., mean1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 mean1 += data[i] * weight[i];
	 V1 += weight[i];
      }
      mean1 /= V1;
      // compute std1
      float V2 = 0., std1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 float ftmp = data[i]-mean1;
	 std1 += ftmp * ftmp * weight[i];
	 V2 += weight[i] * weight[i];
      }
      std1 = sqrt( std1 * V1 / (V1*V1-V2) );
      // exclude larger-than-2sigma data
      float ubound = mean1 + 2.0*std1;// lbound = mean1 - 2.0*std1;
      int i=0;
      while( i<data.size() ) {
	 if( data[i]>ubound ) {
	    data.erase( data.begin() + i );
	    weight.erase( weight.begin() + i );
	 } else {
	    i++;
	 }
      }

      return true;
   }

   // Suppress a vector of data for 2pis. The median of the vector is used as reference
   void Suppress2PI( std::vector<float>& data, float per ) {
      if( data.size() <= 1 ) return;
      // suppress the misfit into the -per/2 ~ per/2 range
      float pero2 = per * 0.5;
      for(int idat=0; idat<data.size(); idat++) {
	 while( data[idat] > pero2 ) data[idat] -= per;
	 while( data[idat] <= -pero2 ) data[idat] += per;
      }
      // find the median as reference
      /* The nth_element() function causes glibc() when compiled with gcc 4.8.2.,
       * which is a bug in the current standard library.
       * gcc 4.8.0 seems to be working fine */
      /* uncomment if 4.8.1/4.8.2 is not used */
      std::vector<float> datatmp(data); 
      int halfs = datatmp.size() / 2;
      std::nth_element(datatmp.begin(), datatmp.begin()+halfs-1, datatmp.end());
      float median = datatmp.at(halfs-1);
      /*/ use partial_sort instead if 4.8.1/4.8.2 is used
      std::vector<float> datatmp(data);
      int halfs = datatmp.size() / 2;
      std::partial_sort(datatmp.begin(), datatmp.begin()+halfs, datatmp.end());
      float median = datatmp.at(halfs-1); */
      /*/ find the average as reference
      float median = 0.;
      for(int idat=0; idat<data.size(); idat++) median += data[idat];
      median /= data.size(); */
      // suppress again into the median-per/2 ~ median+per/2 range
      float lbound = median - pero2, ubound = median + pero2;
      for(int idat=0; idat<data.size(); idat++) {
	 while( data[idat] > ubound ) data[idat] -= per;
	 while( data[idat] <= lbound ) data[idat] += per;
      }

   }

   // Exclude measurements that are out of the 2 sigma range and compute mean and variance
   bool DataAvg( std::vector<float>& data, std::vector<float>& weight, std::vector<float>& azi, float& mean2, float& var2 ) {
      mean2 = -12345.;
      if( data.size() != weight.size() ) throw ErrorFS::SizeMismatch(FuncName, "data - weight");
      // compute mean 1
      float V1 = 0., mean1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 mean1 += data[i] * weight[i];
	 V1 += weight[i];
      }
      mean1 /= V1;
      // compute std1
      float V2 = 0., std1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 float ftmp = data[i]-mean1;
	 std1 += ftmp * ftmp * weight[i];
	 V2 += weight[i] * weight[i];
      }
      float frdm = V1*V1-V2;
      if( frdm <= 0. ) return false;
      std1 = sqrt( std1 * V1 / frdm );
      // erase bad data
      float lbound = mean1 - 2.0*std1, ubound = mean1 + 2.0*std1;
      int i=0;
      while( i<data.size() ) {
	 if( data[i]<lbound || data[i]>ubound ) {
	    data.erase(data.begin()+i);
	    weight.erase(weight.begin()+i);
	    azi.erase(azi.begin()+i);
	 } else {
	    i++;
	 }
      }
      // compute mean 2
      mean2 = 0.; V1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 //if( data[i]<lbound || data[i]>ubound ) continue;
         mean2 += data[i] * weight[i];
         V1 += weight[i];
      }
      mean2 /= V1;
      // compute var2
      V2 = 0., var2 = 0.;
      for(int i=0; i<data.size(); i++) {
	 //if( data[i]<lbound || data[i]>ubound ) continue;
	 float ftmp = data[i]-mean2;
	 var2 += ftmp * ftmp * weight[i];
	 V2 += weight[i] * weight[i];
      }
      frdm = V1*V1-V2;
      if( frdm <= 0. || data.size() < MIN_BAZI_SIZE ) {
	 mean2 = -12345.;
	 return false;
      }
      var2 *= (V1 / frdm); // variance
      //var2 *= V2 / ( frdm * V1 ); // variance of the mean

      // enlarge variances if the dataset is too small (and thus unreliable)
      if( data.size() < 1.5 * MIN_BAZI_SIZE ) var2 *= 5.;

      return true;
   }

   // compare AziData/StaData by azimuth
   inline static bool CompareAziA( AziData sta1, AziData sta2 ) { return (sta1.azi<sta2.azi); }
   inline static bool CompareAziS( StaData sta1, StaData sta2 ) { return (sta1.azi<sta2.azi); }

   // bin-average all measurements and store the results into an AziData vector
   // !!! Note that the input data will be rearranged (with invalid points erased and then sorted by azimuth)!!!
   void BinAverage( std::vector<StaData>& datain, float per, float binstep, float binhwidth, std::vector<AziData>& result ) {
      // erase invalid data points
      for(std::vector<StaData>::iterator iter=datain.begin(); iter!=datain.end(); ) {
	 if( (*iter).valid ) {
	    iter++;
	 } else {
	    iter = datain.erase(iter);
	 }
      }
      if( datain.size() == 0 ) throw ErrorFS::EmptyData(FuncName);
      // The misV should be almost sorted if the EQKSearcher::UpdateAziDis() is called before the Search 
      // Still, sort again to be safe 
      std::sort( datain.begin(), datain.end(), CompareAziS );

      // copy the data into a new vector with boundaries extended
      float binwidth = binhwidth * 2;
      std::vector<StaData> data;
      // prepend measurements with azi>360-binhwidth*2 to the beginning
      StaData sdbound; sdbound.azi = 360-binwidth;
      std::vector<StaData>::iterator sdIbound = std::upper_bound( datain.begin(), datain.end(), sdbound, CompareAziS );
      for(std::vector<StaData>::iterator sdI=sdIbound; sdI<datain.end(); sdI++) {
	 StaData sdtmp = *sdI;
	 sdtmp.azi -= 360.;
	 data.push_back( sdtmp );
      }
      // copy datain in the middle
      size_t presize = data.size();
      data.resize( presize + datain.size() );
      std::copy( datain.begin(), datain.end(), data.begin() + presize );
      // append measurements with azi<binhwidth*2 to the end
      sdbound.azi = binwidth;
      sdIbound = std::lower_bound( datain.begin(), datain.end(), sdbound, CompareAziS );
      for(std::vector<StaData>::iterator sdI=datain.begin(); sdI<sdIbound; sdI++) {
	 StaData sdtmp = *sdI;
	 sdtmp.azi += 360;
	 data.push_back( sdtmp );
      }
      // compute average in each bin
      int nbin = (int)ceil(360 / binstep);
      result.clear(); result.resize(nbin);
      std::vector<StaData>::iterator sdI_lbound, sdI_ubound;
      sdI_lbound = sdI_ubound = data.begin();
      float alpha = -0.5/(binhwidth*binhwidth);
      for(float iazi=0; iazi<nbin; iazi++) {
	 float azi = iazi * binstep;
	 // search for data window boundaries
	 StaData sd_lbound, sd_ubound;
	 sd_lbound.azi = azi-binwidth; sd_ubound.azi = azi+binwidth;
	 sdI_lbound = std::upper_bound( sdI_lbound, data.end(), sd_lbound, CompareAziS );
	 sdI_ubound = std::lower_bound( sdI_ubound, data.end(), sd_ubound, CompareAziS );
	 if( sdI_ubound - sdI_lbound < MIN_BAZI_SIZE ) {
	    result[iazi].valid = false;
	    continue;
	 }
	 // collect data and compute weights
	 std::vector<float> dataG, dataP, dataA;
	 std::vector<float >weitG, weitP, weitA;
	 std::vector<float >aziG, aziP, aziA;
	 for(std::vector<StaData>::iterator sdI=sdI_lbound; sdI<sdI_ubound; sdI++) {
	    float dataazi = (*sdI).azi, ftmp = azi-(*sdI).azi;
	    float weight = exp(alpha*ftmp*ftmp);
	    if( (*sdI).misG != -12345. ) {
		weitG.push_back( weight );
		dataG.push_back( (*sdI).misG );
		aziG.push_back(dataazi);
	    }
	    if( (*sdI).misP != -12345. ) {
		weitP.push_back( weight );
		dataP.push_back( (*sdI).misP );
		aziP.push_back(dataazi);
	    }
	    if( (*sdI).A != -12345. ) {
		weitA.push_back( weight );
		dataA.push_back( (*sdI).A );
		aziA.push_back(dataazi);
	    }
	 }
	 // correct 2-pi
	 Suppress2PI( dataP, per );
	 // compute average in each bin and save into the result vector
	 float var;
	 bool sucG = DataAvg( dataG, weitG, aziG, result[iazi].misG, var ); //result[iazi].valid = false;
	 result[iazi].varG = std::max((float)varGmin, var);
	 bool sucP = DataAvg( dataP, weitP, aziP, result[iazi].misP, var ); //result[iazi].valid = false;
	 result[iazi].varP = std::max((float)varPmin, var);
	 bool sucA = DataAvg( dataA, weitA, aziA, result[iazi].A, var ); //result[iazi].valid = false;
	 result[iazi].varA = std::max((float)varAmin*result[iazi].A, var);
	 // compute average azimuth from all valid data
	 float azisum = 0., wsum = 0.;
	 if(sucG) for(int i=0; i<aziG.size(); i++) { azisum += aziG[i]*weitG[i]; wsum += weitG[i]; }
	 if(sucP) for(int i=0; i<aziP.size(); i++) { azisum += aziP[i]*weitP[i]; wsum += weitP[i]; }
	 if(sucA) for(int i=0; i<aziA.size(); i++) { azisum += aziA[i]*weitA[i]; wsum += weitA[i]; }
	 result[iazi].azi = wsum>0. ? azisum/wsum : azi; //azi;
	 if( result[iazi].azi < 0. ) { 
	    result[iazi].azi += 360.;
	 } else if( result[iazi].azi >= 360. ) {
	    result[iazi].azi -= 360.;
	 }
	 result[iazi].valid = true;
      }

   }

};



/* -------------------- con/destructors and operators -------------------- */
EQKSearcher::EQKSearcher() 
   : pimplES( new EQimpl() ) {}

EQKSearcher::EQKSearcher( const char* fparamin ) 
   : pimplES( new EQimpl(fparamin) ) {
   pimplES->fparam.CheckAccess();
   LoadParams( pimplES->fparam.c_str() );
}

EQKSearcher::EQKSearcher( const EQKSearcher& es2 ) 
   : pimplES( new EQimpl(*(es2.pimplES)) ) {}

EQKSearcher::EQKSearcher( EQKSearcher&& es2 ) 
   : pimplES( std::move(es2.pimplES) ) {}

EQKSearcher& EQKSearcher::operator= ( const EQKSearcher& es2 ) {
   pimplES.reset( new EQimpl(*(es2.pimplES)) );
   return *this;
}

EQKSearcher& EQKSearcher::operator= ( EQKSearcher&& es2 ) {
   pimplES = std::move(es2.pimplES);
   return *this;
}

EQKSearcher::~EQKSearcher() {}


/* -------------------- getters/setters -------------------- */
const EpicInfo& EQKSearcher::EInfo() const { return pimplES->einfo; }
      EpicInfo& EQKSearcher::EInfo() { return pimplES->einfo; }


/* -------------------- param/data preparations -------------------- */
void EQKSearcher::LoadParams( const char* fname ) {
   std::ifstream fin(fname);
   if( ! fin ) throw ErrorFS::BadFile(FuncName, fname);
   int nparam = 0;
   for( std::string stmp; std::getline(fin, stmp); ) {
      int retval = Set( stmp.c_str() );
      if( retval == -3 ) continue; // invalid input for this parameter
      else if( retval == -2 ) continue; // empty input
      else if( retval == -1 ) continue;// std::cerr<<"Warning(EQKSearcher::Load): Unknown parameter name: "<<stmp<<std::endl;
      else if( retval == 0 ) continue;// std::cerr<<"Warning(EQKSearcher::Load): Empty parameter field for "<<stmp<<std::endl;
      else nparam++;
   }
   fin.close();

   std::cout<<"### "<<nparam<<" succed loads from param file "<<fname<<". ###"<<std::endl;

   // check model inputs
   if( access(pimplES->fReigname.c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, pimplES->fReigname);
   if( access(pimplES->fRphvname.c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, pimplES->fRphvname);
   if( access(pimplES->fLeigname.c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, pimplES->fLeigname);
   if( access(pimplES->fLphvname.c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, pimplES->fLphvname);
   
   // synchronize focal-output vectors with input-measurement vectors
   if( pimplES->outlist_RF.size() != pimplES->perRtmp.size() )
      throw ErrorFS::SizeMismatch(FuncName, "pimplES->outlist_RF - pimplES->perRtmp");
   int Rsize = pimplES->perRlist.size();
   if( pimplES->outlist_RF.size() > 0 && Rsize > 0 ) {
      std::vector< FileName > strVtmp( pimplES->outlist_RF );
      pimplES->outlist_RF.clear();
      pimplES->outlist_RF.resize( Rsize );
      for(int iper=0; iper<Rsize; iper++) {
	 int iol;
	 for(iol=0; iol<strVtmp.size(); iol++) {
	    if( pimplES->perRtmp[iol] == pimplES->perRlist[iper] ) break;
	 }
	 if( iol == strVtmp.size() ) continue;
	 pimplES->outlist_RF.at(iper) = strVtmp.at(iol);
      }
      pimplES->perRtmp.clear();
   }
   if( pimplES->outlist_LF.size() != pimplES->perLtmp.size() )
      throw ErrorFS::SizeMismatch(FuncName, "pimplES->outlist_LF - pimplES->perLtmp");
   int Lsize = pimplES->perLlist.size();
   if( pimplES->outlist_LF.size() > 0 && Lsize > 0 ) {
      std::vector< FileName > strVtmp( pimplES->outlist_LF );
      pimplES->outlist_LF.clear();
      pimplES->outlist_LF.resize( Lsize );
      for(int iper=0; iper<Lsize; iper++) {
	 int iol;
	 for(iol=0; iol<strVtmp.size(); iol++) {
	    if( pimplES->perLtmp[iol] == pimplES->perLlist[iper] ) break;
	 }
	 if( iol == strVtmp.size() ) continue;
	 pimplES->outlist_LF.at(iper) = strVtmp.at(iol);
      }
      pimplES->perLtmp.clear();
   }

   if( ! pimplES->Initialize() ) throw ErrorFS::BadParam(FuncName, "invalid Rs | clon | clat");
}

int EQKSearcher::Set( const char *input ) {
   std::istringstream buff(input);
   std::string stmp;
   if( ! (buff>>stmp) ) return -2;
   bool succeed;
   if( stmp == "clon" ) { 
      succeed = buff >> pimplES->clon; 
      if( succeed && pimplES->clon<0.) pimplES->clon += 360.; 
   }
   else if( stmp == "clat" ) succeed = buff >> pimplES->clat;
   else if( stmp == "Rs") succeed = buff >> pimplES->Rs;
   else if( stmp == "strike" ) succeed = buff >> FInfo().strike;
   else if( stmp == "dip" ) succeed = buff >> FInfo().dip;
   else if( stmp == "rake" ) succeed = buff >> FInfo().rake;
   else if( stmp == "depth" ) succeed = buff >> FInfo().depth;
   else if( stmp == "fRse" ) succeed = buff >> pimplES->fReigname;
   else if( stmp == "fRsp" ) succeed = buff >> pimplES->fRphvname;
   else if( stmp == "fLse" ) succeed = buff >> pimplES->fLeigname;
   else if( stmp == "fLsp" ) succeed = buff >> pimplES->fLphvname;
   else if( stmp == "dflag" ) {
      char flagin;
      succeed = buff >> flagin;
      if( succeed ) {
	 RFlag() = LFlag() = false;
	 switch( flagin ) {
	    case 'B': LFlag() = true;
	    case 'R': RFlag() = true;
		break;
	    case 'L': LFlag() = true;
		break;
	    default: return -3;
	 }
      }
   }
   else if( stmp == "fRm" ) {
      FileName stmp1, stmp2, stmp3;
      float per;
      succeed = buff >> stmp1 >> stmp2 >> stmp3 >> per;
      if( succeed ) {
	 for(int iper=0; iper<pimplES->perRlist.size(); iper++) 
	    if(pimplES->perRlist.at(iper) == per) return -3;
	 pimplES->fRlist.push_back( std::vector<FileName>{stmp1, stmp2, stmp3} );
	 pimplES->perRlist.push_back( per );
      }
   }
   else if( stmp == "fLm" ) {
      FileName stmp1, stmp2, stmp3;
      float per;
      succeed = buff >> stmp1 >> stmp2 >> stmp3 >> per;
      if( succeed ) {
	 for(int iper=0; iper<pimplES->perLlist.size(); iper++) 
	    if(pimplES->perLlist.at(iper) == per) return -3;
	 pimplES->fLlist.push_back( std::vector<FileName>{stmp1, stmp2, stmp3} );
	 pimplES->perLlist.push_back( per );
      }
   }
   else if( stmp == "fmisL" ) {
      FileName& outname = pimplES->outname_misL;
      succeed = buff >> outname;
      if( succeed && access(outname.c_str(), F_OK) == 0 ) {
	 FileName oldname = outname + "_old";
	 WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
	 rename(outname.c_str(), oldname.c_str());
      }
   }
   else if( stmp == "fpos" ) {
      FileName& outname = pimplES->outname_pos;
      succeed = buff >> outname;
      if( succeed && access(outname.c_str(), F_OK) == 0 ) {
	 FileName oldname = outname + "_old";
	 WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
	 rename(outname.c_str(), oldname.c_str());
      }
   }
   else if( stmp == "fmisF" ) {
      FileName& outname = pimplES->outname_misF;
      succeed = buff >> outname;
      if( succeed && access(outname.c_str(), F_OK) == 0 ) {
	 FileName oldname = outname + "_old";
	 WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
	 rename(outname.c_str(), oldname.c_str());
      }
   }
   else if( stmp == "ffitR" ) {
      FileName outname;
      float per;
      succeed = buff >> outname >> per;
      if( succeed ) {
	 if( access(outname.c_str(), F_OK) == 0 ) {
	    FileName oldname = outname + "_old";
	    WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
	    rename(outname.c_str(), oldname.c_str());
	 }
	 pimplES->outlist_RF.push_back(outname);
	 pimplES->perRtmp.push_back(per);
      }
   }
   else if( stmp == "ffitL" ) {
      FileName outname;
      float per;
      succeed = buff >> outname >> per;
      if( succeed ) {
	 if( access(outname.c_str(), F_OK) == 0 ) {
	    FileName oldname = outname + "_old";
	    WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
	    rename(outname.c_str(), oldname.c_str());
	 }
	 pimplES->outlist_LF.push_back(outname);
	 pimplES->perLtmp.push_back(per);
      }
   }
   else return -1;
   if( succeed ) return 1;
   return 0;
}

void EQKSearcher::LoadData() {
   //int nfail = 0;

   for(int ifile=0; ifile<pimplES->fRlist.size(); ifile++) {
      std::ifstream fin(pimplES->fRlist.at(ifile).at(0).c_str());
      if( ! fin ) throw ErrorFS::BadFile(FuncName, pimplES->fRlist.at(ifile).at(0));
      pimplES->per_sta_data_R.resize( pimplES->per_sta_data_R.size() + 1 );
      for(std::string line; std::getline(fin, line); ) {
	 pimplES->per_sta_data_R.at(ifile).push_back( StaData(line.c_str()) );
      }
      fin.close();
   }

   for(int ifile=0; ifile<pimplES->fLlist.size(); ifile++) {
      std::ifstream fin(pimplES->fLlist.at(ifile).at(0).c_str());
      if( ! fin ) throw ErrorFS::BadFile(FuncName, pimplES->fLlist.at(ifile).at(0));
      pimplES->per_sta_data_L.resize( pimplES->per_sta_data_L.size() + 1 );
      for(std::string line; std::getline(fin, line); ) {
	 pimplES->per_sta_data_L.at(ifile).push_back( StaData(line.c_str()) );
      }
      fin.close();
   }

//   if( nfail > 0 ) {
//      std::cerr<<"Warning(EQKSearcher::LoadData): failed to load "<<nfail<<" of the data files!"<<std::endl;
//      return false;
//   }
   std::cout<<"### "<<pimplES->fRlist.size() + pimplES->fLlist.size()<<" data file(s) loaded. ###"<<std::endl;
}


/* -------------------- data updaters -------------------- */
void EQKSearcher::UpdateAziDis() {
   // check params and data
   pimplES->CheckEInfo();
   //if( pimplES->einfo.lon == -12345. || pimplES->einfo.lat == -12345. ) 
   //   throw ErrorFS::BadParam(FuncName, "invalid pimplES->einfo.lon || pimplES->einfo.lat");
   if( pimplES->per_sta_data_R.size() == 0 && pimplES->per_sta_data_L.size() == 0 ) 
      throw ErrorFS::EmptyData(FuncName, "pimplES->per_sta_data_R && pimplES->per_sta_data_L");
   // compute azimuths and distances
   pimplES->UpdateAziDis( pimplES->einfo, pimplES->per_sta_data_R);
   pimplES->UpdateAziDis( pimplES->einfo, pimplES->per_sta_data_L);
   // sort by azimuth
   std::vector< std::vector<StaData> >& dataR = pimplES->per_sta_data_R;
   for(int iper=0; iper<dataR.size(); iper++) {
      std::sort( dataR[iper].begin(), dataR[iper].end(), pimplES->CompareAziS );
   }
   std::vector< std::vector<StaData> >& dataL = pimplES->per_sta_data_L;
   for(int iper=0; iper<dataL.size(); iper++) {
      std::sort( dataL[iper].begin(), dataL[iper].end(), pimplES->CompareAziS );
   }

   int iper = 3;
}


void EQKSearcher::UpdateFocalPred( bool flag ) {
   if( pimplES->perRlist.size()==0 && pimplES->perLlist.size()==0 )
      throw ErrorFS::EmptyData(FuncName, "pimplES->perRlist && pimplES->perLlist");

   // check Rayleigh source input
   if( pimplES->perRlist.size() != 0 &&
      (pimplES->fReigname.empty() || pimplES->fRphvname.empty()) )
      throw ErrorFS::BadParam(FuncName, "empty pimplES->fReigname || pimplES->fRphvname");
   
   // check Love source input
   if( pimplES->perLlist.size() != 0 &&
      (pimplES->fLeigname.empty() || pimplES->fLphvname.empty()) )
      throw ErrorFS::BadParam(FuncName, "empty pimplES->fLeigname || pimplES->fLphvname");

   /* ------ Corrections for Rayleigh wave ----- */
   if( pimplES->perRlist.size() > 0 ) {
      //std::vector<float> perRlst;
      //for(int i=0; i<pimplES->perRlist.size(); i++) perRlst.push_back(pimplES->perRlist.at(i));
      std::vector<float>& perRlst = pimplES->perRlist;

      // initialize/reset prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      pimplES->per_azi_pred_R.clear();
      //pimplES->per_azi_pred_R.resize( perRlst.size() );

      bool succeed;
//      if(flag) succeed = RadPatternR( pimplES->fReigname, pimplES->fRphvname, FInfo(), perRlst, pimplES->per_azi_pred_R );
//      else succeed = RadPatternR( pimplES->fReigname, pimplES->fRphvname, FInfoOld(), perRlst, pimplES->per_azi_pred_R );
      if(flag) pimplES->rpR.Predict( 'R', pimplES->fReigname, pimplES->fRphvname, FInfo(), perRlst, pimplES->per_azi_pred_R);
      else pimplES->rpR.Predict( 'R', pimplES->fReigname, pimplES->fRphvname, FInfoOld(), perRlst, pimplES->per_azi_pred_R);

      double Afactor = AFactorR();
      if( Afactor == -12345. ) Afactor = 1.;
      for(int iper=0; iper<pimplES->per_sta_data_R.size(); iper++) {
	 std::vector< AziData >& adlist = pimplES->per_azi_pred_R.at(iper);
	 for(int idata=0; idata<pimplES->per_sta_data_R.at(iper).size(); idata++) {
	    StaData& sdtmp = pimplES->per_sta_data_R[iper][idata];
	    if( ! sdtmp.valid ) continue;
	    int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp, pimplES->CompareAziA )
		         - adlist.begin();
	    //int ipredh = 1;
	    //while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh-1;
	    if( ipredl == -1 ) ipredl = adlist.size() - 1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float azifactor;// = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    try {
		pimplES->AziFactor(adlist[ipredl], sdtmp, adlist[ipredh], azifactor);
	    } catch( std::runtime_error& eazi ) {
		throw ErrorFS::BadAzi(FuncName, eazi.what());
	    }
	    sdtmp.misG = adlist[ipredl].misG + (adlist[ipredh].misG-adlist[ipredl].misG) * azifactor;
	    sdtmp.misP = adlist[ipredl].misP + (adlist[ipredh].misP-adlist[ipredl].misP) * azifactor;
	    sdtmp.Apred = adlist[ipredl].A + (adlist[ipredh].A-adlist[ipredl].A) * azifactor;
	    sdtmp.Apred *= Afactor;
	     //if(iper==3) std::cerr<<sdtmp.azi<<" "<<sdtmp.misG<<" "<<sdtmp.misP<<std::endl;
	 }
      }

   }

   /* ------ Corrections for Love wave ----- */
   if( pimplES->perLlist.size() > 0 ) {
      //std::vector<float> perLlst;
      //for(int i=0; i<pimplES->perLlist.size(); i++) perLlst.push_back(pimplES->perLlist.at(i).per);
      std::vector<float>& perLlst = pimplES->perLlist;

      // initialize prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      pimplES->per_azi_pred_L.clear();
      //pimplES->per_azi_pred_L.resize( perLlst.size() );

/* module RadPatternL is not done yet !!! */
//      bool succeed = RadPatternL( pimplES->fLeigname, pimplES->fLphvname, FInfo(), perLlst, pimplES->per_azi_pred_L );
      pimplES->rpL.Predict( 'L', pimplES->fLeigname, pimplES->fLphvname, FInfo(), perLlst, pimplES->per_azi_pred_L );

      double Afactor = AFactorL();
      if( Afactor == -12345. ) Afactor = 1.;
      for(int iper=0; iper<pimplES->per_sta_data_L.size(); iper++) {
	 std::vector< AziData >& adlist = pimplES->per_azi_pred_L.at(iper);
	 for(int idata=0; idata<pimplES->per_sta_data_L.at(iper).size(); idata++) {
	    StaData& sdtmp = pimplES->per_sta_data_L.at(iper).at(idata);
	    if( ! sdtmp.valid ) continue;
	    int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp, pimplES->CompareAziA )
		         - adlist.begin();
	    //int ipredh = 1;
	    //while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh-1;
	    if( ipredl == -1 ) ipredl = adlist.size() - 1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float azifactor;// = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    try {
		pimplES->AziFactor(adlist[ipredl], sdtmp, adlist[ipredh], azifactor);
	    } catch( std::runtime_error& eazi ) {
		throw ErrorFS::BadAzi(FuncName, eazi.what());
	    }
	    sdtmp.misG = adlist[ipredl].misG + (adlist[ipredh].misG-adlist[ipredl].misG) * azifactor;
	    sdtmp.misP = adlist[ipredl].misP + (adlist[ipredh].misP-adlist[ipredl].misP) * azifactor;
	    sdtmp.Apred = adlist[ipredl].A + (adlist[ipredh].A-adlist[ipredl].A) * azifactor;
	    sdtmp.Apred *= Afactor;
	 }
      }

   }

}


/* -------------------- data output -------------------- */
void EQKSearcher::OutputFocal() {
   // check data existence
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
   // check epicenter location
   pimplES->CheckEInfo();
   // check vel pred maps
   if( pimplES->fRlist.size()!=Rsize || pimplES->fLlist.size()!=Lsize )
      throw ErrorFS::SizeMismatch(FuncName, "fRlist - Rsize || fLlist - Lsize");
   for(int iper=0; iper<Rsize; iper++) {
      if( pimplES->outlist_RF.at(iper).empty() ) continue;
      pimplES->fRlist.at(iper).at(1).CheckAccess();
      pimplES->fRlist.at(iper).at(2).CheckAccess();
   }
   for(int iper=0; iper<Lsize; iper++) {
      if( pimplES->outlist_LF.at(iper).empty() ) continue;
      pimplES->fLlist.at(iper).at(1).CheckAccess();
      pimplES->fLlist.at(iper).at(2).CheckAccess();
   }

   /* Update azimuth & distance based on the current location
    * and sort station by azimuth. For both Love and Rayleigh waves*/
   UpdateAziDis();
   /* Update Focal corrections based on the current finfo.
    * For both R and L waves. */
   UpdateFocalPred();

   // output misfit ( measured + t0 - predicted ) and focal_corrections for Rayleigh
   EpicInfo& einfo = pimplES->einfo;
   float srclon = einfo.lon, srclat = einfo.lat, srct0 = einfo.t0;
   for(int iper=0; iper<Rsize; iper++) {
      // open output file 
      std::string outname = pimplES->outlist_RF.at(iper);
      if( outname.empty() ) continue;
      //outname += "_" + std::string(label);
      std::ofstream fout( outname, std::ofstream::app );
      // read in vel maps
      FileName& fname1 = pimplES->fRlist.at(iper).at(1);
      fname1.CheckAccess();
      Map map1(fname1.c_str(), Point<float>(srclon, srclat));
      FileName& fname2 = pimplES->fRlist.at(iper).at(2);
      fname2.CheckAccess();
      Map map2(fname2.c_str(), Point<float>(srclon, srclat));
      // period and wavelength
      float per = pimplES->perRlist.at(iper), pero2 = per*0.5, lamda = per * Lfactor;
      fout<<"# [ epic = "<<EInfo()<<"  focal = "<<FInfo()<<" ]"<<std::endl;
      for(int idat=0; idat<pimplES->per_sta_data_R.at(iper).size(); idat++) {
	 StaData& sdcur = pimplES->per_sta_data_R[iper][idat];
	 if( ! sdcur.valid ) continue;
	 float percG, percP;
	 float velG = map1.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percG ).Data();
	 float velP = map2.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percP ).Data();
	 float misG = sdcur.grT + srct0 - sdcur.dist/velG;
	 float misP = sdcur.phT + srct0 - sdcur.dist/velP;
	 if( percG < Min_Perc || percP < Min_Perc ) continue;
	 // correct 2pi
	 misP -= sdcur.misP;
	 while( misP > pero2 ) misP -= per;
	 while( misP <= -pero2 ) misP += per;
	 misP += sdcur.misP;
	 fout<<sdcur.azi<<"   "<<misG<<" "<<sdcur.misG<<"   "<<misP<<" "
	     <<sdcur.misP<<"   "<<sdcur.A<<" "<<sdcur.Apred<<std::endl;
      }
      fout<<std::endl<<std::endl; fout.close();
   }

   // output misfit ( measured + t0 - predicted ) and focal_corrections for Love
   for(int iper=0; iper<Lsize; iper++) {
      // open output file 
      std::string outname = pimplES->outlist_LF.at(iper);
      if( outname.empty() ) continue;
      //outname += "_" + std::string(label);
      std::ofstream fout( outname, std::ofstream::app );
      // read in vel maps
      FileName& fname1 = pimplES->fLlist.at(iper).at(1);
      fname1.CheckAccess();
      Map map1(fname1.c_str(), Point<float>(srclon, srclat));
      FileName& fname2 = pimplES->fLlist.at(iper).at(2);
      fname2.CheckAccess();
      Map map2(fname2.c_str(), Point<float>(srclon, srclat));
      // period and wavelength
      float per = pimplES->perLlist.at(iper), pero2 = per*0.5, lamda = per * Lfactor;
      fout<<"# [ epic = "<<EInfo()<<"  focal = "<<FInfo()<<" ]"<<std::endl;
      for(int idat=0; idat<pimplES->per_sta_data_L.at(iper).size(); idat++) {
	 StaData& sdcur = pimplES->per_sta_data_L[iper][idat];
	 if( ! sdcur.valid ) continue;
	 float percG, percP;
	 float velG = map1.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percG ).Data();
	 float velP = map2.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percP ).Data();
	 float misG = sdcur.grT + srct0 - sdcur.dist/velG;
	 float misP = sdcur.phT + srct0 - sdcur.dist/velP;
	 if( percG < Min_Perc || percP < Min_Perc ) continue;
	 // correct 2pi
	 misP -= sdcur.misP;
	 while( misP > pero2 ) misP -= per;
	 while( misP <= -pero2 ) misP += per;
	 misP += sdcur.misP;
	 fout<<sdcur.azi<<"   "<<misG<<" "<<sdcur.misG<<"   "<<misP<<" "
	     <<sdcur.misP<<"   "<<sdcur.A<<" "<<sdcur.Apred<<std::endl;
      }
      fout<<std::endl<<std::endl; fout.close();
   }

}


/* -------------------- compute misfit square at a given location -------------------- */
void EQKSearcher::EnergyL( const EpicInfo& einfo, float& E ) {
   int N;
   float chiS, wSum;
   EQKSearcher::chiSquareL(einfo, chiS, wSum, N);
   if( N <= 0 ) 
      throw ErrorFS::InsufData(FuncName, "N="+std::to_string(N));
   //E = chiS / wSum;
   E = chiS / (N-4.); // reduced chi-square
}
void EQKSearcher::chiSquareL( const EpicInfo& einfo, float& chiS, float& wSum, int& N ) {
   // check input params
   pimplES->CheckEInfo(einfo);
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");

   float srclon = einfo.lon, srclat = einfo.lat, srct0 = einfo.t0;

   chiS = 0.; wSum = 0.; N = 0;
   // weightings
   // compute misfit (measured + t0 - predicted - focal_correction ) for Rayleigh maps
   if( Rsize>0 && RFlag() ) {
//einfo = EpicInfo(245.481, 41.0386, -1.93645);
      std::vector< std::vector<StaData> > dataR = pimplES->per_sta_data_R;
      pimplES->UpdateAziDis( einfo, dataR );
      pimplES->UpdateFocalCorr( einfo, dataR, pimplES->per_azi_pred_R );
      for(int iper=0; iper<Rsize; iper++) {
	 FileName& fname1 = pimplES->fRlist.at(iper).at(1);
	 fname1.CheckAccess();
	 Map map1(fname1.c_str(), Point<float>(srclon, srclat));

	 FileName& fname2 = pimplES->fRlist.at(iper).at(2);
	 fname2.CheckAccess();
	 Map map2(fname2.c_str(), Point<float>(srclon, srclat));

	 float per = pimplES->perRlist.at(iper), pero2 = 0.5*per, lamda = per * Lfactor;
	 std::vector<StaData> misV;//( dataR[iper].size() );
	 for( int idat=0; idat<dataR[iper].size(); idat++ ) {
	    StaData& sdcur = dataR[iper][idat];
	    if( ! sdcur.valid ) continue;
	    if( sdcur.dist < DISMIN || sdcur.dist > DISMAX ) continue;
	    float percG, percP;
	    float velG = map1.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percG ).Data();
	    float velP = map2.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percP ).Data();
	    float misG = sdcur.grT + srct0 - sdcur.misG - sdcur.dist/velG;
	    float misP = sdcur.phT + srct0 - sdcur.misP - sdcur.dist/velP;
	    while( misP > pero2 ) misP -= per;
	    while( misP < -pero2 ) misP += per;
	    StaData sdtmp;
	    sdtmp.azi = sdcur.azi;
	    //sdtmp.A = sdcur.A;
	    sdtmp.valid = true;
	    if( percG > Min_Perc ) sdtmp.misG = misG;//misGV.push_back( misG*misG );
	    if( percP > Min_Perc ) sdtmp.misP = misP;//misPV.push_back( misP*misP);
	    misV.push_back( sdtmp );
	 }
	 // compute azimuthal average
	 std::vector<AziData> dataAzi;
	 //std::sort( misV.begin(), misV.end(), pimplES->CompareAziS );
	 pimplES->BinAverage( misV, per, BINSTEP, BINHWIDTH, dataAzi );
	 // compute average misfit square (excluding bad data)
	 std::vector<float> misGV, misPV;
	 std::vector<float> weitG, weitP;
	 for(int imis=0; imis<dataAzi.size(); imis++) {
	    if( ! dataAzi[imis].valid ) continue;
	    float ftmp = dataAzi[imis].misG;
	    if( ftmp != -12345. ) {
		misGV.push_back( ftmp * ftmp );
		weitG.push_back( weightR_Loc / dataAzi[imis].varG );
	    }
	    ftmp = dataAzi[imis].misP;
	    if( ftmp != -12345. ) {
		misPV.push_back( ftmp * ftmp );
		weitP.push_back( weightR_Loc / dataAzi[imis].varP );
	    }
	 }
	 // check if there're enough misfits
	 float minSize = MIN_AZI_PERC * float(dataAzi.size());
	 if( misGV.size() < minSize || misPV.size() < minSize ) {
	    WarningFS::Other(FuncName, "no enough data point for iper=" + 
				       std::to_string(iper) + " and type=R" );
	    continue;
	 }
	 for(int i=0; i<NEX; i++)
	    if( ! pimplES->ExcludeLarge( misGV, weitG ) ) throw ErrorFS::SizeMismatch(FuncName, "misGV - weitG");
	 for(int i=0; i<NEX; i++)
	    if( ! pimplES->ExcludeLarge( misPV, weitP ) ) throw ErrorFS::SizeMismatch(FuncName, "misPV - weitP");
	 //E += EG*0.2 + EP*0.8;// / dataR[iper].size() );
	 for(int idat=0; idat<misGV.size(); idat++) { chiS += misGV[idat]*weitG[idat]; wSum += weitG[idat]; }// if(weitG[idat]>1200) std::cerr<<"R  misG = "<<misGV[idat]<<"   weightG = "<<weitG[idat]<<std::endl; }
	 for(int idat=0; idat<misPV.size(); idat++) { chiS += misPV[idat]*weitP[idat]; wSum += weitP[idat]; }// if(weitP[idat]>1200) std::cerr<<"R  misP = "<<misPV[idat]<<"   weightP = "<<weitP[idat]<<std::endl; }
	 N += (misGV.size() + misPV.size());
      }
   }

   // compute misfit (measured + t0 - predicted - focal_correction) for Love maps
   if( Lsize>0 && LFlag() ) {
      std::vector< std::vector<StaData> > dataL = pimplES->per_sta_data_L;
      pimplES->UpdateAziDis( einfo, dataL );
      pimplES->UpdateFocalCorr( einfo, dataL, pimplES->per_azi_pred_L );
      for(int iper=0; iper<Lsize; iper++) {
	 FileName& fname1 = pimplES->fLlist.at(iper).at(1);
	 fname1.CheckAccess();
	 Map map1(fname1.c_str(), Point<float>(srclon, srclat));
	 FileName& fname2 = pimplES->fLlist.at(iper).at(2);
	 fname2.CheckAccess();
	 Map map2(fname2.c_str(), Point<float>(srclon, srclat));

	 float per = pimplES->perLlist.at(iper), pero2 = 0.5*per, lamda = per * Lfactor;
	 std::vector<StaData> misV;//( dataL[iper].size() );
	 for( int idat=0; idat<dataL[iper].size(); idat++ ) {
	    StaData& sdcur = dataL[iper][idat];
	    if( ! sdcur.valid ) continue;
	    if( sdcur.dist < DISMIN || sdcur.dist > DISMAX ) continue;
	    float percG, percP;
	    float velG = map1.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percG ).Data();
	    float velP = map2.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percP ).Data();
	    float misG = sdcur.grT + srct0 - sdcur.misG - sdcur.dist/velG;
	    float misP = sdcur.phT + srct0 - sdcur.misP - sdcur.dist/velP;
	    while( misP > pero2 ) misP -= per;
	    while( misP < -pero2 ) misP += per;
	    StaData sdtmp;
	    sdtmp.azi = sdcur.azi;
	    sdtmp.valid = true;
	    if( percG > Min_Perc ) sdtmp.misG = misG;//misGV.push_back( misG*misG );
	    if( percP > Min_Perc ) sdtmp.misP = misP;//misPV.push_back( misP*misP);
	    misV.push_back( sdtmp );
	 }
	 // compute azimuthal average
	 std::vector<AziData> dataAzi;
	 //std::sort( misV.begin(), misV.end(), pimplES->CompareAziS );
	 pimplES->BinAverage( misV, per, BINSTEP, BINHWIDTH, dataAzi );
	 // compute average misfit square (excluding bad data)
	 std::vector<float> misGV, misPV;
	 std::vector<float> weitG, weitP;
	 for(int imis=0; imis<dataAzi.size(); imis++) {
	    if( ! dataAzi[imis].valid ) continue;
	    float ftmp = dataAzi[imis].misG;
	    if( ftmp != -12345. ) {
		misGV.push_back( ftmp * ftmp );
		weitG.push_back( weightL_Loc / dataAzi[imis].varG );
	    }
	    ftmp = dataAzi[imis].misP;
	    if( ftmp != -12345. ) {
		misPV.push_back( ftmp * ftmp );
		weitP.push_back( weightL_Loc / dataAzi[imis].varP );
	    }
	 }
	 // check if there're enough misfits
	 float minSize = MIN_AZI_PERC * float(dataAzi.size());
	 if( misGV.size() < minSize || misPV.size() < minSize ) {
	    WarningFS::Other(FuncName, "no enough data point for iper=" + 
				       std::to_string(iper) + " and type=L" );
	    continue;
	 }
	 for(int i=0; i<NEX; i++) 
	    if( ! pimplES->ExcludeLarge( misGV, weitG ) ) throw ErrorFS::SizeMismatch(FuncName, "misGV - weitG");
	 for(int i=0; i<NEX; i++)
	    if( ! pimplES->ExcludeLarge( misPV, weitP ) ) throw ErrorFS::SizeMismatch(FuncName, "misPV - weitP");
	 //E += EG*0.2 + EP*0.8;// / dataR[iper].size() );
	 for(int idat=0; idat<misGV.size(); idat++) { chiS += misGV[idat]*weitG[idat]; wSum += weitG[idat]; }// if(weitG[idat]>1200) std::cerr<<"L  misG = "<<misGV[idat]<<"   weightG = "<<weitG[idat]<<std::endl;}
	 for(int idat=0; idat<misPV.size(); idat++) { chiS += misPV[idat]*weitP[idat]; wSum += weitP[idat]; }// if(weitP[idat]>1200) std::cerr<<"L  misP = "<<misPV[idat]<<"   weightP = "<<weitP[idat]<<std::endl;}
	 N += (misGV.size() + misPV.size());
      }
   }

   // normalize total energy
   //E = Esum / Wsum;

}


/* -------------------- average the data by azimuth and store the results for FocalSearcher -------------------- */
void EQKSearcher::FillFocalSearcher() { 
   std::vector<PerDazi> perRlst, perLlst;
   std::vector< std::vector<AziData> > resultR, resultL;
   PrepareAziData( pimplES->einfo, resultR, perRlst, resultL, perLlst );

   FSreset( pimplES->outname_misF,
	    pimplES->fReigname, pimplES->fRphvname,
	    pimplES->fLeigname, pimplES->fLphvname,
	    std::move(perRlst), std::move(perLlst),
	    std::move(resultR), std::move(resultL) );
}

void EQKSearcher::PrepareAziData( const EpicInfo& einfo, 
				    std::vector< std::vector<AziData> >& resultR, std::vector<PerDazi>& perRlst,
				    std::vector< std::vector<AziData> >& resultL, std::vector<PerDazi>& perLlst ) {
   // check einfo
   pimplES->CheckEInfo(einfo);

   // check input measurements
   if( (!RFlag()) && (!LFlag()) ) throw ErrorFS::EmptyData(FuncName, "RFlag() && LFlag()");
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
   if( pimplES->perRlist.size() != Rsize || pimplES->perLlist.size() != Lsize ) 
      throw ErrorFS::SizeMismatch(FuncName, "perRlist - Rsize || perLlist - Lsize");

   // initializa parameters
   float srclon = einfo.lon, srclat = einfo.lat, srct0 = einfo.t0;

   // compute azi-misfit for Rayleigh wave
   if( Rsize>0 && RFlag() ) {
      // check source files
      if( pimplES->fReigname.empty() || pimplES->fRphvname.empty() )
	 throw ErrorFS::BadParam(FuncName, "empty pimplES->fReigname || pimplES->fRphvname");

      // compute misfit (measured + t0 - predicted) for Rayleigh maps
      std::vector< std::vector<StaData> > dataR = pimplES->per_sta_data_R;
      pimplES->UpdateAziDis( einfo, dataR );
      resultR.clear(); resultR.resize(Rsize);
      perRlst.clear(); perRlst.resize(Rsize);
      for(int iper=0; iper<Rsize; iper++) {
	 FileName& fname1 = pimplES->fRlist.at(iper).at(1);
	 fname1.CheckAccess();
	 Map map1(fname1.c_str(), Point<float>(srclon, srclat));

	 FileName& fname2 = pimplES->fRlist.at(iper).at(2);
	 fname2.CheckAccess();
	 Map map2(fname2.c_str(), Point<float>(srclon, srclat));

	 float per = pimplES->perRlist.at(iper), pero2 = 0.5*per, lamda = per * Lfactor;
	 // compute misfits and store in a vector for bin-average later
	 std::vector<StaData>& data_cur = dataR[iper];
	 for( int idat=0; idat<data_cur.size(); idat++ ) {
	    StaData& sdcur = data_cur[idat];
	    if( ! sdcur.valid ) continue;
	    float percG, percP;
	    float velG = map1.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percG ).Data();
	    float velP = map2.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percP ).Data();
	    sdcur.misG = sdcur.grT + srct0 - sdcur.dist/velG;
	    float misP = sdcur.phT + srct0 - sdcur.misP - sdcur.dist/velP;
	    if( percG < Min_Perc ) sdcur.misG = -12345.;
	    if( percP < Min_Perc ) {
		sdcur.misP = -12345.;
	    } else {
		while( misP > pero2 ) misP -= per;
		while( misP < -pero2 ) misP += per;
		sdcur.misP = misP + sdcur.misP;
	    }
	    //Ecur += misG*misG*0.5 + misP*misP*0.5;
	 }
	 //std::sort( data_cur.begin(), data_cur.end(), pimplES->CompareAziS );
	 // bin average 
	 pimplES->BinAverage( data_cur, per, BINSTEP, BINHWIDTH, resultR.at(iper) );
	 perRlst.at(iper) = PerDazi( per, BINSTEP );
	 //E += Ecur;// / data_cur.size() );
      }
   }

   // compute azi-misfit for Love wave
   if( Lsize>0 && LFlag() ) {
      // check source files
      if( pimplES->fLeigname.empty() || pimplES->fLphvname.empty() )
	 throw ErrorFS::BadParam(FuncName, "empty pimplES->fLeigname || pimplES->fLphvname");

      // compute misfit (measured + t0 - predicted) for Rayleigh maps
      std::vector< std::vector<StaData> > dataL = pimplES->per_sta_data_L;
      pimplES->UpdateAziDis( einfo, dataL );
      resultL.clear(); resultL.resize(Lsize);
      perLlst.clear(); perLlst.resize(Lsize);
      for(int iper=0; iper<Lsize; iper++) {
	 FileName& fname1 = pimplES->fLlist.at(iper).at(1);
	 fname1.CheckAccess();
	 Map map1(fname1.c_str(), Point<float>(srclon, srclat));

	 FileName& fname2 = pimplES->fLlist.at(iper).at(2);
	 fname2.CheckAccess();
	 Map map2(fname2.c_str(), Point<float>(srclon, srclat));

	 float per = pimplES->perLlist.at(iper), pero2 = 0.5*per, lamda = per * Lfactor;
	 // compute misfits and store in a vector for bin-average later
	 std::vector<StaData>& data_cur = dataL[iper];
	 for( int idat=0; idat<data_cur.size(); idat++ ) {
	    StaData& sdcur = data_cur[idat];
	    if( ! sdcur.valid ) continue;
	    float percG, percP;
	    float velG = map1.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percG ).Data();
	    float velP = map2.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percP ).Data();
	    sdcur.misG = sdcur.grT + srct0 - sdcur.dist/velG;
	    float misP = sdcur.phT + srct0 - sdcur.misP - sdcur.dist/velP;
	    if( percG < Min_Perc ) sdcur.misG = -12345.;
	    if( percP < Min_Perc ) {
		sdcur.misP = -12345.;
	    } else {
		while( misP > pero2 ) misP -= per;
		while( misP < -pero2 ) misP += per;
		sdcur.misP = misP + sdcur.misP;
	    }
	    //Ecur += misG*misG*0.5 + misP*misP*0.5;
	 }
	 // bin average 
	 pimplES->BinAverage( data_cur, per, BINSTEP, BINHWIDTH, resultL.at(iper) );
	 perLlst.at(iper) = PerDazi( per, BINSTEP );
	 //E += Ecur;// / data_cur.size() );
      }
   }

}


/* -------------------- search for optimal epi location with a simulated annealing algorithm -------------------- */
void EQKSearcher::SearchLocation( int nsearch, float alpha, float Tfactor ) {
   // check epic parameters
   pimplES->CheckSearchArea();
   pimplES->CheckEInfo();
   // check input measurements
   if( (!RFlag()) && (!LFlag()) ) throw ErrorFS::EmptyData(FuncName, "RFlag() && LFlag()");
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
   if( pimplES->perRlist.size() != Rsize || pimplES->perLlist.size() != Lsize )
      throw ErrorFS::SizeMismatch(FuncName, "perRlist - Rsize || perLlist - Lsize");
   // check vel map accessibilities
   for(int iper=0; iper<Rsize; iper++) {
      pimplES->fRlist.at(iper).at(1).CheckAccess();
      pimplES->fRlist.at(iper).at(2).CheckAccess();
   }
   for(int iper=0; iper<Lsize; iper++) {
      pimplES->fLlist.at(iper).at(1).CheckAccess();
      pimplES->fLlist.at(iper).at(2).CheckAccess();
   }

   /* update focal predictions based on the current FInfo() 
      for both the 'pred' and the 'data' vectors */
   UpdateFocalPred();
   // initialize parameters
   EpicInfo& einfo = pimplES->einfo;

   // simulated annealing
   float E;
   EnergyL(pimplES->einfo, E);
   float T = E * Tfactor;
   std::cout<<"### SearchLocation: Initial Misfit**2 for ("<<pimplES->einfo<<")&&("<<FInfo()<<") = "<<E<<" T="<<T<<" ###"<<std::endl;
   EpicInfo einfobest = pimplES->einfo;
   float Ebest = E;
   int nrej = 0;
   int isearch = 0;
   std::ofstream fout;
   bool output_mis = ! pimplES->outname_misL.empty();
   if( output_mis ) fout.open(  pimplES->outname_misL.c_str(), std::ofstream::app );
   
   fout<<"# [ epic = "<<EInfo()<<" ]"<<std::endl;
   fout<< "-1\t" << E << "\t" << T << std::endl;
   char type = RFlag()&&LFlag() ? 'B' : (RFlag()?'R':'L');
   #pragma omp parallel for schedule (dynamic, 1)
   for( int i=0; i<nsearch; i++ ) {
      EpicInfo einfonew = pimplES->Neighbour( pimplES->einfo );
      float Enew = -12345.;
      EnergyL(einfonew, Enew);
     #pragma omp critical
     { // critical start
      if( pimplES->Accept(E, Enew, T) ) {
	 pimplES->einfo = einfonew;
	 E = Enew;
	 if( output_mis ) {
	    fout<< std::setw(4)<<isearch << " " << std::setw(8)<<Enew << " "
		<< std::setw(8)<<T << "\t" << pimplES->einfo <<std::endl;
	    fout.flush();
	 }
	 std::cout<<"   Misfit**2 for ("<<einfonew<<") = "<<Enew<<" (accepted)  T="
		  <<T<<"  isearch="<<isearch<<"/"<<nsearch<<"  type="<<type<<std::endl;
	 nrej = 0;
      }
      else { nrej++; std::cout<<"( nrejects = "<<nrej<<" )"<<"  ithread="<<omp_get_thread_num()<<"                  "<<std::endl<<"\x1b[A"; }
      T *= alpha;
      if( Enew < Ebest ) {
	 einfobest = einfonew;
	 Ebest = Enew;
      }
      isearch++;
     } // critical end
   }
   fout<< isearch << "\t" << Ebest << "\t" << T << "\t" << einfobest << std::endl;
   fout<<std::endl<<std::endl; fout.close();
   std::cout<<"                                   "<<std::endl;
   pimplES->einfo = einfobest;

}

/* -------------------- compute chi-square misfit at the current einfo and finfo -------------------- */
void EQKSearcher::EnergyMC( const FocalInfo<ftype>& finfo, const EpicInfo& einfo, float& chiS ) {
   //long t0 = std::chrono::system_clock::now().time_since_epoch().count();
   std::vector< std::vector<AziData> > AziDataR, AziDataL;
   std::vector<PerDazi> perRlist, perLlist;
   PrepareAziData(einfo, AziDataR, perRlist, AziDataL, perLlist);
   int N;
   float wSum;
   double AfR, AfL;
   chiSquareF(AziDataR, perRlist, AziDataL, perLlist, finfo, chiS, wSum, N, AfR, AfL);
   //std::cerr<<"   chiS = "<<chiS<<"  wSum = "<<wSum<<"  N = "<<N<<"   NC = "<<pimplES->NC<<std::endl;
   if( N <= 0 ) 
      throw ErrorFS::InsufData(FuncName, "N="+std::to_string(N));
   if( pimplES->NC == -12345 ) pimplES->NC = N;
   chiS *= (float)(pimplES->NC)/N;
}
/* -------------------- search for the posterior distribution around the current einfo and finfo -------------------- */
void EQKSearcher::SearchPosterior( int nsearch ) {
  /* --- pre-condition checks --- */
   // check output file
   pimplES->outname_pos.CheckEmpty();
   const char* outname = pimplES->outname_pos.c_str();
   // check epic parameters
   pimplES->CheckSearchArea();
   pimplES->CheckEInfo();
   // check input measurements
   if( (!RFlag()) && (!LFlag()) ) throw ErrorFS::EmptyData(FuncName, "RFlag() && LFlag()");
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
   if( pimplES->perRlist.size() != Rsize || pimplES->perLlist.size() != Lsize )
      throw ErrorFS::SizeMismatch(FuncName, "perRlist - Rsize || perLlist - Lsize");
   // check vel map accessibilities
   for(int iper=0; iper<Rsize; iper++) {
      pimplES->fRlist.at(iper).at(1).CheckAccess();
      pimplES->fRlist.at(iper).at(2).CheckAccess();
   }
   for(int iper=0; iper<Lsize; iper++) {
      pimplES->fLlist.at(iper).at(1).CheckAccess();
      pimplES->fLlist.at(iper).at(2).CheckAccess();
   }
  /* ---------------------------- */

   // initialize parameters
   EpicInfo& einfo = pimplES->einfo;
   // pass model/misfit filenames into Focalsearcher
   FSreset( pimplES->outname_misF,
	    pimplES->fReigname, pimplES->fRphvname,
	    pimplES->fLeigname, pimplES->fLphvname );

   // Bayesian Monte Carlo Search in the surrounding space
   // define 'surrounding'
   float Rlon = 0.2, Rlat = 0.2, Rtim = 3.;
   float Rstk = 20., Rdip = 10., Rrak = 20., Rdep = 5.;
   //float Rlon = 0.5, Rlat = 0.5, Rtim = 10.;
   //float Rstk = 180., Rdip = 45., Rrak = 180., Rdep = 30.;
   // initialize
   float E;
   FocalInfo<ftype> finfo = FInfo();
   EQKSearcher::EnergyMC(finfo, einfo, E);
   std::cout<<"### SearchPosterior: chiS for the center ("<<einfo<<")&&("<<finfo<<") = "<<E<<" ###"<<std::endl;
   int isearch = 0;
   std::ofstream fout(outname);
   if( ! fout ) throw ErrorFS::BadFile(FuncName, outname);

   // start searching
   int nrej = 0;
   char type = RFlag()&&LFlag() ? 'B' : (RFlag()?'R':'L');
   #pragma omp parallel for schedule (dynamic, 1)
   for( int i=0; i<nsearch; i++ ) {
      //long t0 = std::chrono::system_clock::now().time_since_epoch().count();
      FocalInfo<ftype> finfonew;
      EpicInfo einfonew;
      // perturb the model from (finfo, einfo) to (finfonew, einfonew) int the range defined by (FInfo(), EInfo() and Rxxxs)
      pimplES->PerturbModel(finfo, einfo, finfonew, einfonew, FInfo(), EInfo(), Rlon, Rlat, Rtim, Rstk, Rdip, Rrak, Rdep);
      float Enew;
      EnergyMC(finfonew, einfonew, Enew);
     #pragma omp critical
     { // critical begin
      if( pimplES->Accept(E, Enew, 2.) ) {
	 finfo = finfonew;
	 einfo = einfonew;
	 E = Enew;
	 fout<< std::setw(4)<<isearch << "   " << std::setw(8)<<Enew << "   "
	     << finfo << "   " << einfo <<std::endl;
	 //fout.flush();
	 std::cout<<"   chiS for ("<<finfo<<") && ("<<einfo<<") = "<<E<<" (accepted)  "
		  <<"  isearch="<<isearch<<"/"<<nsearch<<"  type="<<type<<std::endl;
	 nrej = 0;
      } else { 
	 nrej++; 
	 std::cout<<"( nrejects = "<<nrej<<" )"<<"  ithread="
		  <<omp_get_thread_num()<<"                  "<<std::endl<<"\x1b[A"; 
      }
      isearch++;
     } // critical end
   }
   fout.close();

}




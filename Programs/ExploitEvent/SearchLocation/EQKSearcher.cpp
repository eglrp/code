#include "EQKSearcher.h"
#include "RadPattern.h"
#include "DisAzi.h"
#include "Map.h"
#include <cstdlib>
#include <unistd.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <chrono>
#include <random>
#include <algorithm>
#include <omp.h>

#define BINHWIDTH 15

/* -------------------- implimentation details -------------------- */
struct EQKSearcher::EQimpl {
   std::string fparam;					// parameter file
   std::string outname_mis;				// output misfit filename
   std::vector< std::string > outlist_RF, outlist_LF;	// output focal_fit filename
   std::vector<float> perRtmp, perLtmp;			// tmp period list
//   std::string fReigname, fRphvname;			// input eigen-function file
//   std::string fLeigname, fLphvname;			// input phase-velocity file
   std::vector<float> perRlist, perLlist;		// period list for rayleigh and love waves
   std::vector< std::vector<std::string> > fRlist, fLlist;
   /* It's perfectly OK to use vector of vector here as the data for each
    * period are accessed independently. Consider changing to Array2D if 
    * the access pattern is changed somehow */
   std::vector< std::vector<StaData> > per_sta_data_R, per_sta_data_L;
   std::vector< std::vector<AziData> > per_azi_pred_R, per_azi_pred_L;
   float clon, clat, Rs;
   float Rt, Rlon, Rlat;
   EpicInfo einfo;
   RadPattern rp;


   EQimpl( const char* fparamin = NULL, float clonin = -12345.,
	   float clatin = -12345., float Rsin = -12345. )
      : fparam(fparamin), clon(clonin), clat(clatin), Rs(Rsin), Rt(20.) {
      Initialize();
   }

   // set search ranges
   bool Initialize() {
      if( Rs>0 && clon!=-12345 && clat!=-12345 ) {
	 double dist;
	 //calc_dist(clat, clon, clat, clon+1, &dist);
	 dist = Path<double>(clon, clat, clon+1., clat).Dist();
	 Rlon = Rs / dist;
	 //calc_dist(clat, clon, clat+1, clon, &dist);
	 dist = Path<double>(clon, clat, clon, clat+1.).Dist();
	 Rlat = Rs / dist;
	 einfo = EpicInfo(clon, clat, 0.);
	 return true;
      }
      else {
	 Rlon = Rlat = -12345.;
	 return false;
      }
   }

   inline void AziFactor( AziData& dat_l, AziData& dat_m, AziData& dat_h, float& azifactor ) {
      float azi_l = dat_l.azi, azi_m = dat_m.azi, azi_h = dat_h.azi;
      if( azi_m == azi_l ) { azifactor = 0.; return; }
      if( azi_m == azi_h ) { azifactor = 1.; return; }
      if( azi_l > azi_h ) {
	 azi_h += 360.;
	 if( azi_m < azi_l ) azi_m += 360.;
      }
      if( azi_l>azi_m || azi_m>azi_h )
	 throw std::runtime_error( std::to_string(azi_l)+" - "+std::to_string(azi_m)+" - "+std::to_string(azi_h) );
      azifactor = (dat_m.azi - dat_l.azi) / (dat_h.azi - dat_l.azi);
   }

   // accept criterion for simulated annealing
   bool Accept(float E, float Enew, double T) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
      std::default_random_engine generator (timeseed);
      std::uniform_real_distribution<float> distribution(0., 1.);
      auto rand = std::bind ( distribution, generator );
      if(Enew<E) return true;
      if(rand()<exp((E-Enew)/T)) return true;
      return false;
   }

   // perturb model parameters
   EpicInfo Neighbour( const EpicInfo& einfo ) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
      // random number generator 
      //std::default_random_engine generator2 (timeseed);
      std::mt19937 generator2 (timeseed);
      std::normal_distribution<double> distributionN(0.0,1.0);
      auto randnorm = std::bind ( distributionN, generator2 );
   
      EpicInfo einfonew = einfo;

      float ht = Rt * 0.05;
      float hlon = Rlon * 0.05, hlat = Rlat * 0.05;

      while( float dltlon = randnorm()*hlon ) {
	 float lonnew = einfonew.lon + dltlon;
	 if( lonnew < clon + Rlon && lonnew > clon - Rlon ) {
	    einfonew.lon = lonnew;
	    break;
	 }
      }
      while( float dltlat = randnorm()*hlat ) {
	 float latnew = einfonew.lat + dltlat;
	 if( latnew < clat + Rlat && latnew > clat - Rlat ) {
	    einfonew.lat = latnew;
	    break;
	 }
      }
      while( float dltt = randnorm()*ht ) {
	 float tnew = einfonew.t0 + dltt;
	 if( tnew < Rt && tnew > -Rt ) {
	    einfonew.t0 = tnew;
	    break;
	 }
      }

      return einfonew;
   }

   // compute azimuth and distance for each station based on the input epicenter location
   void UpdateAziDis( EpicInfo& einfoin, std::vector< std::vector<StaData> >& datain ) {
      float srclon = einfoin.lon, srclat = einfoin.lat;

      for(int iper=0; iper<datain.size(); iper++) {
	 for(int idata=0; idata<datain.at(iper).size(); idata++) {
	    StaData& sdtmp = datain[iper][idata];
	    //double azi, dist;
	    //calc_dist(srclat, srclon, sdtmp.lat, sdtmp.lon, &dist);
	    //calc_azimuth(srclat, srclon, sdtmp.lat, sdtmp.lon, &azi);
	    Path<double> pathcur(srclon, srclat, sdtmp.lon, sdtmp.lat);
	    sdtmp.dist = pathcur.Dist();
	    sdtmp.azi = pathcur.Azi1();
	    sdtmp.valid = true;
	    //if( azi<210 && azi>160 ) sdtmp.valid = false;
	 }
      }
   }

   // update focal corrections for rayleigh wave measurements
   // !!! Note that this only updates corrections for each station based on the new source location,
   // the focal predictions are not updated !!!
   void UpdateFocalCorrR( EpicInfo& einfoin, std::vector< std::vector<StaData> >& datain ) {
      if( datain.size()==0 ) throw ErrorFS::EmptyData(FuncName);
      if( datain.size() != per_azi_pred_R.size() ) throw ErrorFS::SizeMismatch(FuncName, "datain - per_azi_pred_R");

      // check Rayleigh source input
      //if( (fReigname.empty() || fRphvname.empty()) ) return false;

      /* ------ Corrections for Rayleigh wave ----- */
      // initialize prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      //per_azi_pred.resize( perRlist.size() );

      //RadPatternR( fReigname, fRphvname, finfo, perRlist, per_azi_pred );

      for(int iper=0; iper<datain.size(); iper++) {
	 std::vector< AziData >& adlist = per_azi_pred_R.at(iper);
	 for(int idata=0; idata<datain.at(iper).size(); idata++) {
	    StaData& sdtmp = datain[iper][idata];
	    if( ! sdtmp.valid ) continue;
	    /* binary search for sdtmp.azi in per_azi_pred list */
	    int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp, CompareAziA ) - adlist.begin();
	    //int ipredh = 1;
	    //while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh==0 ? adlist.size()-1:ipredh-1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float azifactor;// = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    try {
		AziFactor(adlist[ipredl], sdtmp, adlist[ipredh], azifactor);
	    } catch( std::runtime_error& eazi ) {
		throw ErrorFS::BadAzi(FuncName, eazi.what());
	    }
	    sdtmp.misG = adlist[ipredl].misG + (adlist[ipredh].misG-adlist[ipredl].misG) * azifactor;
	    sdtmp.misP = adlist[ipredl].misP + (adlist[ipredh].misP-adlist[ipredl].misP) * azifactor;
	    //if(iper==3) std::cerr<<sdtmp.azi<<" "<<sdtmp.misG<<" "<<sdtmp.misP<<std::endl;
	 }
      }

   }

   // update focal corrections for Love wave measurements
   void UpdateFocalCorrL( EpicInfo& einfoin, std::vector< std::vector<StaData> >& datain ) {
      if( datain.size()==0 ) throw ErrorFS::EmptyData(FuncName);
      if( datain.size() != per_azi_pred_L.size() ) throw ErrorFS::SizeMismatch(FuncName, "datain - per_azi_pred_L");

      // check Love source input
      //if( (fLeigname.empty() || fLphvname.empty()) ) return false;

      /* ------ Corrections for Love wave ----- */
      // initialize prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      //per_azi_pred.resize( perLlist.size() );

      //RadPatternR( fLeigname, fLphvname, finfo, perLlist, per_azi_pred );

      for(int iper=0; iper<datain.size(); iper++) {
	 std::vector< AziData >& adlist = per_azi_pred_L.at(iper);
	 for(int idata=0; idata<datain.at(iper).size(); idata++) {
	    StaData& sdtmp = datain[iper][idata];
	    if( ! sdtmp.valid ) continue;
	    int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp, CompareAziA ) - adlist.begin();
	    //int ipredh = 1;
	    //while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh==0 ? adlist.size()-1:ipredh-1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float azifactor;// = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    try {
		AziFactor(adlist[ipredl], sdtmp, adlist[ipredh], azifactor);
	    } catch( std::runtime_error& eazi ) {
		throw ErrorFS::BadAzi(FuncName, eazi.what());
	    }
	    sdtmp.misG = adlist[ipredl].misG + (adlist[ipredh].misG-adlist[ipredl].misG) * azifactor;
	    sdtmp.misP = adlist[ipredl].misP + (adlist[ipredh].misP-adlist[ipredl].misP) * azifactor;
	 }
      }

   }

   // erase (from a vector) data that are larger than mean + 2 sigma
   bool ExcludeLarge( std::vector<float>& data, std::vector<float>& weight ) {
      if( data.size() != weight.size() ) return false;
      // compute mean 1
      float V1 = 0., mean1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 mean1 += data[i] * weight[i];
	 V1 += weight[i];
      }
      mean1 /= V1;
      // compute std1
      float V2 = 0., std1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 float ftmp = data[i]-mean1;
	 std1 += ftmp * ftmp * weight[i];
	 V2 += weight[i] * weight[i];
      }
      std1 = sqrt( std1 * V1 / (V1*V1-V2) );
      // exclude larger-than-2sigma data
      float ubound = mean1 + 1.8*std1;// lbound = mean1 - 1.8*std1;
      int i=0;
      while( i<data.size() ) {
	 if( data[i]>ubound ) {
	    data.erase( data.begin() + i );
	    weight.erase( weight.begin() + i );
	 } else {
	    i++;
	 }
      }

      return true;
   }

   // Suppress a vector of data for 2pis. The median of the vector is used as reference
   void Suppress2PI( std::vector<float>& data, float per ) {
      if( data.size() <= 1 ) return;
      // suppress the misfit into the -per/2 ~ per/2 range
      float pero2 = per * 0.5;
      for(int idat=0; idat<data.size(); idat++) {
	 while( data[idat] > pero2 ) data[idat] -= per;
	 while( data[idat] <= -pero2 ) data[idat] += per;
      }
      // find the median as reference
      /* The nth_element() function causes glibc() when compiled with gcc 4.8.2.,
       * which is a bug in the current standard library.
       * gcc 4.8.0 seems to be working fine */
      /* uncomment if 4.8.1/4.8.2 is not used */
      std::vector<float> datatmp(data); 
      int halfs = datatmp.size() / 2;
      std::nth_element(datatmp.begin(), datatmp.begin()+halfs-1, datatmp.end());
      float median = datatmp.at(halfs-1);
      /*/ use partial_sort instead if 4.8.1/4.8.2 is used
      std::vector<float> datatmp(data);
      int halfs = datatmp.size() / 2;
      std::partial_sort(datatmp.begin(), datatmp.begin()+halfs, datatmp.end());
      float median = datatmp.at(halfs-1); */
      /*/ find the average as reference
      float median = 0.;
      for(int idat=0; idat<data.size(); idat++) median += data[idat];
      median /= data.size(); */
      // suppress again into the median-per/2 ~ median+per/2 range
      float lbound = median - pero2, ubound = median + pero2;
      for(int idat=0; idat<data.size(); idat++) {
	 while( data[idat] > ubound ) data[idat] -= per;
	 while( data[idat] <= lbound ) data[idat] += per;
      }

   }

   // Exclude measurements that are out of the 2 sigma range and compute mean and variance
   bool DataAvg( std::vector<float>& data, std::vector<float>& weight, std::vector<float>& azi, float& mean2, float& var2 ) {
      mean2 = -12345.;
      if( data.size() != weight.size() ) throw ErrorFS::SizeMismatch(FuncName, "data - weight");
      // compute mean 1
      float V1 = 0., mean1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 mean1 += data[i] * weight[i];
	 V1 += weight[i];
      }
      mean1 /= V1;
      // compute std1
      float V2 = 0., std1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 float ftmp = data[i]-mean1;
	 std1 += ftmp * ftmp * weight[i];
	 V2 += weight[i] * weight[i];
      }
      float frdm = V1*V1-V2;
      if( frdm <= 0. ) return false;
      std1 = sqrt( std1 * V1 / frdm );
      // erase bad data
      float lbound = mean1 - 1.8*std1, ubound = mean1 + 1.8*std1;
      int i=0;
      while( i<data.size() ) {
	 if( data[i]<lbound || data[i]>ubound ) {
	    data.erase(data.begin()+i);
	    weight.erase(weight.begin()+i);
	    azi.erase(azi.begin()+i);
	 } else {
	    i++;
	 }
      }
      // compute mean 2
      mean2 = 0.; V1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 //if( data[i]<lbound || data[i]>ubound ) continue;
         mean2 += data[i] * weight[i];
         V1 += weight[i];
      }
      mean2 /= V1;
      // compute var2
      V2 = 0., var2 = 0.;
      for(int i=0; i<data.size(); i++) {
	 //if( data[i]<lbound || data[i]>ubound ) continue;
	 float ftmp = data[i]-mean2;
	 var2 += ftmp * ftmp * weight[i];
	 V2 += weight[i] * weight[i];
      }
      frdm = V1*V1-V2;
      if( frdm <= 0. || data.size() < MIN_BAZI_SIZE ) {
	 mean2 = -12345.;
	 return false;
      }
      //var2 *= 1. / (V1*V1-V2);
      var2 *= V2 / ( frdm * V1 ); // std of the mean

      // enlarge variances if the dataset is too small (and thus unreliable)
      if( data.size() < 1.5 * MIN_BAZI_SIZE ) var2 *= 5.;

      return true;
   }

   // compare AziData/StaData by azimuth
   inline static bool CompareAziA( AziData sta1, AziData sta2 ) { return (sta1.azi<sta2.azi); }
   inline static bool CompareAziS( StaData sta1, StaData sta2 ) { return (sta1.azi<sta2.azi); }

   // bin-average all measurements and store the results into an AziData vector
   // !!! Note that the input data will be rearranged (with invalid points erased and then sorted by azimuth)!!!
   void BinAverage( std::vector<StaData>& datain, float per, float binstep, float binhwidth, std::vector<AziData>& result ) {
      // erase invalid data points
      for(std::vector<StaData>::iterator iter=datain.begin(); iter!=datain.end(); ) {
	 if( (*iter).valid ) {
	    iter++;
	 } else {
	    iter = datain.erase(iter);
	 }
      }
      if( datain.size() == 0 ) throw ErrorFS::EmptyData(FuncName);
      // The misV should be almost sorted if the EQKSearcher::UpdateAziDis() is called before the Search 
      // Still, sort again to be safe 
      std::sort( datain.begin(), datain.end(), CompareAziS );

      // copy the data into a new vector with boundaries extended
      float binwidth = binhwidth * 2;
      std::vector<StaData> data;
      // prepend measurements with azi>360-binhwidth*2 to the beginning
      StaData sdbound; sdbound.azi = 360-binwidth;
      std::vector<StaData>::iterator sdIbound = std::upper_bound( datain.begin(), datain.end(), sdbound, CompareAziS );
      for(std::vector<StaData>::iterator sdI=sdIbound; sdI<datain.end(); sdI++) {
	 StaData sdtmp = *sdI;
	 sdtmp.azi -= 360.;
	 data.push_back( sdtmp );
      }
      // copy datain in the middle
      size_t presize = data.size();
      data.resize( presize + datain.size() );
      std::copy( datain.begin(), datain.end(), data.begin() + presize );
      // append measurements with azi<binhwidth*2 to the end
      sdbound.azi = binwidth;
      sdIbound = std::lower_bound( datain.begin(), datain.end(), sdbound, CompareAziS );
      for(std::vector<StaData>::iterator sdI=datain.begin(); sdI<sdIbound; sdI++) {
	 StaData sdtmp = *sdI;
	 sdtmp.azi += 360;
	 data.push_back( sdtmp );
      }
      // compute average in each bin
      int nbin = (int)ceil(360 / binstep);
      result.clear(); result.resize(nbin);
      std::vector<StaData>::iterator sdI_lbound, sdI_ubound;
      sdI_lbound = sdI_ubound = data.begin();
      float alpha = -0.5/(binhwidth*binhwidth);
      for(float iazi=0; iazi<nbin; iazi++) {
	 float azi = iazi * binstep;
	 // search for data window boundaries
	 StaData sd_lbound, sd_ubound;
	 sd_lbound.azi = azi-binwidth; sd_ubound.azi = azi+binwidth;
	 sdI_lbound = std::upper_bound( sdI_lbound, data.end(), sd_lbound, CompareAziS );
	 sdI_ubound = std::lower_bound( sdI_ubound, data.end(), sd_ubound, CompareAziS );
	 if( sdI_ubound - sdI_lbound < MIN_BAZI_SIZE ) {
	    result[iazi].valid = false;
	    continue;
	 }
	 // collect data and compute weights
	 std::vector<float> dataG, dataP, dataA;
	 std::vector<float >weitG, weitP, weitA;
	 std::vector<float >aziG, aziP, aziA;
	 for(std::vector<StaData>::iterator sdI=sdI_lbound; sdI<sdI_ubound; sdI++) {
	    float dataazi = (*sdI).azi, ftmp = azi-(*sdI).azi;
	    float weight = exp(alpha*ftmp*ftmp);
	    if( (*sdI).misG != -12345. ) {
		weitG.push_back( weight );
		dataG.push_back( (*sdI).misG );
		aziG.push_back(dataazi);
	    }
	    if( (*sdI).misP != -12345. ) {
		weitP.push_back( weight );
		dataP.push_back( (*sdI).misP );
		aziP.push_back(dataazi);
	    }
	    if( (*sdI).A != -12345. ) {
		weitA.push_back( weight );
		dataA.push_back( (*sdI).A );
		aziA.push_back(dataazi);
	    }
	 }
	 // correct 2-pi
	 Suppress2PI( dataP, per );
	 // compute average in each bin and save into the result vector
	 float var;
	 bool sucG = DataAvg( dataG, weitG, aziG, result[iazi].misG, var ); //result[iazi].valid = false;
	 result[iazi].varG = std::max((float)varGmin, var);
	 bool sucP = DataAvg( dataP, weitP, aziP, result[iazi].misP, var ); //result[iazi].valid = false;
	 result[iazi].varP = std::max((float)varPmin, var);
	 bool sucA = DataAvg( dataA, weitA, aziA, result[iazi].A, var ); //result[iazi].valid = false;
	 result[iazi].varA = std::max((float)varAmin*result[iazi].A, var);
	 // compute average azimuth from all valid data
	 float azisum = 0., wsum = 0.;
	 if(sucG) for(int i=0; i<aziG.size(); i++) { azisum += aziG[i]*weitG[i]; wsum += weitG[i]; }
	 if(sucP) for(int i=0; i<aziP.size(); i++) { azisum += aziP[i]*weitP[i]; wsum += weitP[i]; }
	 if(sucA) for(int i=0; i<aziA.size(); i++) { azisum += aziA[i]*weitA[i]; wsum += weitA[i]; }
	 result[iazi].azi = wsum>0. ? azisum/wsum : azi; //azi;
	 if( result[iazi].azi < 0. ) { 
	    result[iazi].azi += 360.;
	 } else if( result[iazi].azi >= 360. ) {
	    result[iazi].azi -= 360.;
	 }
	 result[iazi].valid = true;
      }

   }

};


/* -------------------- con/destructors -------------------- */
EQKSearcher::EQKSearcher( const char* fparamin ) 
   : pimplES( new EQimpl(fparamin) ) {
   LoadParams( pimplES->fparam.c_str() );
}

EQKSearcher::~EQKSearcher() {}


/* -------------------- getters/setters -------------------- */
const EpicInfo& EQKSearcher::EInfo() const { return pimplES->einfo; }
      EpicInfo& EQKSearcher::EInfo() { return pimplES->einfo; }

/*
const std::string& EQKSearcher::FREigName() const { return pimplES->fReigname; }
      std::string& EQKSearcher::FREigName() { return pimplES->fReigname; }
const std::string& EQKSearcher::FRPhvName() const { return pimplES->fRphvname; }
      std::string& EQKSearcher::FRPhvName() { return pimplES->fRphvname; }

const std::string& EQKSearcher::FLEigName() const { return pimplES->fLeigname; }
      std::string& EQKSearcher::FLEigName() { return pimplES->fLeigname; }
const std::string& EQKSearcher::FLPhvName() const { return pimplES->fLphvname; }
      std::string& EQKSearcher::FLPhvName() { return pimplES->fLphvname; }
*/

/* -------------------- param/data preparations -------------------- */
void EQKSearcher::LoadParams( const char* fname ) {
   std::ifstream fin(fname);
   if( ! fin ) throw ErrorFS::BadFile(FuncName, fname);
   int nparam = 0;
   for( std::string stmp; std::getline(fin, stmp); ) {
      int retval = Set( stmp.c_str() );
      if( retval == -3 ) continue; // invalid input for this parameter
      else if( retval == -2 ) continue; // empty input
      else if( retval == -1 ) continue;// std::cerr<<"Warning(EQKSearcher::Load): Unknown parameter name: "<<stmp<<std::endl;
      else if( retval == 0 ) continue;// std::cerr<<"Warning(EQKSearcher::Load): Empty parameter field for "<<stmp<<std::endl;
      else nparam++;
   }
   fin.close();

   std::cout<<"### "<<nparam<<" succed loads from param file "<<fname<<". ###"<<std::endl;

   // check model inputs
   if( access(FREigName().c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, FREigName());
   if( access(FRPhvName().c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, FRPhvName());
   if( access(FLEigName().c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, FLEigName());
   if( access(FLPhvName().c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, FLPhvName());
   
   // synchronize focal-output vectors with input-measurement vectors
   if( pimplES->outlist_RF.size() != pimplES->perRtmp.size() )
      throw ErrorFS::SizeMismatch(FuncName, "pimplES->outlist_RF - pimplES->perRtmp");
   int Rsize = pimplES->perRlist.size();
   if( pimplES->outlist_RF.size() > 0 && Rsize > 0 ) {
      std::vector< std::string > strVtmp( pimplES->outlist_RF );
      pimplES->outlist_RF.clear();
      pimplES->outlist_RF.resize( Rsize );
      for(int iper=0; iper<Rsize; iper++) {
	 int iol;
	 for(iol=0; iol<strVtmp.size(); iol++) {
	    if( pimplES->perRtmp[iol] == pimplES->perRlist[iper] ) break;
	 }
	 if( iol == strVtmp.size() ) continue;
	 pimplES->outlist_RF.at(iper) = strVtmp.at(iol);
      }
      pimplES->perRtmp.clear();
   }
   if( pimplES->outlist_LF.size() != pimplES->perLtmp.size() )
      throw ErrorFS::SizeMismatch(FuncName, "pimplES->outlist_LF - pimplES->perLtmp");
   int Lsize = pimplES->perLlist.size();
   if( pimplES->outlist_LF.size() > 0 && Lsize > 0 ) {
      std::vector< std::string > strVtmp( pimplES->outlist_LF );
      pimplES->outlist_LF.clear();
      pimplES->outlist_LF.resize( Lsize );
      for(int iper=0; iper<Lsize; iper++) {
	 int iol;
	 for(iol=0; iol<strVtmp.size(); iol++) {
	    if( pimplES->perLtmp[iol] == pimplES->perLlist[iper] ) break;
	 }
	 if( iol == strVtmp.size() ) continue;
	 pimplES->outlist_LF.at(iper) = strVtmp.at(iol);
      }
      pimplES->perLtmp.clear();
   }

   if( ! pimplES->Initialize() ) throw ErrorFS::BadParam(FuncName, "invalid Rs | clon | clat");
}

int EQKSearcher::Set( const char *input ) {
   std::istringstream buff(input);
   std::string stmp;
   if( ! (buff>>stmp) ) return -2;
   bool succeed;
   if( stmp == "clon" ) { 
      succeed = buff >> pimplES->clon; 
      if( succeed && pimplES->clon<0.) pimplES->clon += 360.; 
   }
   else if( stmp == "clat" ) succeed = buff >> pimplES->clat;
   else if( stmp == "Rs") succeed = buff >> pimplES->Rs;
   else if( stmp == "strike" ) succeed = buff >> FInfo().strike;
   else if( stmp == "dip" ) succeed = buff >> FInfo().dip;
   else if( stmp == "rake" ) succeed = buff >> FInfo().rake;
   else if( stmp == "depth" ) succeed = buff >> FInfo().depth;
   else if( stmp == "fRse" ) succeed = buff >> FREigName();
   else if( stmp == "fRsp" ) succeed = buff >> FRPhvName();
   else if( stmp == "fLse" ) succeed = buff >> FLEigName();
   else if( stmp == "fLsp" ) succeed = buff >> FLPhvName();
   else if( stmp == "dflag" ) {
      char flagin;
      succeed = buff >> flagin;
      if( succeed ) {
	 RFlag() = LFlag() = false;
	 switch( flagin ) {
	    case 'B': LFlag() = true;
	    case 'R': RFlag() = true;
		break;
	    case 'L': LFlag() = true;
		break;
	    default: return -3;
	 }
      }
   }
   else if( stmp == "fRm" ) {
      std::string stmp1, stmp2, stmp3;
      float per;
      succeed = buff >> stmp1 >> stmp2 >> stmp3 >> per;
      if( succeed ) {
	 for(int iper=0; iper<pimplES->perRlist.size(); iper++) 
	    if(pimplES->perRlist.at(iper) == per) return -3;
	 pimplES->fRlist.push_back( std::vector<std::string>{stmp1, stmp2, stmp3} );
	 pimplES->perRlist.push_back( per );
      }
   }
   else if( stmp == "fLm" ) {
      std::string stmp1, stmp2, stmp3;
      float per;
      succeed = buff >> stmp1 >> stmp2 >> stmp3 >> per;
      if( succeed ) {
	 for(int iper=0; iper<pimplES->perLlist.size(); iper++) 
	    if(pimplES->perLlist.at(iper) == per) return -3;
	 pimplES->fLlist.push_back( std::vector<std::string>{stmp1, stmp2, stmp3} );
	 pimplES->perLlist.push_back( per );
      }
   }
   else if( stmp == "fmisL" ) {
      std::string& outname = pimplES->outname_mis;
      succeed = buff >> outname;
      if( succeed && access(outname.c_str(), F_OK) == 0 ) {
	 std::string oldname = outname + "_old";
	 WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
	 rename(outname.c_str(), oldname.c_str());
      }
   }
   else if( stmp == "fmisF" ) {
      std::string& outname = FMisF();
      succeed = buff >> outname;
      if( succeed && access(outname.c_str(), F_OK) == 0 ) {
	 std::string oldname = outname + "_old";
	 WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
	 rename(outname.c_str(), oldname.c_str());
      }
   }
   else if( stmp == "ffitR" ) {
      std::string outname;
      float per;
      succeed = buff >> outname >> per;
      if( succeed ) {
	 if( access(outname.c_str(), F_OK) == 0 ) {
	    std::string oldname = outname + "_old";
	    WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
	    rename(outname.c_str(), oldname.c_str());
	 }
	 pimplES->outlist_RF.push_back(outname);
	 pimplES->perRtmp.push_back(per);
      }
   }
   else if( stmp == "ffitL" ) {
      std::string outname;
      float per;
      succeed = buff >> outname >> per;
      if( succeed ) {
	 if( access(outname.c_str(), F_OK) == 0 ) {
	    std::string oldname = outname + "_old";
	    WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
	    rename(outname.c_str(), oldname.c_str());
	 }
	 pimplES->outlist_LF.push_back(outname);
	 pimplES->perLtmp.push_back(per);
      }
   }
   else return -1;
   if( succeed ) return 1;
   return 0;
}

void EQKSearcher::LoadData() {
   //int nfail = 0;

   for(int ifile=0; ifile<pimplES->fRlist.size(); ifile++) {
      std::ifstream fin(pimplES->fRlist.at(ifile).at(0).c_str());
      if( ! fin ) throw ErrorFS::BadFile(FuncName, pimplES->fRlist.at(ifile).at(0));
      pimplES->per_sta_data_R.resize( pimplES->per_sta_data_R.size() + 1 );
      for(std::string line; std::getline(fin, line); ) {
	 pimplES->per_sta_data_R.at(ifile).push_back( StaData(line.c_str()) );
      }
      fin.close();
   }

   for(int ifile=0; ifile<pimplES->fLlist.size(); ifile++) {
      std::ifstream fin(pimplES->fLlist.at(ifile).at(0).c_str());
      if( ! fin ) throw ErrorFS::BadFile(FuncName, pimplES->fLlist.at(ifile).at(0));
      pimplES->per_sta_data_L.resize( pimplES->per_sta_data_L.size() + 1 );
      for(std::string line; std::getline(fin, line); ) {
	 pimplES->per_sta_data_L.at(ifile).push_back( StaData(line.c_str()) );
      }
      fin.close();
   }

//   if( nfail > 0 ) {
//      std::cerr<<"Warning(EQKSearcher::LoadData): failed to load "<<nfail<<" of the data files!"<<std::endl;
//      return false;
//   }
   std::cout<<"### "<<pimplES->fRlist.size() + pimplES->fLlist.size()<<" data file(s) loaded. ###"<<std::endl;
}


/* -------------------- data updaters -------------------- */
void EQKSearcher::UpdateAziDis() {
   // check params and data
   if( pimplES->einfo.lon == -12345. || pimplES->einfo.lat == -12345. ) 
      throw ErrorFS::BadParam(FuncName, "invalid pimplES->einfo.lon || pimplES->einfo.lat");
   if( pimplES->per_sta_data_R.size() == 0 && pimplES->per_sta_data_L.size() == 0 ) 
      throw ErrorFS::EmptyData(FuncName, "pimplES->per_sta_data_R && pimplES->per_sta_data_L");
   // compute azimuths and distances
   pimplES->UpdateAziDis( pimplES->einfo, pimplES->per_sta_data_R);
   pimplES->UpdateAziDis( pimplES->einfo, pimplES->per_sta_data_L);
   // sort by azimuth
   std::vector< std::vector<StaData> >& dataR = pimplES->per_sta_data_R;
   for(int iper=0; iper<dataR.size(); iper++) {
      std::sort( dataR[iper].begin(), dataR[iper].end(), pimplES->CompareAziS );
   }
   std::vector< std::vector<StaData> >& dataL = pimplES->per_sta_data_L;
   for(int iper=0; iper<dataL.size(); iper++) {
      std::sort( dataL[iper].begin(), dataL[iper].end(), pimplES->CompareAziS );
   }

   int iper = 3;
}


void EQKSearcher::UpdateFocalCorr( bool flag ) {
   if( pimplES->perRlist.size()==0 && pimplES->perLlist.size()==0 )
      throw ErrorFS::EmptyData(FuncName, "pimplES->perRlist && pimplES->perLlist");

   // check Rayleigh source input
   if( pimplES->perRlist.size() != 0 &&
      (FREigName().empty() || FRPhvName().empty()) )
      throw ErrorFS::BadParam(FuncName, "empty FREigName() || FRPhvName()");
   
   // check Love source input
   if( pimplES->perLlist.size() != 0 &&
      (FLEigName().empty() || FLPhvName().empty()) )
      throw ErrorFS::BadParam(FuncName, "empty FLEigName() || FLPhvName()");

   /* ------ Corrections for Rayleigh wave ----- */
   if( pimplES->perRlist.size() > 0 ) {
      //std::vector<float> perRlst;
      //for(int i=0; i<pimplES->perRlist.size(); i++) perRlst.push_back(pimplES->perRlist.at(i));
      std::vector<float>& perRlst = pimplES->perRlist;

      // initialize/reset prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      pimplES->per_azi_pred_R.clear();
      //pimplES->per_azi_pred_R.resize( perRlst.size() );

      bool succeed;
//      if(flag) succeed = RadPatternR( FREigName(), FRPhvName(), FInfo(), perRlst, pimplES->per_azi_pred_R );
//      else succeed = RadPatternR( FREigName(), FRPhvName(), FInfoOld(), perRlst, pimplES->per_azi_pred_R );
      if(flag) pimplES->rp.Predict( 'R', FREigName(), FRPhvName(), FInfo(), perRlst, pimplES->per_azi_pred_R);
      else pimplES->rp.Predict( 'R', FREigName(), FRPhvName(), FInfoOld(), perRlst, pimplES->per_azi_pred_R);

      double Afactor = AFactorR();
      if( Afactor == -12345. ) Afactor = 1.;
      for(int iper=0; iper<pimplES->per_sta_data_R.size(); iper++) {
	 std::vector< AziData >& adlist = pimplES->per_azi_pred_R.at(iper);
	 for(int idata=0; idata<pimplES->per_sta_data_R.at(iper).size(); idata++) {
	    StaData& sdtmp = pimplES->per_sta_data_R[iper][idata];
	    if( ! sdtmp.valid ) continue;
	    int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp, pimplES->CompareAziA )
		         - adlist.begin();
	    //int ipredh = 1;
	    //while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh-1;
	    if( ipredl == -1 ) ipredl = adlist.size() - 1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float azifactor;// = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    try {
		pimplES->AziFactor(adlist[ipredl], sdtmp, adlist[ipredh], azifactor);
	    } catch( std::runtime_error& eazi ) {
		throw ErrorFS::BadAzi(FuncName, eazi.what());
	    }
	    sdtmp.misG = adlist[ipredl].misG + (adlist[ipredh].misG-adlist[ipredl].misG) * azifactor;
	    sdtmp.misP = adlist[ipredl].misP + (adlist[ipredh].misP-adlist[ipredl].misP) * azifactor;
	    sdtmp.Apred = adlist[ipredl].A + (adlist[ipredh].A-adlist[ipredl].A) * azifactor;
	    sdtmp.Apred *= Afactor;
	     //if(iper==3) std::cerr<<sdtmp.azi<<" "<<sdtmp.misG<<" "<<sdtmp.misP<<std::endl;
	 }
      }

   }

   /* ------ Corrections for Love wave ----- */
   if( pimplES->perLlist.size() > 0 ) {
      //std::vector<float> perLlst;
      //for(int i=0; i<pimplES->perLlist.size(); i++) perLlst.push_back(pimplES->perLlist.at(i).per);
      std::vector<float>& perLlst = pimplES->perLlist;

      // initialize prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      pimplES->per_azi_pred_L.clear();
      //pimplES->per_azi_pred_L.resize( perLlst.size() );

/* module RadPatternL is not done yet !!! */
//      bool succeed = RadPatternL( FLEigName(), FLPhvName(), FInfo(), perLlst, pimplES->per_azi_pred_L );
      pimplES->rp.Predict( 'L', FLEigName(), FLPhvName(), FInfo(), perLlst, pimplES->per_azi_pred_L );

      double Afactor = AFactorL();
      if( Afactor == -12345. ) Afactor = 1.;
      for(int iper=0; iper<pimplES->per_sta_data_L.size(); iper++) {
	 std::vector< AziData >& adlist = pimplES->per_azi_pred_L.at(iper);
	 for(int idata=0; idata<pimplES->per_sta_data_L.at(iper).size(); idata++) {
	    StaData& sdtmp = pimplES->per_sta_data_L.at(iper).at(idata);
	    if( ! sdtmp.valid ) continue;
	    int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp, pimplES->CompareAziA )
		         - adlist.begin();
	    //int ipredh = 1;
	    //while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh-1;
	    if( ipredl == -1 ) ipredl = adlist.size() - 1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float azifactor;// = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    try {
		pimplES->AziFactor(adlist[ipredl], sdtmp, adlist[ipredh], azifactor);
	    } catch( std::runtime_error& eazi ) {
		throw ErrorFS::BadAzi(FuncName, eazi.what());
	    }
	    sdtmp.misG = adlist[ipredl].misG + (adlist[ipredh].misG-adlist[ipredl].misG) * azifactor;
	    sdtmp.misP = adlist[ipredl].misP + (adlist[ipredh].misP-adlist[ipredl].misP) * azifactor;
	    sdtmp.Apred = adlist[ipredl].A + (adlist[ipredh].A-adlist[ipredl].A) * azifactor;
	    sdtmp.Apred *= Afactor;
	 }
      }

   }

}


/* -------------------- data output -------------------- */
void EQKSearcher::OutputFocal() {
   // check data existence
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
   // check epicenter location
   EpicInfo& einfo = pimplES->einfo;
   if( einfo.lon==-12345. || einfo.lat==-12345. || einfo.t0==-12345. )
      throw ErrorFS::BadParam(FuncName, "invalid einfo.lon || einfo.lat || einfo.t0");
   // check vel pred maps
   if( pimplES->fRlist.size()!=Rsize || pimplES->fLlist.size()!=Lsize )
      throw ErrorFS::SizeMismatch(FuncName, "fRlist - Rsize || fLlist - Lsize");
   for(int iper=0; iper<Rsize; iper++) {
      if( pimplES->outlist_RF.at(iper).empty() ) continue;
      if( access(pimplES->fRlist.at(iper).at(1).c_str(), R_OK) == -1 )
	 throw ErrorFS::BadFile(FuncName, pimplES->fRlist.at(iper).at(1));
      if( access(pimplES->fRlist.at(iper).at(2).c_str(), R_OK) == -1 )
	 throw ErrorFS::BadFile(FuncName, pimplES->fRlist.at(iper).at(2));
   }
   for(int iper=0; iper<Lsize; iper++) {
      if( pimplES->outlist_LF.at(iper).empty() ) continue;
      if( access(pimplES->fLlist.at(iper).at(1).c_str(), R_OK) == -1 )
	 throw ErrorFS::BadFile(FuncName, pimplES->fLlist.at(iper).at(1));
      if( access(pimplES->fLlist.at(iper).at(2).c_str(), R_OK) == -1 )
	 throw ErrorFS::BadFile(FuncName, pimplES->fLlist.at(iper).at(2));
   }

   // output misfit ( measured + t0 - predicted ) and focal_corrections for Rayleigh
   float srclon = einfo.lon, srclat = einfo.lat, srct0 = einfo.t0;
   for(int iper=0; iper<Rsize; iper++) {
      // open output file 
      std::string outname = pimplES->outlist_RF.at(iper);
      if( outname.empty() ) continue;
      //outname += "_" + std::string(label);
      std::ofstream fout( outname, std::ofstream::app );
      // read in vel maps
      std::string& fname1 = pimplES->fRlist.at(iper).at(1);
      if( access(fname1.c_str(), R_OK) == -1 ) throw ErrorFS::BadFile(FuncName, fname1);
      Map map1(fname1.c_str(), Point<float>(srclon, srclat));
      std::string& fname2 = pimplES->fRlist.at(iper).at(2);
      if( access(fname2.c_str(), R_OK) == -1 ) throw ErrorFS::BadFile(FuncName, fname2);
      Map map2(fname2.c_str(), Point<float>(srclon, srclat));
      // period and wavelength
      float per = pimplES->perRlist.at(iper), pero2 = per*0.5, lamda = per * Lfactor;
      fout<<"# [ epic = "<<EInfo()<<"  focal = "<<FInfo()<<" ]"<<std::endl;
      for(int idat=0; idat<pimplES->per_sta_data_R.at(iper).size(); idat++) {
	 StaData& sdcur = pimplES->per_sta_data_R[iper][idat];
	 if( ! sdcur.valid ) continue;
	 float percG, percP;
	 float velG = map1.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percG ).Data();
	 float velP = map2.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percP ).Data();
	 float misG = sdcur.grT + srct0 - sdcur.dist/velG;
	 float misP = sdcur.phT + srct0 - sdcur.dist/velP;
	 if( percG < Min_Perc || percP < Min_Perc ) continue;
	 // correct 2pi
	 misP -= sdcur.misP;
	 while( misP > pero2 ) misP -= per;
	 while( misP <= -pero2 ) misP += per;
	 misP += sdcur.misP;
	 fout<<sdcur.azi<<"   "<<misG<<" "<<sdcur.misG<<"   "<<misP<<" "
	     <<sdcur.misP<<"   "<<sdcur.A<<" "<<sdcur.Apred<<std::endl;
      }
      fout<<std::endl<<std::endl; fout.close();
   }

   // output misfit ( measured + t0 - predicted ) and focal_corrections for Love
   for(int iper=0; iper<Lsize; iper++) {
      // open output file 
      std::string outname = pimplES->outlist_LF.at(iper);
      if( outname.empty() ) continue;
      //outname += "_" + std::string(label);
      std::ofstream fout( outname, std::ofstream::app );
      // read in vel maps
      std::string& fname1 = pimplES->fLlist.at(iper).at(1);
      if( access(fname1.c_str(), R_OK) == -1 ) throw ErrorFS::BadFile(FuncName, fname1);
      Map map1(fname1.c_str(), Point<float>(srclon, srclat));
      std::string& fname2 = pimplES->fLlist.at(iper).at(2);
      if( access(fname2.c_str(), R_OK) == -1 ) throw ErrorFS::BadFile(FuncName, fname2);
      Map map2(fname2.c_str(), Point<float>(srclon, srclat));
      // period and wavelength
      float per = pimplES->perLlist.at(iper), pero2 = per*0.5, lamda = per * Lfactor;
      fout<<"# [ epic = "<<EInfo()<<"  focal = "<<FInfo()<<" ]"<<std::endl;
      for(int idat=0; idat<pimplES->per_sta_data_L.at(iper).size(); idat++) {
	 StaData& sdcur = pimplES->per_sta_data_L[iper][idat];
	 if( ! sdcur.valid ) continue;
	 float percG, percP;
	 float velG = map1.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percG ).Data();
	 float velP = map2.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percP ).Data();
	 float misG = sdcur.grT + srct0 - sdcur.dist/velG;
	 float misP = sdcur.phT + srct0 - sdcur.dist/velP;
	 if( percG < Min_Perc || percP < Min_Perc ) continue;
	 // correct 2pi
	 misP -= sdcur.misP;
	 while( misP > pero2 ) misP -= per;
	 while( misP <= -pero2 ) misP += per;
	 misP += sdcur.misP;
	 fout<<sdcur.azi<<"   "<<misG<<" "<<sdcur.misG<<"   "<<misP<<" "
	     <<sdcur.misP<<"   "<<sdcur.A<<" "<<sdcur.Apred<<std::endl;
      }
      fout<<std::endl<<std::endl; fout.close();
   }

}


/* -------------------- compute misfit square at a given location -------------------- */
void EQKSearcher::EnergyL( EpicInfo& einfo, float& E ) {
   // check input params
   if( einfo.lon==-12345. || einfo.lat==-12345. || einfo.t0==-12345. )
      throw ErrorFS::BadParam(FuncName, "invalid einfo.lon || einfo.lat || einfo.t0");
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");

   float srclon = einfo.lon, srclat = einfo.lat, srct0 = einfo.t0;
   float Esum = 0., Wsum = 0.;

   // weightings
   float weightR = 0.5, weightL = 0.5;
   float dismin = 0., dismax = 9999.;
   // compute misfit (measured + t0 - predicted - focal_correction ) for Rayleigh maps
   if( Rsize>0 && RFlag() ) {
//einfo = EpicInfo(245.481, 41.0386, -1.93645);
      std::vector< std::vector<StaData> > dataR = pimplES->per_sta_data_R;
      pimplES->UpdateAziDis( einfo, dataR );
      pimplES->UpdateFocalCorrR( einfo, dataR );
      for(int iper=0; iper<Rsize; iper++) {
	 std::string& fname1 = pimplES->fRlist.at(iper).at(1);
	 if( access(fname1.c_str(), R_OK) == -1 ) throw ErrorFS::BadFile(FuncName, fname1);
	 Map map1(fname1.c_str(), Point<float>(srclon, srclat));

	 std::string& fname2 = pimplES->fRlist.at(iper).at(2);
	 if( access(fname2.c_str(), R_OK) == -1 ) throw ErrorFS::BadFile(FuncName, fname2);
	 Map map2(fname2.c_str(), Point<float>(srclon, srclat));

	 float per = pimplES->perRlist.at(iper), pero2 = 0.5*per, lamda = per * Lfactor;
	 std::vector<StaData> misV;//( dataR[iper].size() );
	 for( int idat=0; idat<dataR[iper].size(); idat++ ) {
	    StaData& sdcur = dataR[iper][idat];
	    if( ! sdcur.valid ) continue;
	    if( sdcur.dist < dismin || sdcur.dist > dismax ) continue;
	    float percG, percP;
	    float velG = map1.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percG ).Data();
	    float velP = map2.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percP ).Data();
	    float misG = sdcur.grT + srct0 - sdcur.misG - sdcur.dist/velG;
	    float misP = sdcur.phT + srct0 - sdcur.misP - sdcur.dist/velP;
	    while( misP > pero2 ) misP -= per;
	    while( misP < -pero2 ) misP += per;
	    StaData sdtmp;
	    sdtmp.azi = sdcur.azi;
	    //sdtmp.A = sdcur.A;
	    sdtmp.valid = true;
	    if( percG > Min_Perc ) sdtmp.misG = misG;//misGV.push_back( misG*misG );
	    if( percP > Min_Perc ) sdtmp.misP = misP;//misPV.push_back( misP*misP);
	    misV.push_back( sdtmp );
	 }
	 // compute azimuthal average
	 float binstep = 5, binhwidth = BINHWIDTH;
	 std::vector<AziData> dataAzi;
	 //std::sort( misV.begin(), misV.end(), pimplES->CompareAziS );
	 pimplES->BinAverage( misV, per, binstep, binhwidth, dataAzi );
	 // compute average misfit square (excluding bad data)
	 std::vector<float> misGV, misPV;
	 std::vector<float> weitG, weitP;
	 for(int imis=0; imis<dataAzi.size(); imis++) {
	    if( ! dataAzi[imis].valid ) continue;
	    float ftmp = dataAzi[imis].misG;
	    if( ftmp != -12345. ) {
		misGV.push_back( ftmp * ftmp );
		weitG.push_back( weightR / dataAzi[imis].varG );
	    }
	    ftmp = dataAzi[imis].misP;
	    if( ftmp != -12345. ) {
		misPV.push_back( ftmp * ftmp );
		weitP.push_back( weightR / dataAzi[imis].varP );
	    }
	 }
	 for(int i=0; i<NEX; i++)
	    if( ! pimplES->ExcludeLarge( misGV, weitG ) ) throw ErrorFS::SizeMismatch(FuncName, "misGV - weitG");
	 for(int i=0; i<NEX; i++)
	    if( ! pimplES->ExcludeLarge( misPV, weitP ) ) throw ErrorFS::SizeMismatch(FuncName, "misPV - weitP");
	 //E += EG*0.2 + EP*0.8;// / dataR[iper].size() );
	 for(int idat=0; idat<misGV.size(); idat++) { Esum += misGV[idat]*weitG[idat]; Wsum += weitG[idat]; }// if(weitG[idat]>1200) std::cerr<<"R  misG = "<<misGV[idat]<<"   weightG = "<<weitG[idat]<<std::endl; }
	 for(int idat=0; idat<misPV.size(); idat++) { Esum += misPV[idat]*weitP[idat]; Wsum += weitP[idat]; }// if(weitP[idat]>1200) std::cerr<<"R  misP = "<<misPV[idat]<<"   weightP = "<<weitP[idat]<<std::endl; }
      }
   }

   // compute misfit (measured + t0 - predicted - focal_correction) for Love maps
   if( Lsize>0 && LFlag() ) {
      std::vector< std::vector<StaData> > dataL = pimplES->per_sta_data_L;
      pimplES->UpdateAziDis( einfo, dataL );
      pimplES->UpdateFocalCorrL( einfo, dataL );
      for(int iper=0; iper<Lsize; iper++) {
	 std::string& fname1 = pimplES->fLlist.at(iper).at(1);
	 if( access(fname1.c_str(), R_OK) == -1 ) throw ErrorFS::BadFile(FuncName, fname1);
	 Map map1(fname1.c_str(), Point<float>(srclon, srclat));
	 std::string& fname2 = pimplES->fLlist.at(iper).at(2);
	 if( access(fname2.c_str(), R_OK) == -1 ) throw ErrorFS::BadFile(FuncName, fname2);
	 Map map2(fname2.c_str(), Point<float>(srclon, srclat));

	 float per = pimplES->perLlist.at(iper), pero2 = 0.5*per, lamda = per * Lfactor;
	 std::vector<StaData> misV;//( dataL[iper].size() );
	 for( int idat=0; idat<dataL[iper].size(); idat++ ) {
	    StaData& sdcur = dataL[iper][idat];
	    if( ! sdcur.valid ) continue;
	    if( sdcur.dist < dismin || sdcur.dist > dismax ) continue;
	    float percG, percP;
	    float velG = map1.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percG ).Data();
	    float velP = map2.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percP ).Data();
	    float misG = sdcur.grT + srct0 - sdcur.misG - sdcur.dist/velG;
	    float misP = sdcur.phT + srct0 - sdcur.misP - sdcur.dist/velP;
	    while( misP > pero2 ) misP -= per;
	    while( misP < -pero2 ) misP += per;
	    StaData sdtmp;
	    sdtmp.azi = sdcur.azi;
	    sdtmp.valid = true;
	    if( percG > Min_Perc ) sdtmp.misG = misG;//misGV.push_back( misG*misG );
	    if( percP > Min_Perc ) sdtmp.misP = misP;//misPV.push_back( misP*misP);
	    misV.push_back( sdtmp );
	 }
	 // compute azimuthal average
	 float binstep = 5, binhwidth = BINHWIDTH;
	 std::vector<AziData> dataAzi;
	 //std::sort( misV.begin(), misV.end(), pimplES->CompareAziS );
	 pimplES->BinAverage( misV, per, binstep, binhwidth, dataAzi );
	 // compute average misfit square (excluding bad data)
	 std::vector<float> misGV, misPV;
	 std::vector<float> weitG, weitP;
	 for(int imis=0; imis<dataAzi.size(); imis++) {
	    if( ! dataAzi[imis].valid ) continue;
	    float ftmp = dataAzi[imis].misG;
	    if( ftmp != -12345. ) {
		misGV.push_back( ftmp * ftmp );
		weitG.push_back( weightL / dataAzi[imis].varG );
	    }
	    ftmp = dataAzi[imis].misP;
	    if( ftmp != -12345. ) {
		misPV.push_back( ftmp * ftmp );
		weitP.push_back( weightL / dataAzi[imis].varP );
	    }
	 }
	 for(int i=0; i<NEX; i++) 
	    if( ! pimplES->ExcludeLarge( misGV, weitG ) ) throw ErrorFS::SizeMismatch(FuncName, "misGV - weitG");
	 for(int i=0; i<NEX; i++)
	    if( ! pimplES->ExcludeLarge( misPV, weitP ) ) throw ErrorFS::SizeMismatch(FuncName, "misPV - weitP");
	 //E += EG*0.2 + EP*0.8;// / dataR[iper].size() );
	 for(int idat=0; idat<misGV.size(); idat++) { Esum += misGV[idat]*weitG[idat]; Wsum += weitG[idat]; }// if(weitG[idat]>1200) std::cerr<<"L  misG = "<<misGV[idat]<<"   weightG = "<<weitG[idat]<<std::endl;}
	 for(int idat=0; idat<misPV.size(); idat++) { Esum += misPV[idat]*weitP[idat]; Wsum += weitP[idat]; }// if(weitP[idat]>1200) std::cerr<<"L  misP = "<<misPV[idat]<<"   weightP = "<<weitP[idat]<<std::endl;}
      }
   }

   // normalize total energy
   E = Esum / Wsum;

}


/* -------------------- average the data by azimuth and store the results for FocalSearcher -------------------- */
void EQKSearcher::PrepareFocalData() {
   // check einfo
   EpicInfo einfo = pimplES->einfo;
   float srclon = einfo.lon, srclat = einfo.lat, srct0 = einfo.t0;
   if( srclon==-12345. || srclat==-12345. || srct0==-12345. )
      throw ErrorFS::BadParam(FuncName, "invalid einfo.lon || einfo.lat || einfo.t0");

   // check input measurements
   if( (!RFlag()) && (!LFlag()) ) throw ErrorFS::EmptyData(FuncName, "RFlag() && LFlag()");
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
   if( pimplES->perRlist.size() != Rsize || pimplES->perLlist.size() != Lsize ) 
      throw ErrorFS::SizeMismatch(FuncName, "perRlist - Rsize || perLlist - Lsize");

   // compute azi-misfit for Rayleigh wave
   if( Rsize>0 && RFlag() ) {
      // check source files
      if( FREigName().empty() || FRPhvName().empty() )
	 throw ErrorFS::BadParam(FuncName, "empty FREigName() || FRPhvName()");

      // compute misfit (measured + t0 - predicted) for Rayleigh maps
      std::vector< std::vector<StaData> > dataR = pimplES->per_sta_data_R;
      pimplES->UpdateAziDis( einfo, dataR );
      //pimplES->UpdateFocalCorrR( einfo, dataR );
      Per_R_Azi_Data().clear(); Per_R_Azi_Data().resize(Rsize);
      PerRList().clear(); PerRList().resize(Rsize);
      for(int iper=0; iper<Rsize; iper++) {
	 std::string& fname1 = pimplES->fRlist.at(iper).at(1);
	 if( access(fname1.c_str(), R_OK) == -1 ) throw ErrorFS::BadFile(FuncName, fname1);
	 Map map1(fname1.c_str(), Point<float>(srclon, srclat));

	 std::string& fname2 = pimplES->fRlist.at(iper).at(2);
	 if( access(fname2.c_str(), R_OK) == -1 ) throw ErrorFS::BadFile(FuncName, fname2);
	 Map map2(fname2.c_str(), Point<float>(srclon, srclat));

	 float per = pimplES->perRlist.at(iper), pero2 = 0.5*per, lamda = per * Lfactor;
	 // compute misfits and store in a vector for bin-average later
	 std::vector<StaData>& data_cur = dataR[iper];
	 for( int idat=0; idat<data_cur.size(); idat++ ) {
	    StaData& sdcur = data_cur[idat];
	    if( ! sdcur.valid ) continue;
	    float percG, percP;
	    float velG = map1.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percG ).Data();
	    float velP = map2.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percP ).Data();
	    sdcur.misG = sdcur.grT + srct0 - sdcur.dist/velG;
	    float misP = sdcur.phT + srct0 - sdcur.misP - sdcur.dist/velP;
	    if( percG < Min_Perc ) sdcur.misG = -12345.;
	    if( percP < Min_Perc ) {
		sdcur.misP = -12345.;
	    } else {
		while( misP > pero2 ) misP -= per;
		while( misP < -pero2 ) misP += per;
		sdcur.misP = misP + sdcur.misP;
	    }
	    //Ecur += misG*misG*0.5 + misP*misP*0.5;
	 }
	 //std::sort( data_cur.begin(), data_cur.end(), pimplES->CompareAziS );
	 // bin average 
	 float binstep = 5., binhwidth = BINHWIDTH;
	 pimplES->BinAverage( data_cur, per, binstep, binhwidth, Per_R_Azi_Data().at(iper) );
	 PerRList().at(iper) = PerDazi( per, binstep );
	 //E += Ecur;// / data_cur.size() );
      }
   }

   // compute azi-misfit for Love wave
   if( Lsize>0 && LFlag() ) {
      // check source files
      if( FLEigName().empty() || FLPhvName().empty() )
	 throw ErrorFS::BadParam(FuncName, "empty FLEigName() || FLPhvName()");

      // compute misfit (measured + t0 - predicted) for Rayleigh maps
      std::vector< std::vector<StaData> > dataL = pimplES->per_sta_data_L;
      pimplES->UpdateAziDis( einfo, dataL );
      //pimplES->UpdateFocalCorrL( einfo, dataL );
      Per_L_Azi_Data().clear(); Per_L_Azi_Data().resize(Lsize);
      PerLList().clear(); PerLList().resize(Lsize);
      for(int iper=0; iper<Lsize; iper++) {
	 std::string& fname1 = pimplES->fLlist.at(iper).at(1);
	 if( access(fname1.c_str(), R_OK) == -1 ) throw ErrorFS::BadFile(FuncName, fname1);
	 Map map1(fname1.c_str(), Point<float>(srclon, srclat));

	 std::string& fname2 = pimplES->fLlist.at(iper).at(2);
	 if( access(fname2.c_str(), R_OK) == -1 ) throw ErrorFS::BadFile(FuncName, fname2);
	 Map map2(fname2.c_str(), Point<float>(srclon, srclat));

	 float per = pimplES->perLlist.at(iper), pero2 = 0.5*per, lamda = per * Lfactor;
	 // compute misfits and store in a vector for bin-average later
	 std::vector<StaData>& data_cur = dataL[iper];
	 for( int idat=0; idat<data_cur.size(); idat++ ) {
	    StaData& sdcur = data_cur[idat];
	    if( ! sdcur.valid ) continue;
	    float percG, percP;
	    float velG = map1.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percG ).Data();
	    float velP = map2.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percP ).Data();
	    sdcur.misG = sdcur.grT + srct0 - sdcur.dist/velG;
	    float misP = sdcur.phT + srct0 - sdcur.misP - sdcur.dist/velP;
	    if( percG < Min_Perc ) sdcur.misG = -12345.;
	    if( percP < Min_Perc ) {
		sdcur.misP = -12345.;
	    } else {
		while( misP > pero2 ) misP -= per;
		while( misP < -pero2 ) misP += per;
		sdcur.misP = misP + sdcur.misP;
	    }
	    //Ecur += misG*misG*0.5 + misP*misP*0.5;
	 }
	 // bin average 
	 float binstep = 5., binhwidth = BINHWIDTH;
	 pimplES->BinAverage( data_cur, per, binstep, binhwidth, Per_L_Azi_Data().at(iper) );
	 PerLList().at(iper) = PerDazi( per, binstep );
	 //E += Ecur;// / data_cur.size() );
      }
   }

}


/* -------------------- search for optimal epi location with a simulated annealing algorithm -------------------- */
void EQKSearcher::SearchLocation( int nsearch, float alpha, float Tfactor ) {
   // check epic parameters
   if( pimplES->clon==-12345. || pimplES->clat==-12345. || pimplES->Rs==-12345. )
      throw ErrorFS::BadParam(FuncName, "invalid clon || clat || Rs");
   EpicInfo& einfo = pimplES->einfo;
   if( einfo.lon==-12345. || einfo.lat==-12345. || einfo.t0==-12345. )
      throw ErrorFS::BadParam(FuncName, "invalid einfo.lon || einfo.lat || einfo.t0");
   // check input measurements
   if( (!RFlag()) && (!LFlag()) ) throw ErrorFS::EmptyData(FuncName, "RFlag() && LFlag()");
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
   if( pimplES->perRlist.size() != Rsize || pimplES->perLlist.size() != Lsize )
      throw ErrorFS::SizeMismatch(FuncName, "perRlist - Rsize || perLlist - Lsize");
   // check vel map accessibilities
   for(int iper=0; iper<Rsize; iper++) {
      if( access(pimplES->fRlist.at(iper).at(1).c_str(), R_OK) == -1 ) 
	 throw ErrorFS::BadFile(FuncName, pimplES->fRlist.at(iper).at(1));
      if( access(pimplES->fRlist.at(iper).at(2).c_str(), R_OK) == -1 )
	 throw ErrorFS::BadFile(FuncName, pimplES->fRlist.at(iper).at(2));
   }
   for(int iper=0; iper<Lsize; iper++) {
      if( access(pimplES->fLlist.at(iper).at(1).c_str(), R_OK) == -1 ) 
	 throw ErrorFS::BadFile(FuncName, pimplES->fLlist.at(iper).at(1));
      if( access(pimplES->fLlist.at(iper).at(2).c_str(), R_OK) == -1 )
	 throw ErrorFS::BadFile(FuncName, pimplES->fLlist.at(iper).at(2));
   }

   // simulated annealing
   float E;
   EnergyL(pimplES->einfo, E);
   float T = E * Tfactor;
   std::cout<<"### SearchLocation: Initial Misfit**2 for "<<pimplES->einfo<<"&&"<<FInfo()<<" = "<<E<<" T="<<T<<" ###"<<std::endl;
   EpicInfo einfobest = pimplES->einfo;
   float Ebest = E;
   int nrej = 0;
   int isearch = 0;
   std::ofstream fout;
   bool output_mis = ! pimplES->outname_mis.empty();
   if( output_mis ) fout.open(  pimplES->outname_mis.c_str(), std::ofstream::app );
   
   fout<<"# [ epic = "<<EInfo()<<" ]"<<std::endl;
   fout<< "-1\t" << E << "\t" << T << std::endl;
   char type = RFlag()&&LFlag() ? 'B' : (RFlag()?'R':'L');
   #pragma omp parallel for schedule (dynamic, 1)
   for( int i=0; i<nsearch; i++ ) {
      EpicInfo einfonew = pimplES->Neighbour( pimplES->einfo );
      float Enew = -12345.;
      EnergyL(einfonew, Enew);
      if( pimplES->Accept(E, Enew, T) ) {
	 pimplES->einfo = einfonew;
	 E = Enew;
	 if( output_mis ) {
	#pragma omp critical
	{ // critical start
	    fout<< std::setw(4)<<isearch << " " << std::setw(8)<<Enew << " "
		<< std::setw(8)<<T << "\t" << pimplES->einfo <<std::endl;
	    fout.flush();
	} // critical end
	 }
	 std::cout<<"   Misfit**2 for "<<einfonew<<" = "<<Enew<<" (accepted)  T="
		  <<T<<"  isearch="<<isearch<<"/"<<nsearch<<"  type="<<type<<std::endl;
	 nrej = 0;
      }
      else { nrej++; std::cout<<"( nrejects = "<<nrej<<" )"<<"  ithread="<<omp_get_thread_num()<<"                  "<<std::endl<<"\x1b[A"; }
     #pragma omp critical
     { // critical start
      T *= alpha;
      if( Enew < Ebest ) {
	 einfobest = einfonew;
	 Ebest = Enew;
      }
      isearch++;
     } // critical end
   }
   fout<< isearch << "\t" << Ebest << "\t" << T << "\t" << einfobest << std::endl;
   fout<<std::endl<<std::endl; fout.close();
   std::cout<<"                                   "<<std::endl;
   pimplES->einfo = einfobest;

}

#include "EQKSearcher.h"
#include "RadPattern.h"
#include "DisAzi.h"
#include "Map.h"
#include "FileName.h"
#include "MyOMP.h"
#include <unistd.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <algorithm>
#include <chrono>
#include <thread>

#include <unistd.h>
#include <sys/stat.h>

/* -------------------- implimentation details -------------------- */
struct EQKSearcher::EQimpl {

	
	float clon, clat, ct0 = 0., Rs;
	float Rt, Rlon, Rlat;
	float weightR_Loc, weightL_Loc;  // weighting between Rayleigh and Love data for Location search
	float weightR_Foc, weightL_Foc;  // weighting between Rayleigh and Love data for Focal search
	char datatype_name;
	Dtype datatype;
	EpicInfo einfo;
	FocalInfo<ftype> finfo;

	FileName fparam;					// parameter file
	FileName outname_misF;				// filename for output focal misfit
	FileName outname_misL;				// filename for output location misfit
	FileName outname_misAll;			// filename for output all separated misfits (group, phase, amplitude)
	FileName outname_pos;				// filename for output posterior distribution
	FileName fReigname, fRphvname;			// input eigen-function file
	FileName fLeigname, fLphvname;			// input phase-velocity file
	std::vector< FileName > outlist_RF, outlist_LF;	// filename for output focal_fit
	std::vector< FileName > outlist_RP, outlist_LP;	// filename for output travel time predictions
	std::vector< std::vector<FileName> > fRlist, fLlist;

	std::vector<float> perRtmp_fit, perLtmp_fit;		// tmp period list
	std::vector<float> perRtmp_pred, perLtmp_pred;	// tmp period list
	std::vector<float> perRlist, perLlist;				// period list for rayleigh and love waves
	/* It's perfectly OK to use vector of vector here as the data for each
	 * period are accessed independently. Consider changing to Array2D if 
	 * the access pattern is changed somehow */
	std::vector< std::vector<StaData> > per_sta_data_R, per_sta_data_L;
	std::vector< std::vector<AziData> > per_azi_pred_R, per_azi_pred_L;

	RadPattern rpR, rpL;

	std::vector<Rand> randO;

	//number of data points for EnergyMC
	int NC;

	// temperory string
	static std::string sTrash;


	EQimpl( const std::string fparamin = "", float clonin = NaN,
			float clatin = NaN, float Rsin = 30. )
		: fparam(fparamin), clon(clonin), clat(clatin), Rs(Rsin), Rt(20.), NC(NaN), datatype(Undefined)
		  , weightR_Loc(1.), weightL_Loc(1.), weightR_Foc(1.), weightL_Foc(1.)  {
			  // produce Rand object for each thread
			  for(int i=0; i<omp_get_max_threads(); i++) {
				  // apply separated seed by sleeping
				  randO.push_back( Rand() );
				  std::this_thread::sleep_for(std::chrono::milliseconds(100));
			  }
			  Initialize();
		  }

	// set search ranges
	bool Initialize() {
		if( Rs>0 && clon!=NaN && clat!=NaN) {
			double dist;
			try {
				//calc_dist(clat, clon, clat, clon+1, &dist);
				dist = Path<double>(clon, clat, clon+1., clat).Dist();
				Rlon = Rs / dist;
				//calc_dist(clat, clon, clat+1, clon, &dist);
				dist = Path<double>(clon, clat, clon, clat+1.).Dist();
				Rlat = Rs / dist;
			} catch ( std::exception& e ) {
				std::cerr<<e.what()<<std::endl;
				return false;
			}
			einfo = EpicInfo(clon, clat, ct0);
			return true;
		}
		else {
			Rlon = Rlat = NaN;
			return false;
		}
	}

	/* synchronize output vectors with input-measurement vectors */
	void ArrangeOutlist ( std::vector<FileName>& outlist, std::vector<float>& outperlst, const std::vector<float>& perlst ) {
		// check sizes
		if( outlist.size() != outperlst.size() )
			throw ErrorFS::SizeMismatch(FuncName, "outlist - outperlst");
		// save and clear the outlist
		std::vector< FileName > strVtmp( std::move(outlist) );
		outlist.clear();
		
		// for each output filename, search for matching period in the targeting list
		int Psize = perlst.size(); // targeting period list
		if( Psize == 0 ) return;	// empty output list if targeting perlst is empty
		outlist.resize( Psize );	// output size same as perlst otherwise
		if( strVtmp.size() > 0 ) {
			for(int iper=0; iper<Psize; iper++) {
				int iol;
				for(iol=0; iol<strVtmp.size(); iol++) {
					if( outperlst[iol] == perlst[iper] ) break;
				}
				if( iol == strVtmp.size() ) continue;
				outlist.at(iper) = strVtmp.at(iol);
			}
			outperlst.clear();
		}
	}

	// check parameters 
	inline void CheckSearchArea() const {
		if( clon==NaN || clat==NaN || Rs==NaN )
			throw ErrorFS::BadParam(FuncName, "invalid clon || clat || Rs");
	}
	inline void CheckEInfo() const { CheckEInfo(this->einfo); }
	inline void CheckEInfo(const EpicInfo& einfoin) const {
		if( einfoin.lon==NaN || einfoin.lat==NaN || einfoin.t0==NaN )
			throw ErrorFS::BadParam(FuncName, "invalid einfo.lon || einfo.lat || einfo.t0");
	}

	inline void AziFactor( const AziData& dat_l, const AziData& dat_m, const AziData& dat_h, float& azifactor ) {
		float azi_l = dat_l.azi, azi_m = dat_m.azi, azi_h = dat_h.azi;
		if( azi_m == azi_l ) { azifactor = 0.; return; }
		if( azi_m == azi_h ) { azifactor = 1.; return; }
		if( azi_l > azi_h ) {
			azi_h += 360.;
			if( azi_m < azi_l ) azi_m += 360.;
		}
		if( azi_l>azi_m || azi_m>azi_h )
			throw std::runtime_error( std::to_string(azi_l)+" - "+std::to_string(azi_m)+" - "+std::to_string(azi_h) );
		azifactor = (dat_m.azi - dat_l.azi) / (dat_h.azi - dat_l.azi);
	}

	// get to-be-used data flag
	bool RFlag() {	return (datatype==B || datatype==R); }
	bool LFlag() {	return (datatype==B || datatype==L); }

	/* handle and normalize weightings of R&L waves */
	inline void NormalizeWeights( Dtype& datatype, float& wR, float& wL) {
		if( datatype == Undefined ) datatype = B;
			//throw ErrorFS::BadParam(FuncName, "Undefined datatype");
		if( datatype == R ) {
			wR = 1.; wL = 0.;
		} else if( datatype == L ) {
			wR = 0.; wL = 1.;
		} else {
			if( wR<=0. || wL<=0. )
				throw ErrorFS::BadParam(FuncName, "invalid weightR | weightL");
			float factor = 2. / (wR + wL);
			wR *= factor;
			wL *= factor;
		}
	}

	// accept criterion for simulated annealing
	bool Accept(float E, float Enew, double T) {
		/*
			unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
			std::default_random_engine generator (timeseed);
			std::uniform_real_distribution<float> distribution(0., 1.);
			auto rand = std::bind ( distribution, generator );
			*/
		bool accept;
		if(Enew<E) {
			accept = true;
		} else if(randO[omp_get_thread_num()].Uniform()<exp((E-Enew)/T)) {
			accept = true;
		} else {
			accept = false;
		}
		//std::cerr<<"E="<<E<<" Enew="<<Enew<<"  accept="<<accept<<" "<<ftmp<<" "<<exp((E-Enew)/T)<<std::endl;
		return accept;
	}

	inline float Neighbour_Reflect( float valold, float hlen, float lb, float ub ) {
		float range = ub - lb;
		float shift = randO[omp_get_thread_num()].Normal() * hlen;
		if( shift > range ) shift = range;
		else if( shift < -range ) shift = -range;
		float valnew = valold + shift;
		if( valnew >= ub ) { valnew = 2.*ub-valnew; }
		else if( valnew < lb ) { valnew = 2.*lb-valnew; }
		return valnew;
	}

	// perturb model parameters
	EpicInfo Neighbour( const EpicInfo& einfo ) {

		EpicInfo einfonew;// = einfo;

		float ht = Rt * 0.1;
		float hlon = Rlon * 0.1, hlat = Rlat * 0.1;

		einfonew.lon = Neighbour_Reflect(einfo.lon, hlon, clon-Rlon, clon+Rlon);
		einfonew.lat = Neighbour_Reflect(einfo.lat, hlat, clat-Rlat, clat+Rlat);
		einfonew.t0  = Neighbour_Reflect(einfo.t0, ht, ct0-Rt, ct0+Rt);

		return einfonew;
	}


	/*
		void PerturbModel( const FocalInfo<ftype>& finfoin, const EpicInfo& einfoin,
		FocalInfo<ftype>& finfonew, EpicInfo& einfonew, 
		const FocalInfo<ftype>& finfoc, const EpicInfo& einfoc, 
		float Rlon, float Rlat, float Rtim, 
		ftype Rstk, ftype Rdip, ftype Rrak, ftype Rdep) {
		float sfactor = 0.1; // step length as percentage of the range

		finfonew.strike = Neighbour_Reflect(finfoin.strike, Rstk*sfactor, finfoc.strike-Rstk, finfoc.strike+Rstk);
		while( finfonew.strike >= 360. ) finfonew.strike -= 360.;
		while( finfonew.strike < 0. ) finfonew.strike += 360.;

		float lb = finfoc.dip-Rdip, ub = finfoc.dip+Rdip;
		if( lb < 0. ) lb = 0.;
		if( ub > 90. ) ub = 90.;
		finfonew.dip = Neighbour_Reflect(finfoin.dip, Rdip*sfactor, lb, ub);

		finfonew.rake = Neighbour_Reflect(finfoin.rake, Rrak*sfactor, finfoc.rake-Rrak, finfoc.rake+Rrak);
		while( finfonew.rake >= 180. ) finfonew.rake -= 360.;
		while( finfonew.rake < -180. ) finfonew.rake += 360.;

		lb = finfoc.depth-Rdep; ub = finfoc.depth+Rdep;
		if( lb < 0. ) lb = 0.;
		finfonew.depth = Neighbour_Reflect(finfoin.depth, Rdep*sfactor, lb, ub);

		einfonew.lon = Neighbour_Reflect(einfoin.lon, Rlon*sfactor, einfoc.lon-Rlon, einfoc.lon+Rlon);

		einfonew.lat = Neighbour_Reflect(einfoin.lat, Rlat*sfactor, einfoc.lat-Rlat, einfoc.lat+Rlat);

		einfonew.t0 = Neighbour_Reflect(einfoin.t0, Rtim*sfactor, einfoc.t0-Rtim, einfoc.t0+Rtim);

		}
		*/


	// compute azimuth and distance for each station based on the input epicenter location
	void UpdateAziDis( const EpicInfo& einfoin, std::vector< std::vector<StaData> >& datain ) {
		float srclon = einfoin.lon, srclat = einfoin.lat;

		for( auto& dataV : datain ) {
			for( auto& sdtmp : dataV ) {
				try {
					Path<double> pathcur(srclon, srclat, sdtmp.lon, sdtmp.lat);
					sdtmp.dist = pathcur.Dist();
					sdtmp.azi = pathcur.Azi1();
				} catch( std::exception& e ) {
					throw ErrorFS::InternalException(FuncName, e.what());
				}
				sdtmp.valid = true;
				//if( azi<210 && azi>160 ) sdtmp.valid = false;
			}
			std::sort( dataV.begin(), dataV.end() );
		}
	}

	// update focal corrections for rayleigh or Love wave measurements
	// !!! Note that this only update corrections for each station by shifting the predictions
	// based on the new source location, the focal prediction itself is not updated !!!
	void UpdateFocalCorr( const EpicInfo& einfoin, std::vector< std::vector<StaData> >& datain, 
								 const std::vector< std::vector<AziData> >& Mpred ) {
		if( datain.size()==0 ) throw ErrorFS::EmptyData(FuncName);
		if( datain.size() != Mpred.size() ) throw ErrorFS::SizeMismatch(FuncName, "datain - Mpred");

		for(int iper=0; iper<datain.size(); iper++) {
			auto& adlist = Mpred.at(iper);
			for(int idata=0; idata<datain.at(iper).size(); idata++) {
				StaData& sdtmp = datain[iper][idata];
				if( ! sdtmp.valid ) continue;
				/* binary search for sdtmp.azi in per_azi_pred list */
				int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp ) - adlist.begin();
				//int ipredh = 1;
				//while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
				int ipredl = ipredh==0 ? adlist.size()-1:ipredh-1;
				if( ipredh == adlist.size() ) ipredh = 0;
				float azifactor;// = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
				try {
					AziFactor(adlist[ipredl], sdtmp, adlist[ipredh], azifactor);
				} catch( std::runtime_error& eazi ) {
					throw ErrorFS::BadAzi(FuncName, eazi.what());
				}
				sdtmp.misG = adlist[ipredl].misG + (adlist[ipredh].misG-adlist[ipredl].misG) * azifactor;
				sdtmp.misP = adlist[ipredl].misP + (adlist[ipredh].misP-adlist[ipredl].misP) * azifactor;
				//if(iper==3) std::cerr<<sdtmp.azi<<" "<<sdtmp.misG<<" "<<sdtmp.misP<<std::endl;
			}
		}

	}

	// for a single period, predict traveltimes from VelMaps and store into varG&varP
	void UpdateTPred_SP( const FileName& fGvel, const FileName& fPvel,
			const float clon, const float clat, const float ct0,
			std::vector<StaData>& Vmeasure, const float per, const bool c2pi ) const {
		// read in vel maps
		fGvel.CheckAccess();
		Map mapG(fGvel.c_str(), Point<float>(clon, clat));
		fPvel.CheckAccess();
		Map mapP(fPvel.c_str(), Point<float>(clon, clat));

		// period and wavelength
		float pero2 = per*0.5, lamda = per * Lfactor;
		for( auto& sdcur : Vmeasure ) {
			sdcur.varG = sdcur.varP = NaN;
			if( ! sdcur.valid ) continue;
			if( sdcur.dist < DISMIN || sdcur.dist > DISMAX ) continue;
			float percG, percP;
			float velG = mapG.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percG ).Data();
			float velP = mapP.PathAverage_Reci( Point<float>(sdcur.lon, sdcur.lat), lamda, percP ).Data();
			if( percG < Min_Perc || percP < Min_Perc ) continue;	// pathAverage succeed?
			sdcur.varG = sdcur.grT + ct0 - sdcur.dist/velG;			// Tmeasure + ct0 - gVpred
			const float pVpred = sdcur.dist/velP - ct0;				// phase T predicted from vel map
			if( c2pi ) {
				if( sdcur.misP == NaN )
					throw ErrorFS::BadPred(FuncName, "NaN misP");
				float Tpred = sdcur.misP + pVpred;
				while( sdcur.phT > Tpred+pero2 ) sdcur.phT -= per;
				while( sdcur.phT <= Tpred-pero2 ) sdcur.phT += per;
			}
			sdcur.varP = sdcur.phT - pVpred;
		}
	}


	// erase (from a vector) data that are larger than mean + 2 sigma
	bool ExcludeLarge( std::vector<float>& data, std::vector<float>& weight ) {
		if( data.size() != weight.size() ) return false;
		// compute mean 1
		float V1 = 0., mean1 = 0.;
		for(int i=0; i<data.size(); i++) {
			mean1 += data[i] * weight[i];
			V1 += weight[i];
		}
		mean1 /= V1;
		// compute std1
		float V2 = 0., std1 = 0.;
		for(int i=0; i<data.size(); i++) {
			float ftmp = data[i]-mean1;
			std1 += ftmp * ftmp * weight[i];
			V2 += weight[i] * weight[i];
		}
		std1 = sqrt( std1 * V1 / (V1*V1-V2) );
		// exclude larger-than-2sigma data
		float ubound = mean1 + 2.0*std1;// lbound = mean1 - 2.0*std1;
		int i=0;
		while( i<data.size() ) {
			if( data[i]>ubound ) {
				data.erase( data.begin() + i );
				weight.erase( weight.begin() + i );
			} else {
				i++;
			}
		}

		return true;
	}

	// Suppress a vector of data for 2pis. The median of the vector is used as reference
	void Suppress2PI( std::vector<float>& data, float per ) const {
		if( data.size() <= 1 ) return;
		float pero2 = per * 0.5;
		/*
		// suppress the misfit into the -per/2 ~ per/2 range
		for(int idat=0; idat<data.size(); idat++) {
			while( data[idat] > pero2 ) data[idat] -= per;
			while( data[idat] <= -pero2 ) data[idat] += per;
		}
		*/
		// find the median as reference
		/* The nth_element() function causes glibc() when compiled with gcc 4.8.2.,
		 * which is a bug in the current standard library.
		 * gcc 4.8.0 seems to be working fine */
		/* uncomment if 4.8.1/4.8.2 is not used */
		std::vector<float> datatmp(data); 
		int halfs = datatmp.size() / 2;
		std::nth_element(datatmp.begin(), datatmp.begin()+halfs-1, datatmp.end());
		float median = datatmp.at(halfs-1);
		/*/ use partial_sort instead if 4.8.1/4.8.2 is used
		  std::vector<float> datatmp(data);
		  int halfs = datatmp.size() / 2;
		  std::partial_sort(datatmp.begin(), datatmp.begin()+halfs, datatmp.end());
		  float median = datatmp.at(halfs-1); */
		/*/ find the average as reference
		  float median = 0.;
		  for(int idat=0; idat<data.size(); idat++) median += data[idat];
		  median /= data.size(); */
		// suppress again into the median-per/2 ~ median+per/2 range
		float lbound = median - pero2, ubound = median + pero2;
		for(int idat=0; idat<data.size(); idat++) {
			while( data[idat] > ubound ) data[idat] -= per;
			while( data[idat] <= lbound ) data[idat] += per;
		}

	}

	// mean and rms
	void MeanRMS( const std::vector<float>& data, const std::vector<float>& weight, float& mean, float& rms ) {
		if( data.size() != weight.size() ) throw ErrorFS::SizeMismatch(FuncName, "data - weight");
		// compute mean
		float V1 = 0.;
		mean = 0.; rms = 0.;
		for(int i=0; i<data.size(); i++) {
			mean += data[i] * weight[i];
			rms += data[i] * data[i] * weight[i];
			V1 += weight[i];
		}
		mean /= V1;
		rms = sqrt(rms/V1);
	}

	// mean and std
	bool Mean( const std::vector<float>& data, float& mean ) const {
		std::vector<float> weit( data.size(), 1. );
		return Mean( data, weit, mean );
	}
	bool Mean( const std::vector<float>& data, const std::vector<float>& weight, float& mean ) const {
		if( data.size() == 0 ) return false;
		float V1 = 0.; mean = 0.;
		for(int i=0; i<data.size(); i++) {
			mean += data[i] * weight[i];
			V1 += weight[i];
		}
		mean /= V1;
		return true;
	}
	bool MeanSTD( const std::vector<float>& data, float& mean, float& std ) const {
		std::vector<float> weit( data.size(), 1. );
		return MeanSTD( data, weit, mean, std );
	}
	bool MeanSTD( const std::vector<float>& data, const std::vector<float>& weight, float& mean, float& std ) const {
		if( data.size() == 0 ) return false;
		if( data.size() != weight.size() ) throw ErrorFS::SizeMismatch(FuncName, "data - weight");
		// compute mean
		float V1 = 0.;
		mean = 0.;
		for(int i=0; i<data.size(); i++) {
			mean += data[i] * weight[i];
			V1 += weight[i];
		}
		mean /= V1;
		// compute std
		float V2 = 0.;
		std = 0.;
		for(int i=0; i<data.size(); i++) {
			float ftmp = data[i]-mean;
			std += ftmp * ftmp * weight[i];
			V2 += weight[i] * weight[i];
		}
		float frdm = V1*V1-V2;
		if( frdm <= 0. ) {
			mean = NaN;
			return false;
		}
		std = sqrt( std * V1 / frdm );
		return true;
	}

	// mean and std of group, phase, and amplitude in an azimuth bin
	// results stored in an AziData variable
	void MeanSTD_Bin( const std::vector<StaData>::iterator adI_lbound,
							const std::vector<StaData>::iterator adI_ubound,
							const float binwidth, const float azi, const float per,
							AziData& result, const bool avgazi ) const {
			result.valid = false;
			if( adI_ubound - adI_lbound < MIN_BAZI_SIZE ) return;
			// collect valid data in the given range
			std::vector<float> dataG, dataP, dataA, aziV; //weitV;
			float alpha = -2.0/(binwidth*binwidth); // == -0.5 / (halfwidth*halfwidth)
			for(auto adI=adI_lbound; adI<adI_ubound; adI++) {
				// check completeness
				auto adcur = *adI;
				if( adcur.varG==NaN || adcur.varP==NaN || adcur.A==NaN ) continue;
				// weighting by azimuth
				float dataazi = adcur.azi, ftmp = azi-adcur.azi;
				//float weight = exp(alpha*ftmp*ftmp);
				// collect data for each type
				dataG.push_back( adcur.varG );
				dataP.push_back( adcur.varP );
				dataA.push_back( adcur.A );
				aziV.push_back( dataazi );
				//weitV.push_back( weight );
			}
			// correct phase for 2-pi
			Suppress2PI( dataP, per );
			// compute mean&variance in the given range
			// makes litte sense to weight data by azimuth ?
			//if( ! MeanSTD(dataG, weitV, result.misG, result.varG) ) return;
			if( ! MeanSTD(dataG, result.misG, result.varG) ) return;
			if( ! MeanSTD(dataP, result.misP, result.varP) ) return;
			if( ! MeanSTD(dataA, result.A, result.varA) ) return;
			if( avgazi ) {
				if( ! Mean(aziV, result.azi) ) return;
				if( result.azi >= 360. ) {
					result.azi -= 360.;
				} else if( result.azi < 0. ) {
					result.azi += 360.;
				}
			} else {
				result.azi = azi;
			}
			result.valid = true;
	}

	// exclude StaData point based on the input bin-avg data (discard if group/phase/amplitude is out of 3-sigma)
	bool ExcludeBad_Bin( std::vector<StaData>& datain, std::vector<AziData>& binavgV,
								const float binwidth, std::string& sDValid ) const {
		auto adI_lbound = datain.begin(), adI_ubound = datain.begin();
		const float exfactor = 3.0;
		// invalidate
		for( auto& binavg : binavgV ) {
			float cazi = binavg.azi;
			// data window (in datain) for the current azi range (from binavgV)
			AziData ad_lbound, ad_ubound;
			ad_lbound.azi = cazi-binwidth; ad_ubound.azi = cazi+binwidth;
			adI_lbound = std::upper_bound( adI_lbound, datain.end(), ad_lbound );
			adI_ubound = std::lower_bound( adI_ubound, datain.end(), ad_ubound );
			// check through the data window and invalidate any out-of-3sigma point
			float lbG = binavg.misG-exfactor*binavg.varG, ubG = binavg.misG+exfactor*binavg.varG;
			float lbP = binavg.misP-exfactor*binavg.varP, ubP = binavg.misP+exfactor*binavg.varP;
			float lbA = binavg.A-exfactor*binavg.varA, ubA = binavg.A+exfactor*binavg.varA;
			for( auto adI=adI_lbound; adI<adI_ubound; adI++ ) {
				auto& adcur = (*adI);
				if( ! adcur.valid ) continue;
				if( adcur.varG>lbG && adcur.varG<ubG &&
					 adcur.varP>lbP && adcur.varP<ubP &&
					 adcur.A>lbA && adcur.A<ubA ) continue;
				adcur.valid = false; 
//if(debug) std::cerr<<"ExcludeBad: "<<adcur.azi<<"   "<<adcur.misG<<" "<<lbG<<" "<<ubG<<"   "<<adcur.misP<<" "<<lbP<<" "<<ubP<<"   "<<adcur.A<<" "<<lbA<<" "<<ubA<<std::endl;
			}
		}
		// and erase
		int N = datain.size();
		for(auto adI=datain.begin(); adI!=datain.end(); ) {
			if( (*adI).valid ) {
				adI++;
			} else {
				adI = datain.erase(adI);
			}
		}
		sDValid.append( std::to_string(datain.size()) + "/" + std::to_string(N) + " " );
		if( datain.size() == 0 ) throw ErrorFS::EmptyData(FuncName);
	}

	/*
	// Exclude measurements that are out of the 2 sigma range and compute mean and variance
	bool DataAvg( std::vector<float>& data, std::vector<float>& weight, std::vector<float>& azi, float& mean2, float& var2 ) {
		mean2 = NaN;
		// compute mean1 and std1
		float mean1, std1;
		if( ! MeanSTD( data, weight, mean1, std1 ) ) return false;
			//throw ErrorFS::BadParam(FuncName, "unexpected frdm");
		// erase bad data
		float lbound = mean1 - 2.0*std1, ubound = mean1 + 2.0*std1;
		int i=0;
		while( i<data.size() ) {
			if( data[i]<lbound || data[i]>ubound ) {
				data.erase(data.begin()+i);
				weight.erase(weight.begin()+i);
				azi.erase(azi.begin()+i);
			} else {
				i++;
			}
		}
		if( data.size() < MIN_BAZI_SIZE ) return false;
		// compute mean 2
		if( ! MeanSTD( data, weight, mean2, var2 ) ) return false;
			//throw ErrorFS::BadParam(FuncName, "unexpected frdm");
		var2 = var2*var2;

		// enlarge variances if the dataset is too small (and thus unreliable)
		if( data.size() < 1.5 * MIN_BAZI_SIZE ) var2 *= 5.;

		return true;
	}
	*/

	// compare AziData/StaData by azimuth
	//inline static bool CompareAzi( const AziData& sta1, const AziData& sta2 ) { return (sta1.azi<sta2.azi); }

	/* bin-average all measurements and store the results into an AziData vector */

	// transfer the (Sta)datain into a new vector of (Sta)dataout with boundaries extended (periodically)
	void PeriodicExtension( std::vector<StaData>& datain, const float binwidth, std::vector<StaData>& dataout ) const {
		// not necessary! it is ensured that data are always sorted 
		//std::sort( datain.begin(), datain.end() );

		// clear the new vector (of Azidata) dataout
		dataout.clear();
		// prepend measurements with azi>360-binhwidth*2 to the beginning
		AziData sdbound; sdbound.azi = 360-binwidth;
		auto sdIbound = std::upper_bound( datain.begin(), datain.end(), sdbound );
		for(auto sdI=sdIbound; sdI<datain.end(); sdI++) {
			auto sdtmp = *sdI;
			sdtmp.azi -= 360.;
			dataout.push_back( sdtmp );
		}
		// copy datain in the middle
		size_t presize = dataout.size();
		dataout.resize( presize + datain.size() );
		std::copy( datain.begin(), datain.end(), dataout.begin() + presize );
		// append measurements with azi<binhwidth*2 to the end
		sdbound.azi = binwidth;
		sdIbound = std::lower_bound( datain.begin(), datain.end(), sdbound );
		for(auto sdI=datain.begin(); sdI<sdIbound; sdI++) {
			auto sdtmp = *sdI;
			sdtmp.azi += 360;
			dataout.push_back( sdtmp );
		}
	}

	// sub-BinAverage: takes the extended data vector and computes the mean and std in each bin
	void BinAvg( std::vector<StaData>& datain, const float binstep, const float binwidth,
					 const float per, std::vector<AziData>& dataout, const bool aziavg ) const {
		// compute average in each bin
		int nbin = (int)ceil(360 / binstep);
		dataout.clear(); dataout.resize(nbin);
		auto sdI_lbound = datain.begin(), sdI_ubound = datain.begin();
		for(float iazi=0; iazi<nbin; iazi++) {
			float azi = iazi * binstep;
			// search for dataV window boundaries
			AziData sd_lbound, sd_ubound;
			sd_lbound.azi = azi-binwidth; sd_ubound.azi = azi+binwidth;
			sdI_lbound = std::upper_bound( sdI_lbound, datain.end(), sd_lbound );
			sdI_ubound = std::lower_bound( sdI_ubound, datain.end(), sd_ubound );
			// compute mean&variance for group, phase, and amplitude in the range
			MeanSTD_Bin( sdI_lbound, sdI_ubound, binwidth, azi, per, dataout[iazi], aziavg );
		}
	}

	// main BinAverage  !!! Note that the input data will be rearranged (with invalid & incomplete points erased and then sorted by azimuth)!!!
	// first iteration
	void BinAverage1( const std::vector<StaData>& datain, const float per, const float binstep, const float binhwidth, 
							std::vector<AziData>& result, std::vector<StaData>& dataV, std::string& sDValid=sTrash ) const {
		// copy valid and complete points into a new vector (to be modified)
		std::vector<StaData> datao;
		for( const auto& sdcur : datain )
			if( sdcur.valid &&
             sdcur.varG!=NaN && sdcur.varP!=NaN && sdcur.A!=NaN ) 
				datao.push_back(sdcur);
		if( datao.size() == 0 ) throw ErrorFS::EmptyData(FuncName);

		// transfer the (Sta)data into a new vector of (Azi)data with boundaries extended (periodically)
		dataV.clear();
		const float binwidth = binhwidth * 2;
		PeriodicExtension( datao, binwidth, dataV);

		// bin average the data vector (use center azimuth for the azi of each bin)
		BinAvg( dataV, binstep, binwidth, per, result, false );
/*
if(per == 30) {
std::ofstream fout("fdata1.txt");
for( auto adcur : dataV ) fout<<adcur.azi<<"   "<<adcur.misG<<" "<<adcur.misP<<" "<<adcur.A<<"\n";
fout.close(); fout.clear();
fout.open("fbinavg1.txt");
for( auto adcur : result ) fout<<adcur.azi<<"   "<<adcur.misG<<" "<<adcur.varG<<" "<<adcur.misP<<" "<<adcur.varP<<" "<<adcur.A<<" "<<adcur.varA<<"\n";
}*/

		// exclude 'bad' data based on the bin-average from 1st iteration
		ExcludeBad_Bin( dataV, result, binwidth, sDValid );
	}
	// second half (v1), output bin-average results into the (AziData) result vector
	void BinAverage( const std::vector<StaData>& datain, const float per, const float binstep, 
						  const float binhwidth, std::vector<AziData>& result, std::string& sDValid=sTrash ) const {
		// run first half
		std::vector<StaData> dataV;
		BinAverage1( datain, per, binstep, binhwidth, result, dataV, sDValid );

		// output into result vector
		// use 'result' vector to store the bin-average result
		// bin average again (use average azimuth for each bin)
		float binwidth = binhwidth * 2.;
		BinAvg( dataV, binstep, binwidth, per, result, true );

		// sort (in case the ending bins are relocated by azimuth)
		std::sort( result.begin(), result.end() );
		for( auto& adcur : result ) {
			// square std to get variance
			adcur.varG = adcur.varG * adcur.varG;
			adcur.varP = adcur.varP * adcur.varP;
			adcur.varA = adcur.varA * adcur.varA;
			// limit 
			adcur.varG = std::max((float)varGmin, adcur.varG);
			adcur.varP = std::max((float)varPmin, adcur.varP);
			adcur.varA = std::max((float)varAmin*adcur.A, adcur.varA);
		}
	}
	// second half (v2), output updated input data into the (StaData) dataout vector
	void BinAverage_ExcludeBad( const std::vector<StaData>& datain, const float per, 
										 const float binstep, const float binhwidth, std::vector<StaData>& dataout ) const {
		// run first half
      std::vector<AziData> result;
      std::vector<StaData> dataV;
      BinAverage1( datain, per, binstep, binhwidth, result, dataV );
		// data window: effective azimuth range = [0., 360.)
		AziData ad_lbound, ad_ubound;
		ad_lbound.azi = 0.; ad_ubound.azi = 360.;
		auto sdI_lbound = std::upper_bound( dataV.begin(), dataV.end(), ad_lbound );
		auto sdI_ubound = std::lower_bound( sdI_lbound, dataV.end(), ad_ubound );
		// use 'dataout' vector to store updated input data with bad measurements discarded
		dataout.assign( sdI_lbound, sdI_ubound );
	}


	/* system operation: make directories for a given path */
	bool MKDir(const char *dirname) {
		//create dir if not exists
		//with read/write/search permissions for owner and group, and with read/search permissions for others if not already exists
		if( mkdir(dirname, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) == 0 ) return true;
		switch(errno) {
			case EEXIST:
				return false;
			default:
				perror("### Error: MKDir failed"); //failed. prompt to continue
				exit(0);
		}
	}
	void MKDirFor( const std::string& path ) {
		if( path.empty() ) return;
		std::stringstream spath(path);
		std::vector<std::string> dirs;
		for(std::string dir; std::getline(spath, dir, '/'); ) {
			dirs.push_back(dir);
		}
		if( dirs.size() < 2 ) return;
		for( int idir=0; idir<dirs.size()-1; idir++ ) {
			if( MKDir( dirs[idir].c_str() ) )
				std::cerr<<"Warning("<<FuncName<<"): Making directory "<<dirs[idir]<<std::endl;
		}
	}
};
std::string EQKSearcher::EQimpl::sTrash;


/* -------------------- con/destructors and operators -------------------- */
EQKSearcher::EQKSearcher() 
	: pimplES( new EQimpl() ) {}

EQKSearcher::EQKSearcher( const std::string fparamin, const bool MoveF ) 
	: pimplES( new EQimpl(fparamin) ) {
		LoadParams( pimplES->fparam, MoveF );
		CheckParams();
	}

EQKSearcher::EQKSearcher( const EQKSearcher& es2 ) 
	: pimplES( new EQimpl(*(es2.pimplES)) ) {}

EQKSearcher::EQKSearcher( EQKSearcher&& es2 ) 
	: pimplES( std::move(es2.pimplES) ) {}

	EQKSearcher& EQKSearcher::operator= ( const EQKSearcher& es2 ) {
		pimplES.reset( new EQimpl(*(es2.pimplES)) );
		return *this;
	}

EQKSearcher& EQKSearcher::operator= ( EQKSearcher&& es2 ) {
	pimplES = std::move(es2.pimplES);
	return *this;
}

EQKSearcher::~EQKSearcher() {}


/* -------------------- getters/setters -------------------- */
const FocalInfo<ftype>& EQKSearcher::FInfo() const { return pimplES->finfo; }

const EpicInfo& EQKSearcher::EInfo() const { return pimplES->einfo; }


/* --------------- extend the SearchFocal method to Prepare AziData first --------------- */
void EQKSearcher::SearchFocal( int nsearch, float alpha, float Tfactor ) {
	FillFocalSearcher();
	pimplES->finfo = FocalSearcher::SearchFocal( pimplES->finfo, pimplES->datatype, nsearch, alpha, Tfactor );
}

/* -------------------- param/data preparations -------------------- */
void EQKSearcher::LoadParams( const FileName& fname, const bool MoveF ) {
	fname.CheckAccess();
	std::ifstream fin(fname);
	if( ! fin ) throw ErrorFS::BadFile(FuncName, fname);
	int nparam = 0;
	for( std::string stmp; std::getline(fin, stmp); ) {
		int retval = Set( stmp.c_str(), MoveF );
		if( retval == -3 ) continue; // invalid input for this parameter
		else if( retval == -2 ) continue; // empty input
		else if( retval == -1 ) continue;// std::cerr<<"Warning(EQKSearcher::Load): Unknown parameter name: "<<stmp<<std::endl;
		else if( retval == 0 ) continue;// std::cerr<<"Warning(EQKSearcher::Load): Empty parameter field for "<<stmp<<std::endl;
		else nparam++;
	}
	fin.close();

	std::cout<<"### "<<nparam<<" succed loads from param file "<<fname<<". ###"<<std::endl;

	// check clon/clat validation and initialize einfo
	if( ! pimplES->Initialize() ) throw ErrorFS::BadParam(FuncName, "invalid Rs | clon | clat");

	/* synchronize output vectors with input-measurement vectors */
	pimplES->ArrangeOutlist( pimplES->outlist_RF, pimplES->perRtmp_fit, pimplES->perRlist );
	pimplES->ArrangeOutlist( pimplES->outlist_LF, pimplES->perLtmp_fit, pimplES->perLlist );
	pimplES->ArrangeOutlist( pimplES->outlist_RP, pimplES->perRtmp_pred, pimplES->perRlist );
	pimplES->ArrangeOutlist( pimplES->outlist_LP, pimplES->perLtmp_pred, pimplES->perLlist );

	// check output paths and make directorie(s) if necessary
	std::vector<FileName> Voutf { pimplES->outname_misF, pimplES->outname_misL, pimplES->outname_misAll, pimplES->outname_pos };
	Voutf.insert( Voutf.end(), pimplES->outlist_RF.begin(), pimplES->outlist_RF.end() );
	Voutf.insert( Voutf.end(), pimplES->outlist_LF.begin(), pimplES->outlist_LF.end() );
	Voutf.insert( Voutf.end(), pimplES->outlist_RP.begin(), pimplES->outlist_RP.end() );
	Voutf.insert( Voutf.end(), pimplES->outlist_LP.begin(), pimplES->outlist_LP.end() );
	for( const auto& outfname : Voutf )	pimplES->MKDirFor( outfname );
}

void EQKSearcher::CheckParams() {
	// check initial focal info
	const FocalInfo<ftype>& finfo = pimplES->finfo;
	if( finfo.strike==NaN|| finfo.dip==NaN||
			finfo.rake==NaN|| finfo.depth==NaN) {
		throw ErrorFS::BadParam(FuncName, "invalid/incomplete initial focal info");
	}

	// check model inputs
	if( access(pimplES->fReigname.c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, pimplES->fReigname);
	if( access(pimplES->fRphvname.c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, pimplES->fRphvname);
	if( access(pimplES->fLeigname.c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, pimplES->fLeigname);
	if( access(pimplES->fLphvname.c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, pimplES->fLphvname);

	// check weightings
	float& weightR_Loc = pimplES->weightR_Loc;
	float& weightL_Loc = pimplES->weightL_Loc;
	float& weightR_Foc = pimplES->weightR_Foc;
	float& weightL_Foc = pimplES->weightL_Foc;

	// check excluded data
	if( !useG && !useP )
		throw ErrorFS::BadParam(FuncName, "All data excluded! (noG and noP)");
	if( ! useG )
		std::cerr<<"Warning("<<FuncName<<"): GroupT data excluded!"<<std::endl;
	if( ! useP )
		std::cerr<<"Warning("<<FuncName<<"): PhaseT data excluded!"<<std::endl;
	if( ! useA )
		std::cerr<<"Warning("<<FuncName<<"): Amplitude data excluded!"<<std::endl;

	pimplES->NormalizeWeights( pimplES->datatype, weightR_Loc, weightL_Loc );
	pimplES->NormalizeWeights( pimplES->datatype, weightR_Foc, weightL_Foc );
}

int EQKSearcher::Set( const char *input, const bool MoveF ) {
	std::istringstream buff(input);
	std::string stmp;
	if( ! (buff>>stmp) ) return -2;
	bool succeed;
	if( stmp == "clon" ) { 
		succeed = buff >> pimplES->clon; 
		if( succeed && pimplES->clon<0.) pimplES->clon += 360.; 
	}
	else if( stmp == "clat" ) succeed = buff >> pimplES->clat;
	else if( stmp == "ct0" ) succeed = buff >> pimplES->ct0;
	else if( stmp == "Rs") succeed = buff >> pimplES->Rs;
	else if( stmp == "strike" ) succeed = buff >> pimplES->finfo.strike;
	else if( stmp == "dip" ) succeed = buff >> pimplES->finfo.dip;
	else if( stmp == "rake" ) succeed = buff >> pimplES->finfo.rake;
	else if( stmp == "depth" ) succeed = buff >> pimplES->finfo.depth;
	else if( stmp == "fRse" ) succeed = buff >> pimplES->fReigname;
	else if( stmp == "fRsp" ) succeed = buff >> pimplES->fRphvname;
	else if( stmp == "fLse" ) succeed = buff >> pimplES->fLeigname;
	else if( stmp == "fLsp" ) succeed = buff >> pimplES->fLphvname;
	else if( stmp == "weightR_Loc" ) succeed = buff >> pimplES->weightR_Loc;
	else if( stmp == "weightL_Loc" ) succeed = buff >> pimplES->weightL_Loc;
	else if( stmp == "weightR_Foc" ) succeed = buff >> pimplES->weightR_Foc;
	else if( stmp == "weightL_Foc" ) succeed = buff >> pimplES->weightL_Foc;
	else if( stmp == "noG" ) { succeed = true; useG = false; }
	else if( stmp == "noP" ) { succeed = true; useP = false; }
	else if( stmp == "noA" ) { succeed = true; useA = false; }
	else if( stmp == "dflag" ) {
		succeed = buff >> pimplES->datatype_name;
		if( succeed ) {
			switch( pimplES->datatype_name ) {
				case 'B': pimplES->datatype = B;
							 break;
				case 'R': pimplES->datatype = R;
							 break;
				case 'L': pimplES->datatype = L;
							 break;
				default: return -3;
			}
		}
	}
	else if( stmp == "fRm" ) {
		FileName stmp1, stmp2, stmp3;
		float per;
		succeed = buff >> stmp1 >> stmp2 >> stmp3 >> per;
		if( succeed ) {
			for(int iper=0; iper<pimplES->perRlist.size(); iper++) 
				if(pimplES->perRlist.at(iper) == per) return -3;
			pimplES->fRlist.push_back( std::vector<FileName>{stmp1, stmp2, stmp3} );
			pimplES->perRlist.push_back( per );
		}
	}
	else if( stmp == "fLm" ) {
		FileName stmp1, stmp2, stmp3;
		float per;
		succeed = buff >> stmp1 >> stmp2 >> stmp3 >> per;
		if( succeed ) {
			for(int iper=0; iper<pimplES->perLlist.size(); iper++) 
				if(pimplES->perLlist.at(iper) == per) return -3;
			pimplES->fLlist.push_back( std::vector<FileName>{stmp1, stmp2, stmp3} );
			pimplES->perLlist.push_back( per );
		}
	}
	else if( stmp == "fmisL" ) {
		FileName& outname = pimplES->outname_misL;
		succeed = buff >> outname;
		if( succeed && MoveF && access(outname.c_str(), F_OK) == 0 ) {
			FileName oldname = outname + "_old";
			WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
			rename(outname.c_str(), oldname.c_str());
		}
	}
	else if( stmp == "fmisF" ) {
		FileName& outname = pimplES->outname_misF;
		succeed = buff >> outname;
		if( succeed && MoveF && access(outname.c_str(), F_OK) == 0 ) {
			FileName oldname = outname + "_old";
			WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
			rename(outname.c_str(), oldname.c_str());
		}
	}
	else if( stmp == "fmisAll" ) {
		FileName& outname = pimplES->outname_misAll;
		succeed = buff >> outname;
		if( succeed && MoveF && access(outname.c_str(), F_OK) == 0 ) {
			FileName oldname = outname + "_old";
			WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
			rename(outname.c_str(), oldname.c_str());
		}
	}
	else if( stmp == "fpos" ) {
		FileName& outname = pimplES->outname_pos;
		succeed = buff >> outname;
		if( succeed && MoveF && access(outname.c_str(), F_OK) == 0 ) {
			FileName oldname = outname + "_old";
			WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
			rename(outname.c_str(), oldname.c_str());
		}
	}
	else if( stmp == "ffitR" ) {
		FileName outname;
		float per;
		succeed = buff >> outname >> per;
		if( succeed ) {
			if( MoveF && access(outname.c_str(), F_OK) == 0 ) {
				FileName oldname = outname + "_old";
				WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
				rename(outname.c_str(), oldname.c_str());
			}
			pimplES->outlist_RF.push_back(outname);
			pimplES->perRtmp_fit.push_back(per);
		}
	}
	else if( stmp == "ffitL" ) {
		FileName outname;
		float per;
		succeed = buff >> outname >> per;
		if( succeed ) {
			if( MoveF && access(outname.c_str(), F_OK) == 0 ) {
				FileName oldname = outname + "_old";
				WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
				rename(outname.c_str(), oldname.c_str());
			}
			pimplES->outlist_LF.push_back(outname);
			pimplES->perLtmp_fit.push_back(per);
		}
	}
	else if( stmp == "fpredR" ) {
		FileName outname;
		float per;
		succeed = buff >> outname >> per;
		if( succeed ) {
			/*
			if( MoveF && access(outname.c_str(), F_OK) == 0 ) {
				FileName oldname = outname + "_old";
				WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
				rename(outname.c_str(), oldname.c_str());
			} */
			pimplES->outlist_RP.push_back(outname);
			pimplES->perRtmp_pred.push_back(per);
		}
	}
	else if( stmp == "fpredL" ) {
		FileName outname;
		float per;
		succeed = buff >> outname >> per;
		if( succeed ) {
			/*
			if( MoveF && access(outname.c_str(), F_OK) == 0 ) {
				FileName oldname = outname + "_old";
				WarningFS::MoveExistFile(FuncName, outname+" -> "+oldname);
				rename(outname.c_str(), oldname.c_str());
			} */
			pimplES->outlist_LP.push_back(outname);
			pimplES->perLtmp_pred.push_back(per);
		}
	}
	else return -1;
	if( succeed ) return 1;
	return 0;
}

void EQKSearcher::LoadData() {
	//int nfail = 0;

	auto& dataR = pimplES->per_sta_data_R;
	dataR.clear(); dataR.resize( pimplES->fRlist.size() );
	for(int ifile=0; ifile<dataR.size(); ifile++) {
		// check data file
		std::ifstream fin(pimplES->fRlist.at(ifile).at(0).c_str());
		if( ! fin ) throw ErrorFS::BadFile(FuncName, pimplES->fRlist.at(ifile).at(0));
		// check phase shift
		float ph_shift = 0.;
		if( pio4_R != 0 ) { // correct the input phase traveltime measurements for phase shift!
			float per = pimplES->perRlist.at(ifile);
			ph_shift = - pio4_R * 0.125 * per;
		}
		// read from file
		for(std::string line; std::getline(fin, line); ) {
			StaData sdcur(line.c_str(), ph_shift);
			if( ! sdcur.isComplete() ) continue;
			dataR.at(ifile).push_back( sdcur );
		}
		// compute azi&dis and sort by azimuth
		pimplES->UpdateAziDis( pimplES->einfo, dataR );
	}

	auto& dataL = pimplES->per_sta_data_L;
	dataL.clear(); dataL.resize( pimplES->fLlist.size() );
	for(int ifile=0; ifile<dataL.size(); ifile++) {
		// check data file
		std::ifstream fin(pimplES->fLlist.at(ifile).at(0).c_str());
		if( ! fin ) throw ErrorFS::BadFile(FuncName, pimplES->fLlist.at(ifile).at(0));
		// check phase shift
		float ph_shift = 0.;
		if( pio4_L != 0 ) { // correct the input phase traveltime measurements for phase shift!
			float per = pimplES->perLlist.at(ifile);
			ph_shift = - pio4_L * 0.125 * per;
		}
		// read from file
		for(std::string line; std::getline(fin, line); ) {
			StaData sdcur(line.c_str(), ph_shift);
			if( ! sdcur.isComplete() ) continue;
			dataL.at(ifile).push_back( sdcur );
		}
		// compute azi&dis and sort by azimuth
		pimplES->UpdateAziDis( pimplES->einfo, dataL );
	}

	//   if( nfail > 0 ) {
	//      std::cerr<<"Warning(EQKSearcher::LoadData): failed to load "<<nfail<<" of the data files!"<<std::endl;
	//      return false;
	//   }
	std::cout<<"### "<<pimplES->fRlist.size() + pimplES->fLlist.size()<<" data file(s) loaded. ###"<<std::endl;
}


/* -------------------- data updaters -------------------- */
/*
void EQKSearcher::UpdateAziDis() {
	// check params and data
	pimplES->CheckEInfo();
	//if( pimplES->einfo.lon == NaN || pimplES->einfo.lat == NaN ) 
	//   throw ErrorFS::BadParam(FuncName, "invalid pimplES->einfo.lon || pimplES->einfo.lat");
	if( pimplES->per_sta_data_R.size() == 0 && pimplES->per_sta_data_L.size() == 0 ) 
		throw ErrorFS::EmptyData(FuncName, "pimplES->per_sta_data_R && pimplES->per_sta_data_L");
	// compute azimuths and distances
	pimplES->UpdateAziDis( pimplES->einfo, pimplES->per_sta_data_R);
	pimplES->UpdateAziDis( pimplES->einfo, pimplES->per_sta_data_L);
	// sort each period by azimuth
	for( auto& dataV : pimplES->per_sta_data_R )
		std::sort( dataV.begin(), dataV.end(), pimplES->CompareAzi );
	for( auto& dataV : pimplES->per_sta_data_L )
		std::sort( dataV.begin(), dataV.end(), pimplES->CompareAzi );

	int iper = 3;
}
*/

void EQKSearcher::UpdateFocalPred() {
	if( pimplES->perRlist.size()==0 && pimplES->perLlist.size()==0 )
		throw ErrorFS::EmptyData(FuncName, "pimplES->perRlist && pimplES->perLlist");

	// check Rayleigh source input
	if( pimplES->perRlist.size() != 0 &&
			(pimplES->fReigname.empty() || pimplES->fRphvname.empty()) )
		throw ErrorFS::BadParam(FuncName, "empty pimplES->fReigname || pimplES->fRphvname");

	// check Love source input
	if( pimplES->perLlist.size() != 0 &&
			(pimplES->fLeigname.empty() || pimplES->fLphvname.empty()) )
		throw ErrorFS::BadParam(FuncName, "empty pimplES->fLeigname || pimplES->fLphvname");

	const FocalInfo<ftype>& finfo = pimplES->finfo;

	/* Check amplitude factors for R/L waves. Prepare amplitude AziData for Rescaling if Afactor(s) are undefined */
	//double AfactorR = AFactorR(), AfactorL = AFactorL();
	double AfactorR = NaN, AfactorL = NaN;
	std::vector< std::vector<AziData> > AziAmpR, AziAmpL;
	std::vector<PerDazi> perRlist, perLlist;
	if( AfactorR==NaN || AfactorL==NaN ) {
		// do not correct for 2-pi ( as no previous focal prediction should be assumed
		//									  and also only amplitude information is needed )
		UpdateTrvtPred( false );
		PrepareAziData( AziAmpR, perRlist, AziAmpL, perLlist );
	}

	/* ------ Corrections for Rayleigh wave ----- */
	if( pimplES->perRlist.size() > 0 ) {
		//std::vector<float> perRlst;
		//for(int i=0; i<pimplES->perRlist.size(); i++) perRlst.push_back(pimplES->perRlist.at(i));
		std::vector<float>& perRlst = pimplES->perRlist;

		// initialize/reset prediction matrix
		//std::vector< std::vector<AziData> > per_azi_pred;
		pimplES->per_azi_pred_R.clear();
		//pimplES->per_azi_pred_R.resize( perRlst.size() );

		pimplES->rpR.Predict( 'R', pimplES->fReigname, pimplES->fRphvname, finfo.strike, finfo.dip,
				finfo.rake, finfo.depth, perRlst, pimplES->per_azi_pred_R);

		if( AfactorR == NaN ) {
			ReScalePred( AziAmpR, pimplES->per_azi_pred_R, AfactorR );
			AfactorR = 1.;
		}
		for(int iper=0; iper<pimplES->per_sta_data_R.size(); iper++) {
			std::vector< AziData >& adlist = pimplES->per_azi_pred_R.at(iper);
			for( auto& sdtmp : pimplES->per_sta_data_R.at(iper) ) {
				if( ! sdtmp.valid ) continue;
				int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp ) -
								 adlist.begin();
				//int ipredh = 1;
				//while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
				int ipredl = ipredh-1;
				if( ipredl == -1 ) ipredl = adlist.size() - 1;
				if( ipredh == adlist.size() ) ipredh = 0;
				float azifactor;// = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
				try {
					pimplES->AziFactor(adlist[ipredl], sdtmp, adlist[ipredh], azifactor);
				} catch( std::runtime_error& eazi ) {
					throw ErrorFS::BadAzi(FuncName, eazi.what());
				}
				sdtmp.misG = adlist[ipredl].misG + (adlist[ipredh].misG-adlist[ipredl].misG) * azifactor;
				sdtmp.misP = adlist[ipredl].misP + (adlist[ipredh].misP-adlist[ipredl].misP) * azifactor;
				sdtmp.Apred = adlist[ipredl].A + (adlist[ipredh].A-adlist[ipredl].A) * azifactor;
				sdtmp.Apred *= AfactorR;
				//if(iper==3) std::cerr<<sdtmp.azi<<" "<<sdtmp.misG<<" "<<sdtmp.misP<<std::endl;
			}
		}

	}

	/* ------ Corrections for Love wave ----- */
	if( pimplES->perLlist.size() > 0 ) {
		//std::vector<float> perLlst;
		//for(int i=0; i<pimplES->perLlist.size(); i++) perLlst.push_back(pimplES->perLlist.at(i).per);
		std::vector<float>& perLlst = pimplES->perLlist;

		// initialize prediction matrix
		//std::vector< std::vector<AziData> > per_azi_pred;
		pimplES->per_azi_pred_L.clear();
		//pimplES->per_azi_pred_L.resize( perLlst.size() );

		/* module RadPatternL is not done yet !!! */
		//      bool succeed = RadPatternL( pimplES->fLeigname, pimplES->fLphvname, pimplES->finfo, perLlst, pimplES->per_azi_pred_L );
		pimplES->rpL.Predict( 'L', pimplES->fLeigname, pimplES->fLphvname, finfo.strike, finfo.dip,
				finfo.rake, finfo.depth, perLlst, pimplES->per_azi_pred_L );

		if( AfactorL == NaN ) {
			ReScalePred( AziAmpL, pimplES->per_azi_pred_L, AfactorL );
			AfactorL = 1.;
		}
		for(int iper=0; iper<pimplES->per_sta_data_L.size(); iper++) {
			std::vector< AziData >& adlist = pimplES->per_azi_pred_L.at(iper);
			for( auto& sdtmp : pimplES->per_sta_data_L.at(iper) ) {
				if( ! sdtmp.valid ) continue;
				int ipredh = std::lower_bound( adlist.begin(), adlist.end(), sdtmp )
					- adlist.begin();
				//int ipredh = 1;
				//while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
				int ipredl = ipredh-1;
				if( ipredl == -1 ) ipredl = adlist.size() - 1;
				if( ipredh == adlist.size() ) ipredh = 0;
				float azifactor;// = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
				try {
					pimplES->AziFactor(adlist[ipredl], sdtmp, adlist[ipredh], azifactor);
				} catch( std::runtime_error& eazi ) {
					throw ErrorFS::BadAzi(FuncName, eazi.what());
				}
				sdtmp.misG = adlist[ipredl].misG + (adlist[ipredh].misG-adlist[ipredl].misG) * azifactor;
				sdtmp.misP = adlist[ipredl].misP + (adlist[ipredh].misP-adlist[ipredl].misP) * azifactor;
				sdtmp.Apred = adlist[ipredl].A + (adlist[ipredh].A-adlist[ipredl].A) * azifactor;
				sdtmp.Apred *= AfactorL;
			}
		}

	}

}



/*	-------------------- predict travel times based on VelMaps -------------------- */
/* store Tmeasure-Vpred into varG&varP, phase measurements are corrected for 2-PI if Fpred is valid */
/* this function modifies internal data, use caution when multi-threading!!! */
void EQKSearcher::UpdateTrvtPred( const bool c2pi ) { 
	UpdateTrvtPred( pimplES->einfo, pimplES->per_sta_data_R, pimplES->per_sta_data_L, c2pi ); 
}
void EQKSearcher::UpdateTrvtPred( const EpicInfo& einfo, std::vector< std::vector<StaData> >& dataR, 
											 std::vector< std::vector<StaData> >& dataL, const bool c2pi ) {
	// predict travel times based on VelMaps and store into varG&varP
	pimplES->CheckEInfo(einfo);
	// check input measurements
	//if( pimplES->datatype == Undefined ) throw ErrorFS::BadParam(FuncName, "Undefined datatype");
	int Rsize = dataR.size(), Lsize = dataL.size();
	//if( pimplES->perRlist.size() != Rsize || pimplES->perLlist.size() != Lsize ) 
	//	throw ErrorFS::SizeMismatch(FuncName, "perRlist - Rsize || perLlist - Lsize");

	float srclon = einfo.lon, srclat = einfo.lat, srct0 = einfo.t0;

	// compute traveltime for Rayleigh wave
	if( Rsize>0 ) {// && RFlag ) {
		pimplES->UpdateAziDis( einfo, dataR );
		for(int iper=0; iper<Rsize; iper++)
			pimplES->UpdateTPred_SP( pimplES->fRlist.at(iper).at(1), pimplES->fRlist.at(iper).at(2),
											 srclon, srclat, srct0, dataR[iper], pimplES->perRlist.at(iper), c2pi );
	}

	// compute traveltime for Love wave
	if( Lsize>0 ) {// && LFlag ) {
		pimplES->UpdateAziDis( einfo, dataL );
		for(int iper=0; iper<Lsize; iper++)
			pimplES->UpdateTPred_SP( pimplES->fLlist.at(iper).at(1), pimplES->fLlist.at(iper).at(2),
											 srclon, srclat, srct0, dataL[iper], pimplES->perLlist.at(iper), c2pi );
	}

}


/* -------------------- data output -------------------- */
void EQKSearcher::Output( bool excludeBad, const EQKSearcher::OutType otype ) {
	// check data existence
	int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
	if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
	// check epicenter location
	pimplES->CheckEInfo();
	// check size of VelMap name vectors
	if( pimplES->fRlist.size()!=Rsize || pimplES->fLlist.size()!=Lsize )
		throw ErrorFS::SizeMismatch(FuncName, "fRlist - Rsize || fLlist - Lsize");

	/* Update Focal corrections (and predictions) based on the current finfo.
	 * For both R and L waves. */
	UpdateFocalPred();
	/* predict traveltime from VelMaps and store Tmeasure - Vpred into varG&varP
		phase measurements are corrected for 2-pi based on Fpred & Vpred */
	UpdateTrvtPred( true );

	bool outisfit = (otype == EQKSearcher::FIT);

	// output misfit ( measured + t0 - predicted ) and focal_corrections for Rayleigh
	for(int iper=0; iper<Rsize; iper++) {
		float per = pimplES->perRlist.at(iper);
		// run bin-average to eliminate bad data
		std::vector<StaData> T_pred_diff;
		if( excludeBad ) {
			pimplES->BinAverage_ExcludeBad( pimplES->per_sta_data_R.at(iper),
													  per, BINSTEP, BINHWIDTH, T_pred_diff );
		} else {
			T_pred_diff = pimplES->per_sta_data_R.at(iper);
		}
		// output
		std::string outname;
		std::ofstream fout;
		if( outisfit ) {
			outname = pimplES->outlist_RF.at(iper);
			if ( outname.empty() ) continue;
			fout.open( outname, std::ofstream::app );
			fout<<"# [ epic = "<<EInfo()<<"  focal = "<<pimplES->finfo<<" ]\n";
		} else {
			outname = pimplES->outlist_RP.at(iper);
			if ( outname.empty() ) continue;
			fout.open( outname );
			fout<<EInfo()<<"\n";
		}
		for( const auto& res_T : T_pred_diff ) {
			if( ! res_T.isGood() ) continue;
			if( outisfit ) {
				res_T.streamTo( fout, 1 );
//				fout<<res_T.azi<<"   "<<res_T.misG<<" "<<res_T.varG<<"   "
//					 <<res_T.misP<<" "<<res_T.varP<<"   "<<res_T.A<<" "<<res_T.Apred<<"\n";
			} else {
				res_T.streamTo( fout, 2 );
//				fout<<res_T.lon<<" "<<res_T.lat<<"   "<<res_T.grT<<" "<<res_T.misG<<"   "
//					 <<res_T.phT<<" "<<res_T.misP<<"   "<<res_T.Apred<<" "<<res_T.A<<"   "
//					 <<res_T.dist<<"   "<<res_T.azi<<"\n";
			}
		}
		if( outisfit ) fout<<"\n\n";
	}

	// output misfit ( measured + t0 - predicted ) and focal_corrections for Love
	for(int iper=0; iper<Lsize; iper++) {
		float per = pimplES->perLlist.at(iper);
		// run bin-average to eliminate bad data
		std::vector<StaData> T_pred_diff;
		if( excludeBad ) {
			pimplES->BinAverage_ExcludeBad( pimplES->per_sta_data_L.at(iper),
													  per, BINSTEP, BINHWIDTH, T_pred_diff );
		} else {
			T_pred_diff = pimplES->per_sta_data_L.at(iper);
		}
		// output
		std::string outname;
		std::ofstream fout;
		if( outisfit ) {
			outname = pimplES->outlist_LF.at(iper);
			if( outname.empty() ) continue;
			fout.open( outname, std::ofstream::app );
			fout<<"# [ epic = "<<EInfo()<<"  focal = "<<pimplES->finfo<<" ]\n";
		} else {
			outname = pimplES->outlist_LP.at(iper);
			if( outname.empty() ) continue;
			fout.open( outname );
			fout<<EInfo()<<"\n";
		}
		for( const auto& res_T : T_pred_diff ) {
			if( ! res_T.isGood() ) continue;
			if( outisfit ) {
				res_T.streamTo( fout, 1 );
			} else {
				res_T.streamTo( fout, 2 );
			}
		}
		if( outisfit ) fout<<"\n\n";
	}

}


/* --- compute and output misfits, separately, for group, phase, and amplitudes --- */
bool EQKSearcher::ReadResults( const FileName& fname, std::vector<AziData>& FitResults ) {
	if( fname.empty() ) return false;
	if( access(fname.c_str(), R_OK) == -1 ) return false;
	
	std::ifstream fin(fname);
	for(std::string line; std::getline(fin, line); ) {
		if( line.c_str()[0] == '#' ) {
			FitResults.clear();
		} else {
			AziData azires;
			/* Note that misG is used to store the group delay from measurements while varG
				is used for group delay from prediction. Same holds for phase and amplitude */
			if( sscanf(line.c_str(), "%f %f %f %f %f %f %f", &azires.azi, &azires.misG, &azires.varG, 
							&azires.misP, &azires.varP, &azires.A, &azires.varA ) == 7 )
				FitResults.push_back( azires );
		}
	}
}

void EQKSearcher::ComputeMisfits( const std::vector<AziData>& FitResults, AziData& results ) {
	// push misfits into vectors
	std::vector<float> misfitsG, misfitsP, misfitsA;
	for( auto fitres : FitResults ) {
		misfitsG.push_back( fabs(fitres.misG-fitres.varG) );
		misfitsP.push_back( fabs(fitres.misP-fitres.varP) );
		misfitsA.push_back( fabs(fitres.A-fitres.varA) );
	}
	// exclude bad measurements
	std::vector<float> weitG( misfitsG.size(), 1.0 ), weitP( misfitsP.size(), 1.0 ), weitA( misfitsA.size(), 1.0 );
	pimplES->ExcludeLarge( misfitsG, weitG ); 
	pimplES->ExcludeLarge( misfitsP, weitP ); 
	pimplES->ExcludeLarge( misfitsA, weitA ); 
	// compute mean and rms
	pimplES->MeanRMS( misfitsG, weitG, results.misG, results.varG );
	pimplES->MeanRMS( misfitsP, weitP, results.misP, results.varP );
	pimplES->MeanRMS( misfitsA, weitA, results.A, results.varA );
}

void EQKSearcher::ComputeMisfitsAll() {
	// check data existence
	int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
	if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");

	// output file
	const FileName& outname = pimplES->outname_misAll;
	if( outname.empty() ) return;
	std::ofstream fout( outname );

	// read from the result file at each period. Rayleigh
	for(int iper=0; iper<Rsize; iper++) {
		// read the latest fitting results
		std::vector<AziData> FitResults;
		const FileName& fresult = pimplES->outlist_RF.at(iper);
		if( fresult.empty() ) continue;
		if( ! ReadResults( fresult, FitResults ) ) {
			std::cerr<<"Warning(ComputeMisfitsAll): cannot read from file "<<fresult<<std::endl;
			continue;
		}
		// compute the stds for group, phase, and amplitude
		AziData misfits;
		ComputeMisfits( FitResults, misfits );
		fout<<"R "<<pimplES->perRlist.at(iper)<<"   "<<misfits.misG<<" "<<misfits.varG
			 <<"   "<<misfits.misP<<" "<<misfits.varP<<"   "<<misfits.A<<" "<<misfits.varA<<std::endl;
	}
	// read from the result file at each period. Love
	for(int iper=0; iper<Lsize; iper++) {
		// read the latest fitting results
		std::vector<AziData> FitResults;
		const FileName& fresult = pimplES->outlist_LF.at(iper);
		if( fresult.empty() ) continue;
		if( ! ReadResults( fresult, FitResults ) ) {
			std::cerr<<"Warning(ComputeMisfitsAll): cannot read from file "<<fresult<<std::endl;
			continue;
		}
		// compute the stds for group, phase, and amplitude
		AziData misfits;
		ComputeMisfits( FitResults, misfits );
		fout<<"L "<<pimplES->perLlist.at(iper)<<"   "<<misfits.misG<<" "<<misfits.varG
			 <<"   "<<misfits.misP<<" "<<misfits.varP<<"   "<<misfits.A<<" "<<misfits.varA<<std::endl;
	}
}


/* -------------------- compute misfit square at a given location -------------------- */
std::string EQKSearcher::EnergyL( const EpicInfo& einfo, float& E ) {
	int N;
	float chiS, wSum;
	std::string sDValid;
	chiSquareL(einfo, chiS, wSum, N, sDValid);
	if( N <= 0 ) 
		throw ErrorFS::InsufData(FuncName, "N="+std::to_string(N));
	//E = chiS / wSum;
	E = chiS / (N-4.); // reduced chi-square
	//std::cout<<"EnergyL results for ("<<einfo<<"): "<<chiS<<" "<<N<<" "<<E<<std::endl;
	return sDValid;
}
void EQKSearcher::chiSquareL( const EpicInfo& einfo, float& chiS, float& wSum, int& N, std::string& sDValid ) {
	// check input params
	pimplES->CheckEInfo(einfo);
	int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
	if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
	if( pimplES->datatype == Undefined ) throw ErrorFS::BadParam(FuncName, "Undefined datatype");

	float srclon = einfo.lon, srclat = einfo.lat, srct0 = einfo.t0;

	// copy data matrices for modification!!
	std::vector< std::vector<StaData> > dataR, dataL;
	if( pimplES->RFlag() ) dataR = pimplES->per_sta_data_R;
	if( pimplES->LFlag() ) dataL = pimplES->per_sta_data_L;

	// predict traveltime from VelMaps and store Tmeasure - Vpred into varG&varP
	//	phase measurements are corrected for 2-pi based on Fpred & Vpred
	UpdateTrvtPred( einfo, dataR, dataL, true );

	chiS = 0.; wSum = 0.; N = 0;
	sDValid.clear();
	// compute misfit (measured + t0 - predicted - focal_correction ) for Rayleigh maps
	if( Rsize>0 && pimplES->RFlag() ) {
		//einfo = EpicInfo(245.481, 41.0386, -1.93645);
		float weightR = pimplES->weightR_Loc;
		// copy data (to be modified)
		pimplES->UpdateFocalCorr( einfo, dataR, pimplES->per_azi_pred_R );
		for(int iper=0; iper<Rsize; iper++) {
			float per = pimplES->perRlist.at(iper);
			auto& dataV = dataR.at(iper);
			// substract misG/misP from varG/varP for misfits
			for( auto& sd : dataV )
				if( sd.isGood() ) {
					sd.varG -= sd.misG; sd.varP -= sd.misP;
				} else {
					sd.valid = false;
				}
			// compute azimuthal average
			std::vector<AziData> dataAzi;
			pimplES->BinAverage( dataV, per, BINSTEP, BINHWIDTH, dataAzi, sDValid );
			// compute average misfit square (excluding bad data)
			std::vector<float> misGV, misPV;
			std::vector<float> weitG, weitP;
			for( const auto& ad : dataAzi ) {
				if( ! ad.isGood() ) continue;
				float ftmp = ad.misG;
				misGV.push_back( ftmp * ftmp );
				weitG.push_back( weightR / ad.varG );
				ftmp = ad.misP;
				misPV.push_back( ftmp * ftmp );
				weitP.push_back( weightR / ad.varP );
			}
			// check if there're enough misfits
			float minSize = MIN_AZI_PERC * float(dataAzi.size());
			if( misGV.size() < minSize || misPV.size() < minSize ) {
				WarningFS::Other(FuncName, "no enough data point for iper=" + 
						std::to_string(iper) + " and type=R" );
				continue;
			}
			/*
			// exclude bad azimuths when computing chi-squre
			for(int i=0; i<NEX; i++)
				if( ! pimplES->ExcludeLarge( misGV, weitG ) ) throw ErrorFS::SizeMismatch(FuncName, "misGV - weitG");
			for(int i=0; i<NEX; i++)
				if( ! pimplES->ExcludeLarge( misPV, weitP ) ) throw ErrorFS::SizeMismatch(FuncName, "misPV - weitP");
			*/
			//E += EG*0.2 + EP*0.8;// / dataR[iper].size() );
			if( useG ) {
				for(int idat=0; idat<misGV.size(); idat++) { chiS += misGV[idat]*weitG[idat]; wSum += weitG[idat]; }
				N += misGV.size();
			}
			if( useP ) {
				for(int idat=0; idat<misPV.size(); idat++) { chiS += misPV[idat]*weitP[idat]; wSum += weitP[idat]; }
				N += misPV.size();
			}
		} // for iper
	} // if R

	// compute misfit (measured + t0 - predicted - focal_correction) for Love maps
	if( Lsize>0 && pimplES->LFlag() ) {
		float weightL = pimplES->weightL_Loc;
		// copy data (to be modified)
		pimplES->UpdateFocalCorr( einfo, dataL, pimplES->per_azi_pred_L );
		for(int iper=0; iper<Lsize; iper++) {
			float per = pimplES->perLlist.at(iper);
			auto& dataV = dataL.at(iper);
			// substract misG/misP from varG/varP for misfits
			for( auto& sd : dataV )
				if( sd.isGood() ) {
					sd.varG -= sd.misG; sd.varP -= sd.misP;
				} else {
					sd.valid = false;
				}
			// compute azimuthal average
			std::vector<AziData> dataAzi;
			pimplES->BinAverage( dataV, per, BINSTEP, BINHWIDTH, dataAzi, sDValid );
			// compute average misfit square (excluding bad data)
			std::vector<float> misGV, misPV;
			std::vector<float> weitG, weitP;
			for( const auto& ad : dataAzi ) {
				if( ! ad.isGood() ) continue;
				float ftmp = ad.misG;
				misGV.push_back( ftmp * ftmp );
				weitG.push_back( weightL / ad.varG );
				ftmp = ad.misP;
				misPV.push_back( ftmp * ftmp );
				weitP.push_back( weightL / ad.varP );
			}
			// check if there're enough misfits
			float minSize = MIN_AZI_PERC * float(dataAzi.size());
			if( misGV.size() < minSize || misPV.size() < minSize ) {
				WarningFS::Other(FuncName, "no enough data point for iper=" + 
										std::to_string(iper) + " and type=L" );
				continue;
			}
			for(int i=0; i<NEX; i++) 
				if( ! pimplES->ExcludeLarge( misGV, weitG ) ) throw ErrorFS::SizeMismatch(FuncName, "misGV - weitG");
			for(int i=0; i<NEX; i++)
				if( ! pimplES->ExcludeLarge( misPV, weitP ) ) throw ErrorFS::SizeMismatch(FuncName, "misPV - weitP");
			//E += EG*0.2 + EP*0.8;// / dataR[iper].size() );
			if( useG ) {
				for(int idat=0; idat<misGV.size(); idat++) { chiS += misGV[idat]*weitG[idat]; wSum += weitG[idat]; }
				N += misGV.size();
			}
			if( useP ) {
				for(int idat=0; idat<misPV.size(); idat++) { chiS += misPV[idat]*weitP[idat]; wSum += weitP[idat]; }
				N += misPV.size();
			}
		} // for iper
	} // if L

	// normalize total energy
	//E = Esum / Wsum;
}


/* -------------------- average measurements by azimuth and store the results for FocalSearcher -------------------- */
void EQKSearcher::FillFocalSearcher() { 
	std::vector<PerDazi> perRlst, perLlst;
	std::vector< std::vector<AziData> > resultR, resultL;
	UpdateTrvtPred( false );
	PrepareAziData( resultR, perRlst, resultL, perLlst );

	FSreset( pimplES->outname_misF,
			pimplES->fReigname, pimplES->fRphvname,
			pimplES->fLeigname, pimplES->fLphvname,
			pimplES->weightR_Foc, pimplES->weightL_Foc,
			std::move(perRlst), std::move(perLlst),
			std::move(resultR), std::move(resultL) );
}

void EQKSearcher::PrepareAziData( std::vector< std::vector<AziData> >& resultR, std::vector<PerDazi>& perRlst,
											 std::vector< std::vector<AziData> >& resultL, std::vector<PerDazi>& perLlst ) const {
	PrepareAziData(pimplES->per_sta_data_R, pimplES->perRlist, pimplES->per_sta_data_L, pimplES->perLlist,
						resultR, perRlst, resultL, perLlst );
}
void EQKSearcher::PrepareAziData( const std::vector< std::vector<StaData> >& dataR, const std::vector<float>& perRlstin,
											 const std::vector< std::vector<StaData> >& dataL, const std::vector<float>& perLlstin,
											 std::vector< std::vector<AziData> >& resultR, std::vector<PerDazi>& perRlst,
											 std::vector< std::vector<AziData> >& resultL, std::vector<PerDazi>& perLlst ) const {
	// check input measurements
	const int Rsize = dataR.size(), Lsize = dataL.size();
	if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
	if( Rsize>0 && perRlstin.size()!=Rsize || Lsize>0 && perLlstin.size()!=Lsize ) 
		throw ErrorFS::SizeMismatch(FuncName, "perRlstin - Rsize || perLlstin - Lsize");

	// compute azi-misfit for Rayleigh wave
	resultR.resize(Rsize); perRlst.resize(Rsize);
	for( int iper=0; iper<Rsize; iper++ ) {
		float per = perRlstin.at(iper);
		pimplES->BinAverage( dataR.at(iper), per, BINSTEP, BINHWIDTH, resultR.at(iper) );
		perRlst.at(iper) = PerDazi( per, BINSTEP );
	}

	// compute azi-misfit for Love wave
	resultL.resize(Lsize); perLlst.resize(Lsize);
	for( int iper=0; iper<Lsize; iper++ ) {
		float per = perLlstin.at(iper);
		pimplES->BinAverage( dataL.at(iper), per, BINSTEP, BINHWIDTH, resultL.at(iper) );
		perLlst.at(iper) = PerDazi( per, BINSTEP );
	}

}


	/* -------------------- search for optimal epi location with a simulated annealing algorithm -------------------- */
	void EQKSearcher::SearchLocation( int nsearch, float alpha, float Tfactor ) {
		// check epic parameters
		pimplES->CheckSearchArea();
		pimplES->CheckEInfo();
		// check input measurements
		if( pimplES->datatype == Undefined ) throw ErrorFS::BadParam(FuncName, "Undefined datatype");
		int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
		if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
		if( pimplES->perRlist.size() != Rsize || pimplES->perLlist.size() != Lsize )
			throw ErrorFS::SizeMismatch(FuncName, "perRlist - Rsize || perLlist - Lsize");
		// check vel map accessibilities
		for(int iper=0; iper<Rsize; iper++) {
			pimplES->fRlist.at(iper).at(1).CheckAccess();
			pimplES->fRlist.at(iper).at(2).CheckAccess();
		}
		for(int iper=0; iper<Lsize; iper++) {
			pimplES->fLlist.at(iper).at(1).CheckAccess();
			pimplES->fLlist.at(iper).at(2).CheckAccess();
		}

		/* update focal predictions based on the current pimplES->finfo 
			for both the 'pred' and the 'data' vectors */
		UpdateFocalPred();
		// initialize parameters
		EpicInfo& einfo = pimplES->einfo;

		// simulated annealing
		float E;
		EnergyL(pimplES->einfo, E);
		float T = E * Tfactor;
		std::cout<<"### SearchLocation: Initial Misfit**2 for ("<<pimplES->einfo<<")&&("<<pimplES->finfo<<") = "<<E<<" T="<<T<<" ###"<<std::endl;
		EpicInfo einfobest = pimplES->einfo;
		float Ebest = E;
		int nrej = 0;
		int isearch = 0;
		std::ofstream fout;
		bool output_mis = ! pimplES->outname_misL.empty();
		if( output_mis ) fout.open(  pimplES->outname_misL.c_str(), std::ofstream::app );

		fout<<"# [ epic = "<<EInfo()<<" ]"<<std::endl;
		fout<< "-1\t" << E << "\t" << T << std::endl;
#pragma omp parallel for schedule (dynamic, 1)
		for( int i=0; i<nsearch; i++ ) {
			EpicInfo einfonew = pimplES->Neighbour( pimplES->einfo );
			float Enew = NaN;
			std::string sDValid = EnergyL(einfonew, Enew);
#pragma omp critical
			{ // critical start
				if( pimplES->Accept(E, Enew, T) ) {
					pimplES->einfo = einfonew;
					E = Enew;
					if( output_mis ) {
						fout<< std::setw(4)<<isearch << " " << std::setw(8)<<Enew << " "
							<< std::setw(8)<<T << "\t" << pimplES->einfo <<"\n";
						fout.flush();
					}
					std::cout<<"   chiSr("<<einfonew<<")="<<Enew<<"(accepted) T="<<T<<" isearch="<<isearch<<"/"<<nsearch
								<<" dtype="<<pimplES->datatype_name<<" DValid="<<sDValid<<std::endl;
					nrej = 0;
				}
				else { nrej++; std::cout<<"( nrejects = "<<nrej<<" )"<<"  ithread="<<omp_get_thread_num()<<"                  "<<"\n\x1b[A"; }
				T *= alpha;
				if( Enew < Ebest ) {
					einfobest = einfonew;
					Ebest = Enew;
				}
				isearch++;
			} // critical end
		}
		fout<< isearch << "\t" << Ebest << "\t" << T << "\t" << einfobest << std::endl;
		fout<<std::endl<<std::endl; fout.close();
		std::cout<<"                                   "<<std::endl;
		pimplES->einfo = einfobest;

	}

	/* -------------------- compute chi-square misfit at the current einfo and finfo -------------------- */
	void EQKSearcher::EnergyMC( const ModelInfo& minfo, float& chiS, int& Ndata ) {
		// decompose model info
		const FocalInfo<ftype> finfo = minfo;
		const EpicInfo einfo = minfo;

		// copy data matrices for modification!!
		std::vector< std::vector<StaData> > dataR, dataL;
		if( pimplES->RFlag() ) dataR = pimplES->per_sta_data_R;
		if( pimplES->LFlag() ) dataL = pimplES->per_sta_data_L;

		// predict traveltime from VelMaps and store Tmeasure - Vpred into varG&varP
		//	phase measurements are corrected for 2-pi based on Fpred & Vpred
		UpdateTrvtPred( einfo, dataR, dataL, false );

		// convert StaData to AziData
		std::vector< std::vector<AziData> > AziDataR, AziDataL;
		std::vector<PerDazi> perRlist, perLlist;
		PrepareAziData( dataR, pimplES->perRlist, dataL, pimplES->perLlist,
							 AziDataR, perRlist, AziDataL, perLlist );
		float wSum;
		double AfR, AfL;
		chiSquareF(AziDataR, perRlist, AziDataL, perLlist, finfo, pimplES->datatype, chiS, wSum, Ndata, AfR, AfL);
		//std::cerr<<"   chiS = "<<chiS<<"  wSum = "<<wSum<<"  Ndata = "<<Ndata<<"   NC = "<<pimplES->NC<<std::endl;
		if( Ndata <= 0 ) 
			throw ErrorFS::InsufData(FuncName, "Ndata="+std::to_string(Ndata));
		if( pimplES->NC == NaN) pimplES->NC = Ndata;
		chiS *= (float)(pimplES->NC)/Ndata;
	}

	float EQKSearcher::SearchBound( ModelInfo& minfo, float& key, float bound, float Pthsd, float Emin, int nsearch ) {
		const float key_orig = key; // save the original key
		float direct = 1, steplen = (bound-key) * 0.5;
		for(int isearch=0; isearch<nsearch; isearch++) {
			key += steplen * direct;
			int Ndata; float E;
			EnergyMC(minfo, E, Ndata);
			float P = exp(0.5*(Emin-E));
			if( P < Pthsd ) direct = -1;	  // moving backward
			else direct = 1;
			steplen *= 0.5;
			//std::cerr<<isearch<<"   "<<E<<" "<<P<<"   "<<direct<<" "<<steplen<<std::endl;
		}
		bound = key + steplen * direct;
		key = key_orig;	// set the key back to its original value
		return bound;	  // return final position after nsearches
	}

	/* -------------------- bayesian monte carlo search -------------------- */
	void EQKSearcher::MonteCarloSearch( int nsearch, ModelSpace& mspace,
			std::vector< SearchInfo<ModelInfo> >& VSinfo, bool outflag ) {
		// initialize
		int Ndata; float E;
		EnergyMC(mspace, E, Ndata);
		std::cout<<"### SearchPosterior: chiS for the center ("<<static_cast<ModelInfo>(mspace)<<") = "<<E<<" ###"<<std::endl;
		int isearch = 0;

		// start searching
		int nrej = 0;
		const char* outname = pimplES->outname_pos.c_str();
		std::ofstream fout( outname, std::ofstream::app );
		if( ! fout ) throw ErrorFS::BadFile(FuncName, outname);
		//if(outflag) VSinfo.clear();
		// save the best fitting model
		int Ndatabest = Ndata;
		float Ebest = E;
		ModelInfo mbest = mspace;
#pragma omp parallel for schedule(dynamic, 1) private( Ndata )
		for( int i=0; i<nsearch; i++ ) {
			//long t0 = std::chrono::system_clock::now().time_since_epoch().count();
			//FocalInfo<ftype> finfonew;
			//EpicInfo einfonew;
			// perturb the model from (finfo, einfo) to (finfonew, einfonew) int the range defined by (pimplES->finfo, EInfo() and Rxxxs)
			//pimplES->PerturbModel(finfo, einfo, finfonew, einfonew, pimplES->finfo, EInfo(), Rlon, Rlat, Rtim, Rstk, Rdip, Rrak, Rdep);
			ModelInfo minfonew;
			try {
				mspace.Perturb(minfonew);
			} catch( std::exception& e ) {
				std::cerr<<"Exception when perturbing mspace: "<<e.what()<<std::endl;
				exit(-2);
			}
			float Enew;
			EnergyMC(minfonew, Enew, Ndata);
#pragma omp critical
			{ // critical begin
//std::cerr<<"before EnergyMC: "<<minfonew<<std::endl;
//EnergyMC(minfonew, Enew, Ndata);
//std::cerr<<"after EnergyMC: "<<Enew<<" "<<Ndata<<std::endl;
				if( pimplES->Accept(E, Enew, 2.) ) {
					// update E and mspace
					mspace.SetMState(minfonew);
					E = Enew;
					// update Ebest and mbest
					if( E < Ebest ) {
						Ebest = E;
						mbest = mspace;
						Ndatabest = Ndata;
					}
					// output SearchInfo
					SearchInfo<ModelInfo> Sinfo { isearch, E, minfonew };
					//Sinfo.isearch = isearch; Sinfo.E = E; Sinfo.info = minfonew;
					if(outflag) VSinfo.push_back(Sinfo);
					fout << std::setw(4) << Sinfo.isearch << " " << std::setw(8)
						<< Sinfo.E << "   " << Sinfo.info << "   " << Ndata << std::endl;
					std::cout<<"   chiS for ("<<minfonew<<") = "<<E<<" (accepted)  "<<"  isearch="
						<<isearch<<"/"<<nsearch<<"  datatype="<<pimplES->datatype_name<<std::endl;
					nrej = 0;
				} else { 
					nrej++; 
					std::cout<<"( nrejects = "<<nrej<<" )"<<" ("<<E<<" ->| "<<Enew<<")  ithread="
						<<omp_get_thread_num()<<"   "<<minfonew<<"                  "<<"\n\x1b[A"; 
				}
				isearch++;
				if( isearch%100 == 0 ) std::cout.flush();
			} // critical end
		}
		// final output
		fout << std::setw(4) << isearch << " " << std::setw(8)
			<< Ebest << "   " << mbest << "   " << Ndatabest << "\n\n\n";
		fout.close();
		if(outflag) {
			SearchInfo<ModelInfo> Sinfo { isearch, Ebest, mbest};
			//Sinfo.isearch = isearch; Sinfo.E = Ebest; Sinfo.info = mbest;
			VSinfo.push_back(Sinfo);
		}

	}


	/* -------------------- search for the posterior distribution around the current einfo and finfo -------------------- */
	void EQKSearcher::SearchPosterior( const int nsearch1, const int nsearch2, const int niter2 ) {
		// search without calling SetFreeFocal for the 1st time to 
		// make sure the best fitting model is in the distribution
		SearchPosterior( nsearch1, nsearch2, false );
		for(int iter=1; iter<niter2; iter++)
			SearchPosterior( nsearch1, nsearch2, true );
	}
	void EQKSearcher::SearchPosterior( const int nsearch1, const int nsearch2, const bool freeFocal ) {
		/* ---------- pre-condition checks ---------- */
		// check output file
		pimplES->outname_pos.CheckEmpty();
		// check epic parameters
		pimplES->CheckSearchArea();
		pimplES->CheckEInfo();
		// check input measurements
		if( pimplES->datatype == Undefined ) throw ErrorFS::BadParam(FuncName, "Undefined datatype");
		int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
		if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
		if( pimplES->perRlist.size() != Rsize || pimplES->perLlist.size() != Lsize )
			throw ErrorFS::SizeMismatch(FuncName, "perRlist - Rsize || perLlist - Lsize");
		// check vel map accessibilities
		for(int iper=0; iper<Rsize; iper++) {
			pimplES->fRlist.at(iper).at(1).CheckAccess();
			pimplES->fRlist.at(iper).at(2).CheckAccess();
		}
		for(int iper=0; iper<Lsize; iper++) {
			pimplES->fLlist.at(iper).at(1).CheckAccess();
			pimplES->fLlist.at(iper).at(2).CheckAccess();
		}
		/* ------------------------------------------ */

		// pass model/misfit filenames into Focalsearcher
		FSreset( pimplES->outname_misF,
				pimplES->fReigname, pimplES->fRphvname,
				pimplES->fLeigname, pimplES->fLphvname,
				pimplES->weightR_Foc, pimplES->weightL_Foc );

		/* ---------- Initial search to stablize ---------- */
		std::cout<<"*** Starting initial Monte Carlo search ("<<nsearch1<<") to stablize the results ***" << std::endl;
		ModelInfo minfo( pimplES->einfo, pimplES->finfo );
		ModelSpace mspace( minfo ); // initial model state
		// define 'surrounding'
		float Rlon = 0.2, Rlat = 0.2, Rtim = 5.;
		float Rstk = 20., Rdip = 10., Rrak = 20., Rdep = 5.;
		// define perturbations
		float pf = 0.1;
		float Plon = pf*Rlon, Plat = pf*Rlat, Ptim = pf*Rtim;
		float Pstk = pf*Rstk, Pdip = pf*Rdip, Prak = pf*Rrak, Pdep = pf*Rdep;
		// define model space
		mspace.SetSpace( minfo.lon, minfo.lat, minfo.t0, minfo.strike, minfo.dip, minfo.rake, minfo.depth, 
				Rlon, Rlat, Rtim, Rstk, Rdip, Rrak, Rdep );
		mspace.SetPerturb( Plon, Plat, Ptim, Pstk, Pdip, Prak, Pdep );
		// run the search
		if(freeFocal) mspace.SetFreeFocal();
		std::vector< SearchInfo<ModelInfo> > VSinfo;
		MonteCarloSearch( nsearch1, mspace, VSinfo, true );
		// find the best model
		float Emin = VSinfo.at(0).E;
		ModelInfo minfo_best(minfo);
		for( auto sinfo : VSinfo ) {
			if( sinfo.E >= Emin ) continue;
			minfo_best = sinfo.info;
			Emin = sinfo.E;
		}
		/* ------------------------------------------------ */

		/* --- estimate acceptable range of each parameter and compute perturb step sizes --- */
		std::cout<<"*** Estimating acceptable range of each parameter and computing perturb step sizes ***" << std::endl;
#pragma omp parallel shared(minfo_best) private(minfo)
		{
#pragma omp sections
			{

#pragma omp section
				{
					minfo = minfo_best;
					float lb_old = minfo_best.strike - Rstk, ub_old = minfo_best.strike + Rstk;
					float lb_strike = SearchBound( minfo, minfo.strike, lb_old, Pthreshold, Emin, 10 );
					float ub_strike = SearchBound( minfo, minfo.strike, ub_old, Pthreshold, Emin, 10 );
					Pstk = (ub_strike-lb_strike) * Sfactor;
				} // omp section

#pragma omp section
				{
					minfo = minfo_best;
					float lb_old = minfo_best.dip - Rdip, ub_old = minfo_best.dip + Rdip;
					float lb_dip = SearchBound( minfo, minfo.dip, lb_old, Pthreshold, Emin, 10 );
					float ub_dip = SearchBound( minfo, minfo.dip, ub_old, Pthreshold, Emin, 10 );
					Pdip = (ub_dip-lb_dip) * Sfactor;
				} // omp section

#pragma omp section
				{
					minfo = minfo_best;
					float lb_old = minfo_best.rake - Rrak, ub_old = minfo_best.rake + Rrak;
					float lb_rake = SearchBound( minfo, minfo.rake, lb_old, Pthreshold, Emin, 10 );
					float ub_rake = SearchBound( minfo, minfo.rake, ub_old, Pthreshold, Emin, 10 );
					Prak = (ub_rake-lb_rake) * Sfactor;
				} // omp section

#pragma omp section
				{
					minfo = minfo_best;
					float lb_old = minfo_best.depth - Rdep, ub_old = minfo_best.depth + Rdep;
					float lb_depth = SearchBound( minfo, minfo.depth, lb_old, Pthreshold, Emin, 10 );
					float ub_depth = SearchBound( minfo, minfo.depth, ub_old, Pthreshold, Emin, 10 );
					Pdep = (ub_depth-lb_depth) * Sfactor;
				} // omp section

#pragma omp section
				{
					minfo = minfo_best;
					float lb_old = minfo_best.lon - Rlon, ub_old = minfo_best.lon + Rlon;
					float lb_lon = SearchBound( minfo, minfo.lon, lb_old, Pthreshold, Emin, 10 );
					float ub_lon = SearchBound( minfo, minfo.lon, ub_old, Pthreshold, Emin, 10 );
					Plon = (ub_lon-lb_lon) * Sfactor;
				} // omp section

#pragma omp section
				{
					minfo = minfo_best;
					float lb_old = minfo_best.lat - Rlat, ub_old = minfo_best.lat + Rlat;
					float lb_lat = SearchBound( minfo, minfo.lat, lb_old, Pthreshold, Emin, 10 );
					float ub_lat = SearchBound( minfo, minfo.lat, ub_old, Pthreshold, Emin, 10 );
					Plat = (ub_lat-lb_lat) * Sfactor;
				} // omp section

#pragma omp section
				{
					minfo = minfo_best;
					float lb_old = minfo_best.t0 - Rtim, ub_old = minfo_best.t0 + Rtim;
					float lb_t0 = SearchBound( minfo, minfo.t0, lb_old, Pthreshold, Emin, 10 );
					float ub_t0 = SearchBound( minfo, minfo.t0, ub_old, Pthreshold, Emin, 10 );
					Ptim = (ub_t0-lb_t0) * Sfactor;
				} // omp section

			} // omp sections
		} // omp parallel
		/* --------------------------------------------------------------------------------------- */

		/* ---------- second Monte Carlo Search with desired perturb sizes ---------- */
		mspace.SetMState( minfo_best );
		mspace.SetPerturb( Plon, Plat, Ptim, Pstk, Pdip, Prak, Pdep );
		std::cout<<"*** Starting the Monte Carlo search ("<<nsearch2<<") with model setting:"<<std::endl;
		std::cout<<mspace<<std::endl;
		VSinfo.clear();
		/*
		bool freeFocal = (niter2 != NaN);
		if( freeFocal ) {
			std::cout<<"*** Searching for "<<niter2<<" iterations for "<<nsearch2<<" searches each"<<std::endl;
			for(int iter=0; iter<niter2; iter++) {
				mspace.SetFreeFocal();
				MonteCarloSearch( nsearch2, mspace, VSinfo, true );
			}
		} else {
		*/
		MonteCarloSearch( nsearch2, mspace, VSinfo, true ); // do (not) save details into VSinfo
		/* ------------------------------------------------------------------------- */

		/* ---------- best fitting model ---------- */
		minfo_best = 
			std::min_element( VSinfo.begin(), VSinfo.end(), 
					[] (const SearchInfo<ModelInfo>& si1, const SearchInfo<ModelInfo>& si2) {
					  return (si1.E<si2.E);
					}
					) -> info;
		if( ! freeFocal ) {
			pimplES->finfo = minfo_best;
			pimplES->einfo = minfo_best;
		}
		/* ---------------------------------------- */

	}


#include "EQKSearcher.h"
#include "DisAzi.h"
#include "Map.h"
#include <cstdlib>
#include <unistd.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <chrono>
#include <random>
#include <omp.h>

struct EQKSearcher::EQimpl {
   std::string fparam;
   std::string fReigname, fRphvname;
   std::string fLeigname, fLphvname;
   std::vector< std::array<std::string, 3> > fRlist, fLlist;
   std::vector<float> perRlist, perLlist;
   std::vector< std::vector<StaData> > per_sta_data_R, per_sta_data_L;
   std::vector< std::vector<AziData> > per_azi_pred_R, per_azi_pred_L;
   float clon, clat, Rs;
   float Rt, Rlon, Rlat;
   EpicInfo einfo;


   EQimpl( const char* fparamin = NULL, float clonin = -12345.,
	   float clatin = -12345., float Rsin = -12345. )
      : fparam(fparamin), clon(clonin), clat(clatin), Rs(Rsin), Rt(20.) {
      Initialize();
   }

   bool Initialize() {
      if( Rs>0 && clon!=-12345 && clat!=-12345 ) {
	 double dist;
	 calc_dist(clat, clon, clat, clon+1, &dist);
	 Rlon = Rs / dist;
	 calc_dist(clat, clon, clat+1, clon, &dist);
	 Rlat = Rs / dist;
	 einfo = EpicInfo(clon, clat, 0.);
	 return true;
      }
      else {
	 Rlon = Rlat = -12345.;
	 return false;
      }
   }


   bool Accept(float E, float Enew, double T) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
      std::default_random_engine generator (timeseed);
      std::uniform_real_distribution<float> distribution(0., 1.);
      auto rand = std::bind ( distribution, generator );
      if(Enew<E) return true;
      if(rand()<exp((E-Enew)/T)) return true;
      return false;
   }


   EpicInfo Neighbour( const EpicInfo& einfo ) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
      // random number generator 
      std::default_random_engine generator2 (timeseed);
      //std::mt19937 generator2 (timeseed);
      std::normal_distribution<double> distributionN(0.0,1.0);
      auto randnorm = std::bind ( distributionN, generator2 );
   
      EpicInfo einfonew = einfo;

      float ht = Rt * 0.05;
      float hlon = Rlon * 0.05, hlat = Rlat * 0.05;

      while( float dltlon = randnorm()*hlon ) {
	 float lonnew = einfonew.lon + dltlon;
	 if( lonnew < clon + Rlon && lonnew > clon - Rlon ) {
	    einfonew.lon = lonnew;
	    break;
	 }
      }
      while( float dltlat = randnorm()*hlat ) {
	 float latnew = einfonew.lat + dltlat;
	 if( latnew < clat + Rlat && latnew > clat - Rlat ) {
	    einfonew.lat = latnew;
	    break;
	 }
      }
      while( float dltt = randnorm()*ht ) {
	 float tnew = einfonew.t0 + dltt;
	 if( tnew < Rt && tnew > -Rt ) {
	    einfonew.t0 = tnew;
	    break;
	 }
      }

      return einfonew;
   }


   void UpdateAziDis( EpicInfo& einfoin, std::vector< std::vector<StaData> >& datain ) {
      float srclon = einfoin.lon, srclat = einfoin.lat;

      for(int iper=0; iper<datain.size(); iper++) {
	 for(int idata=0; idata<datain.at(iper).size(); idata++) {
	    StaData& sdtmp = datain[iper][idata];
	    double azi, dist;
	    calc_dist(srclat, srclon, sdtmp.lat, sdtmp.lon, &dist);
	    calc_azimuth(srclat, srclon, sdtmp.lat, sdtmp.lon, &azi);
	    sdtmp.azi = azi;
	    sdtmp.dist = dist;
	 }
      }
/*
      for(int iper=0; iper<dataL.size(); iper++) {
	 for(int idata=0; idata<dataL.at(iper).size(); idata++) {
	    StaData& sdtmp = dataL[iper][idata];
	    double azi, dist;
	    calc_dist(srclat, srclon, sdtmp.lat, sdtmp.lon, &dist);
	    calc_azimuth(srclat, srclon, sdtmp.lat, sdtmp.lon, &azi);
	    sdtmp.azi = azi;
	    sdtmp.dist = dist;

	 }
      }
*/
   }


   bool UpdateFocalCorrR( EpicInfo& einfoin, FocalInfo& finfo, std::vector< std::vector<StaData> >& datain ) {
      if( datain.size()==0 ) return false;
      if( datain.size() != per_azi_pred_R.size() ) return false;

      // check Rayleigh source input
      if( (fReigname.empty() || fRphvname.empty()) ) return false;

      /* ------ Corrections for Rayleigh wave ----- */
      // initialize prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      //per_azi_pred.resize( perRlist.size() );

      //RadPatternR( fReigname, fRphvname, finfo, perRlist, per_azi_pred );

      for(int iper=0; iper<datain.size(); iper++) {
	 std::vector< AziData >& adlist = per_azi_pred_R.at(iper);
	 for(int idata=0; idata<datain.at(iper).size(); idata++) {
	    StaData& sdtmp = datain[iper][idata];
	    int ipredh = 1;
/* optimizable!!! */
	    while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh-1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float factor = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    sdtmp.misG = adlist.at(ipredl).misG + (adlist.at(ipredh).misG-adlist.at(ipredl).misG) * factor;
	    sdtmp.misP = adlist.at(ipredl).misP + (adlist.at(ipredh).misP-adlist.at(ipredl).misP) * factor;
	    //if(iper==3) std::cerr<<sdtmp.azi<<" "<<sdtmp.misG<<" "<<sdtmp.misP<<std::endl;
	 }
      }


      return true;
   }

   bool UpdateFocalCorrL( EpicInfo& einfoin, FocalInfo& finfo, std::vector< std::vector<StaData> >& datain ) {
      if( datain.size()==0 ) return false;
      if( datain.size() != per_azi_pred_L.size() ) return false;

      // check Love source input
      if( (fLeigname.empty() || fLphvname.empty()) ) return false;

      /* ------ Corrections for Love wave ----- */
      // initialize prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      //per_azi_pred.resize( perLlist.size() );

      //RadPatternR( fLeigname, fLphvname, finfo, perLlist, per_azi_pred );

      for(int iper=0; iper<datain.size(); iper++) {
	 std::vector< AziData >& adlist = per_azi_pred_L.at(iper);
	 for(int idata=0; idata<datain.at(iper).size(); idata++) {
	    StaData& sdtmp = datain[iper][idata];
	    int ipredh = 1;
/* optimizable!!! */
	    while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh-1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float factor = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    sdtmp.misG = adlist.at(ipredl).misG + (adlist.at(ipredh).misG-adlist.at(ipredl).misG) * factor;
	    sdtmp.misP = adlist.at(ipredl).misP + (adlist.at(ipredh).misP-adlist.at(ipredl).misP) * factor;
	 }
      }

      return true;
   }


};

EQKSearcher::EQKSearcher( const char* fparamin ) 
   : pimplES( new EQimpl(fparamin) ) {
   if( ! LoadParams( pimplES->fparam.c_str() ) ) {
      std::cerr<<"ERROR(EQKSearcher::EQKSearcher): Failed to load parameters from file "<<pimplES->fparam<<std::endl;
      exit(0);
   }
}

EQKSearcher::~EQKSearcher() {}

const std::string& EQKSearcher::FREigName() const { return pimplES->fReigname; }
      std::string& EQKSearcher::FREigName() { return pimplES->fReigname; }
const std::string& EQKSearcher::FRPhvName() const { return pimplES->fRphvname; }
      std::string& EQKSearcher::FRPhvName() { return pimplES->fRphvname; }

const std::string& EQKSearcher::FLEigName() const { return pimplES->fLeigname; }
      std::string& EQKSearcher::FLEigName() { return pimplES->fLeigname; }
const std::string& EQKSearcher::FLPhvName() const { return pimplES->fLphvname; }
      std::string& EQKSearcher::FLPhvName() { return pimplES->fLphvname; }

bool EQKSearcher::LoadParams( const char* fname ) {
   std::ifstream fin(fname);
   if( ! fin ) return false;
   int nparam = 0;
   for( std::string stmp; std::getline(fin, stmp); ) {
      int retval = Set( stmp.c_str() );
      if( retval == -3 ) continue; // reapeated period in fRlist or fLlist
      else if( retval == -2 ) continue; // empty input
      else if( retval == -1 ) continue;// std::cerr<<"Warning(EQKSearcher::Load): Unknown parameter name: "<<stmp<<std::endl;
      else if( retval == 0 ) continue;// std::cerr<<"Warning(EQKSearcher::Load): Empty parameter field for "<<stmp<<std::endl;
      else nparam++;
   }
   fin.close();

   std::cout<<"### "<<nparam<<" succed loads from param file "<<fname<<". ###"<<std::endl;

   if( pimplES->Initialize() ) return true;
   return false;
}

int EQKSearcher::Set( const char *input ) {
   std::istringstream buff(input);
   std::string stmp;
   if( ! (buff>>stmp) ) return -2;
   bool succeed;
   if( stmp == "clon" ) { 
      succeed = buff >> pimplES->clon; 
      if( succeed && pimplES->clon<0.) pimplES->clon += 360.; 
   }
   else if( stmp == "clat" ) succeed = buff >> pimplES->clat;
   else if( stmp == "Rs") succeed = buff >> pimplES->Rs;
   else if( stmp == "strike" ) succeed = buff >> FInfo().strike;
   else if( stmp == "dip" ) succeed = buff >> FInfo().dip;
   else if( stmp == "rake" ) succeed = buff >> FInfo().rake;
   else if( stmp == "depth" ) succeed = buff >> FInfo().depth;
   else if( stmp == "fRm" ) {
      std::string stmp1, stmp2, stmp3;
      float per;
      succeed = buff >> stmp1 >> stmp2 >> stmp3 >> per;
      if( succeed ) {
	 for(int iper=0; iper<pimplES->perRlist.size(); iper++) 
	    if(pimplES->perRlist.at(iper) == per) return -3;
	 pimplES->fRlist.push_back( std::array<std::string, 3>{ {stmp1, stmp2, stmp3} } );
	 pimplES->perRlist.push_back( per );
      }
   }
   else if( stmp == "fLm" ) {
      std::string stmp1, stmp2, stmp3;
      float per;
      succeed = buff >> stmp1 >> stmp2 >> stmp3 >> per;
      if( succeed ) {
	 for(int iper=0; iper<pimplES->perLlist.size(); iper++) 
	    if(pimplES->perLlist.at(iper) == per) return -3;
	 pimplES->fLlist.push_back( std::array<std::string, 3>{ {stmp1, stmp2, stmp3} } );
	 pimplES->perLlist.push_back( per );
      }
   }
   else return -1;
   if( succeed ) return 1;
   return 0;
}

bool EQKSearcher::LoadData() {
   int nfail = 0;

   for(int ifile=0; ifile<pimplES->fRlist.size(); ifile++) {
      std::ifstream fin(pimplES->fRlist.at(ifile).at(0).c_str());
      if( ! fin ) { nfail++; continue; }
      pimplES->per_sta_data_R.resize( pimplES->per_sta_data_R.size() + 1 );
      for(std::string line; std::getline(fin, line); ) {
	 pimplES->per_sta_data_R.at(ifile).push_back( StaData(line.c_str()) );
      }
      fin.close();
   }

   for(int ifile=0; ifile<pimplES->fLlist.size(); ifile++) {
      std::ifstream fin(pimplES->fLlist.at(ifile).at(0).c_str());
      if( ! fin ) { nfail++; continue; }
      pimplES->per_sta_data_L.resize( pimplES->per_sta_data_L.size() + 1 );
      for(std::string line; std::getline(fin, line); ) {
	 pimplES->per_sta_data_L.at(ifile).push_back( StaData(line.c_str()) );
      }
      fin.close();
   }


   if( nfail > 0 ) {
      std::cerr<<"Warning(EQKSearcher::LoadData): failed to load "<<nfail<<" of the data files!"<<std::endl;
      return false;
   }
   std::cout<<"### "<<pimplES->fRlist.size() + pimplES->fLlist.size()<<" data file(s) loaded. ###"<<std::endl;
   return true;
}


bool EQKSearcher::UpdateFocalCorr() {
   if( pimplES->perRlist.size()==0 && pimplES->perLlist.size()==0 ) return false;

   // check Rayleigh source input
   if( pimplES->perRlist.size() != 0 &&
      (FREigName().empty() || FRPhvName().empty()) ) return false;
   
   // check Love source input
   if( pimplES->perLlist.size() != 0 &&
      (FLEigName().empty() || FLPhvName().empty()) ) return false;

   /* ------ Corrections for Rayleigh wave ----- */
   if( pimplES->perRlist.size() > 0 ) {
      //std::vector<float> perRlst;
      //for(int i=0; i<pimplES->perRlist.size(); i++) perRlst.push_back(pimplES->perRlist.at(i));
      std::vector<float>& perRlst = pimplES->perRlist;

      // initialize/reset prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      pimplES->per_azi_pred_R.clear();
      pimplES->per_azi_pred_R.resize( perRlst.size() );

      RadPatternR( FREigName(), FRPhvName(), FInfo(), perRlst, pimplES->per_azi_pred_R );

      for(int iper=0; iper<pimplES->per_sta_data_R.size(); iper++) {
	 std::vector< AziData >& adlist = pimplES->per_azi_pred_R.at(iper);
	 for(int idata=0; idata<pimplES->per_sta_data_R.at(iper).size(); idata++) {
	    StaData& sdtmp = pimplES->per_sta_data_R.at(iper).at(idata);
	     int ipredh = 1;
	     while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	     int ipredl = ipredh-1;
	     if( ipredh == adlist.size() ) ipredh = 0;
	     float factor = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	     sdtmp.misG = adlist.at(ipredl).misG + (adlist.at(ipredh).misG-adlist.at(ipredl).misG) * factor;
	     sdtmp.misP = adlist.at(ipredl).misP + (adlist.at(ipredh).misP-adlist.at(ipredl).misP) * factor;
	     //if(iper==3) std::cerr<<sdtmp.azi<<" "<<sdtmp.misG<<" "<<sdtmp.misP<<std::endl;
	 }
      }

   }

   /* ------ Corrections for Love wave ----- */
   if( pimplES->perLlist.size() > 0 ) {
      //std::vector<float> perLlst;
      //for(int i=0; i<pimplES->perLlist.size(); i++) perLlst.push_back(pimplES->perLlist.at(i).per);
      std::vector<float>& perLlst = pimplES->perLlist;

      // initialize prediction matrix
      //std::vector< std::vector<AziData> > per_azi_pred;
      pimplES->per_azi_pred_L.clear();
      pimplES->per_azi_pred_L.resize( perLlst.size() );

      RadPatternR( FLEigName(), FLPhvName(), FInfo(), perLlst, pimplES->per_azi_pred_L );

      for(int iper=0; iper<pimplES->per_sta_data_L.size(); iper++) {
	 std::vector< AziData >& adlist = pimplES->per_azi_pred_L.at(iper);
	 for(int idata=0; idata<pimplES->per_sta_data_L.at(iper).size(); idata++) {
	    StaData& sdtmp = pimplES->per_sta_data_L.at(iper).at(idata);
	    int ipredh = 1;
	    while( ipredh < adlist.size() && adlist.at(ipredh).azi < sdtmp.azi ) ipredh++;
	    int ipredl = ipredh-1;
	    if( ipredh == adlist.size() ) ipredh = 0;
	    float factor = (sdtmp.azi - adlist.at(ipredl).azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    sdtmp.misG = adlist.at(ipredl).misG + (adlist.at(ipredh).misG-adlist.at(ipredl).misG) * factor;
	    sdtmp.misP = adlist.at(ipredl).misP + (adlist.at(ipredh).misP-adlist.at(ipredl).misP) * factor;
	 }
      }

   }

   return true;
}



bool EQKSearcher::Energy( EpicInfo& einfo, float& E ) {

//   std::cerr<<"test!!!: "<<map.PathAverage(Point<float>(-102., 42.), 80.)<<std::endl;
   // check input params
   if( einfo.lon==-12345. || einfo.lat==-12345. || einfo.t0==-12345. ) return false;
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) return false;

   E = 0.;
   float srclon = einfo.lon, srclat = einfo.lat, srct0 = einfo.t0;

   // compute misfit (measured - predicted) for Rayleigh maps
   std::vector< std::vector<StaData> > dataR = pimplES->per_sta_data_R;
   pimplES->UpdateAziDis( einfo, dataR );
   pimplES->UpdateFocalCorrR( einfo, FInfo(), dataR );
   for(int iper=0; iper<Rsize; iper++) {
      std::string& fname1 = pimplES->fRlist.at(iper).at(1);
      if( access(fname1.c_str(), R_OK) == -1 ) return false;
      Map map1(fname1.c_str(), Point<float>(srclon, srclat));

      std::string& fname2 = pimplES->fRlist.at(iper).at(2);
      if( access(fname2.c_str(), R_OK) == -1 ) return false;
      Map map2(fname2.c_str(), Point<float>(srclon, srclat));

      float per = pimplES->perRlist.at(iper), lamda = per*3.;
      for( int idat=0; idat<dataR[iper].size(); idat++ ) {
	 StaData& sdcur = dataR[iper][idat];
	 float misG = sdcur.grT + srct0 - sdcur.misG - 
		      sdcur.dist/map1.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda );
	 float misP = sdcur.phT + srct0 - sdcur.misP - 
		      sdcur.dist/map2.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda );
	 E += misG*misG*0.5 + misP*misP*0.5;
      }

   }

   for(int iper=0; iper<Lsize; iper++) {
      if( access(pimplES->fLlist.at(iper).at(1).c_str(), R_OK) == -1 ) return false;
      if( access(pimplES->fLlist.at(iper).at(2).c_str(), R_OK) == -1 ) return false;
   }
   // compute misfit (measured - predicted) for Love maps
   std::vector< std::vector<StaData> > dataL = pimplES->per_sta_data_L;
   pimplES->UpdateAziDis( einfo, dataL );
   pimplES->UpdateFocalCorrL( einfo, FInfo(), dataL );
   for(int iper=0; iper<Lsize; iper++) {
      std::string& fname1 = pimplES->fLlist.at(iper).at(1);
      if( access(fname1.c_str(), R_OK) == -1 ) return false;
      Map map1(fname1.c_str(), Point<float>(srclon, srclat));

      std::string& fname2 = pimplES->fLlist.at(iper).at(2);
      if( access(fname2.c_str(), R_OK) == -1 ) return false;
      Map map2(fname2.c_str(), Point<float>(srclon, srclat));

      float per = pimplES->perLlist.at(iper), lamda = per*3.;
      for( int idat=0; idat<dataL[iper].size(); idat++ ) {
	 StaData& sdcur = dataL[iper][idat];
	 float misG = sdcur.grT + srct0 - sdcur.misG - 
		      sdcur.dist/map1.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda );
	 float misP = sdcur.phT + srct0 - sdcur.misP - 
		      sdcur.dist/map2.PathAverage( Point<float>(sdcur.lon, sdcur.lat), lamda );
	 E += misG*0.5 + misP*0.5;
      }

   }


   return true;
}

bool EQKSearcher::SearchLocation( int nsearch, float alpha, float Tfactor ) {
   // check parameters
   if( pimplES->clon==-12345. || pimplES->clat==-12345. || pimplES->Rs==-12345. ) return false;
   // check input measurements
   int Rsize = pimplES->per_sta_data_R.size(), Lsize = pimplES->per_sta_data_L.size();
   if( Rsize == 0 && Lsize == 0 ) return false;
   if( pimplES->perRlist.size() != Rsize || pimplES->perLlist.size() != Lsize ) return false;
   // check vel maps
   for(int iper=0; iper<Rsize; iper++) {
      if( access(pimplES->fRlist.at(iper).at(1).c_str(), R_OK) == -1 ) return false;
      if( access(pimplES->fRlist.at(iper).at(2).c_str(), R_OK) == -1 ) return false;
   }
   for(int iper=0; iper<Lsize; iper++) {
      if( access(pimplES->fLlist.at(iper).at(1).c_str(), R_OK) == -1 ) return false;
      if( access(pimplES->fLlist.at(iper).at(2).c_str(), R_OK) == -1 ) return false;
   }

   // simulated annealing
   float E;
   if( ! Energy(pimplES->einfo, E) ) return false;
   float T = E * Tfactor;
   std::cout<<"### SearchLocation: Initial Misfit**2 for "<<pimplES->einfo<<" = "<<E<<" T="<<T<<" ###"<<std::endl;
   EpicInfo einfobest = pimplES->einfo;
   float Ebest = E;
   int nrej = 0;
   int isearch = 0;
   #pragma omp parallel for
   for( int i=0; i<nsearch; i++ ) {
      EpicInfo einfonew = pimplES->Neighbour( pimplES->einfo );
      float Enew = -12345.;
      if( ! Energy(einfonew, Enew) ) continue;
      if( pimplES->Accept(E, Enew, T) ) {
	 pimplES->einfo = einfonew;
	 E = Enew;
	 std::cout<<"   Misfit**2 for "<<einfonew<<" = "<<Enew<<" (accepted)  T="
		  <<T<<"  isearch="<<isearch<<"/"<<nsearch<<std::endl;
	 nrej = 0;
      }
      else { nrej++; std::cout<<"( nrejects = "<<nrej<<" )"<<"  ithread="<<omp_get_thread_num()<<"   "<<std::endl<<"\x1b[A"; }
     #pragma omp critical
     { // critical start
      T *= alpha;
      if( Enew < Ebest ) {
	 einfobest = einfonew;
	 Ebest = Enew;
      }
      isearch++;
     } // critical end
   }
   pimplES->einfo = einfobest;

   return true;
}

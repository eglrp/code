/* search for earthquake location and focal infomation from surface wave measurements */
/* the searching space and measurement files are given in the input parameter file as follows: */
   /* clon, clat defines the search center (required) */
   /* Rs defines the search radius (required) */
   /* strike, dip, rake, depth defines the initial focal mechanism */
   /* Raleigh wave measurements ( stalon, stalat, grT, phT, amp ) */
   /* Love wave measurements ( stalon, stalat, grT, phT, amp ) */

#include "EQKSearcher.h"
#include <cstdio>
#include <cstdlib>
#include <iostream>

int main( int argc, char *argv[] ) {
   if( argc != 2 ) {
      std::cerr<<"Usage: "<<argv[0]<<" [parameter file]"<<std::endl;
      exit(-1);
   }

   EQKSearcher eSearcher( argv[1] );

   if( ! eSearcher.LoadData() ) { exit(0); }

   for(int iter=0; iter<20; iter++) {
      //initial epic info and focal info
      EpicInfo einfo_old = eSearcher.EInfo();
      FocalInfo<ftype> finfo_old = eSearcher.FInfo();
      //float E;
      //EpicInfo eitmp = EpicInfo(245.137, 41.1451, -.5);
      //eSearcher.EnergyL( eitmp, E ); std::cerr<<E<<std::endl;
      
      /* Update azimuth & distance based on the current location
       * and sort station by azimuth. For both Love and Rayleigh waves*/
      eSearcher.UpdateAziDis();
      /* Update Focal corrections based on the current finfo.
       * For both R and L waves. */
      if( ! eSearcher.UpdateFocalCorr() ) {
	 std::cerr<<"Error(main): correct focal failed!"<<std::endl;
	 exit(0);
      }
      /* output 1 */
      eSearcher.OutputFocal();

      /* search for a better location (simulated annealing with both R and L data) */
      /* redefine searching space after 2 iterations */
      int nsearchL = 2000;
/*
      if(iter >= 2) {
	 nsearchL = 500;
	 eSearcher.Set("Rs 10.");
	 EpicInfo eicur = eSearcher.EInfo();
	 eSearcher.Set( std::string("clon " + std::to_string(eicur.lon)).c_str() );
	 eSearcher.Set( std::string("clat " + std::to_string(eicur.lat)).c_str() );
      }
*/
      /* This is a linear problem. At alpha=0.99, the temperature decays down to 0 
       * in the first 500 steps allowing fast convergence to the optimal location */
      if( ! eSearcher.SearchLocation(nsearchL, 1., 0.) ) {
      //if( ! eSearcher.SearchLocation(2000, 0.99, 0.3) ) {
	 std::cerr<<"Error(main): search location failed!"<<std::endl;
	 exit(0);
      }

      /* prepare data for the FocalSearcher */
      if( ! eSearcher.PrepareFocalData() ) {
	 std::cerr<<"Error(main): Data preparation fo focal search failed!"<<std::endl;
	 exit(0);
      }

      /* output 2 */
      //eSearcher.UpdateAziDis();
      //eSearcher.OutputFocal();

      /* search for better focal info
       * the focal mechanism is rather unstable. A smaller alpha and larger T0 is set for
       * iter 1&2 so that the search result is likely to converge to the global minimum */
      int nsearchF = 5000;
      float alpha = 0.9985, Tfactor = 10.;
      if(iter>=2) { nsearchF = 1000, alpha = 1., Tfactor = 0.; }
      if( ! eSearcher.SearchFocal( nsearchF, alpha, Tfactor ) ) {
	 std::cerr<<"Error(main): search focal failed!"<<std::endl;
	 exit(0);
      }

      /* stop search if the result converges
       * note that the '==' operators are defined such that
       * differences less than 0.01km/0.1sec/0.1degree are ignored */
      if( eSearcher.FInfo()==finfo_old && eSearcher.EInfo()==einfo_old ) break;
   }
   eSearcher.UpdateAziDis();
   if( ! eSearcher.UpdateFocalCorr() ) {
      std::cerr<<"Error(main): correct focal failed!"<<std::endl;
      exit(0);
   }
   eSearcher.OutputFocal();

   std::cout<<eSearcher.FInfo()<<std::endl;


   return 0;
}

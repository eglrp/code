/* search for earthquake location and focal infomation from surface wave measurements */
/* the searching space and measurement files are given in the input parameter file as follows: */
   /* clon, clat defines the search center (required) */
   /* Rs defines the search radius (required) */
   /* strike, dip, rake, depth defines the initial focal mechanism */
   /* Raleigh wave measurements ( stalon, stalat, grT, phT, amp ) */
   /* Love wave measurements ( stalon, stalat, grT, phT, amp ) */

#include "EQKSearcher.h"
#include <cstring>
#include <iostream>
#include <stdexcept>

int main( int argc, char *argv[] ) {
	if( argc!=2 && argc!=3 ) {
		std::cerr<<"Usage: "<<argv[0]<<" [parameter file] [freeFocal(optional)]"<<std::endl;
		exit(-1);
	}
	if( argc==3 && strcmp(argv[2],"freeFocal")!=0 ) {
		std::cerr<<"Invalid input!"<<std::endl;
		exit(-1);
	}

	try {
		EQKSearcher eSearcher( argv[1] );

		eSearcher.LoadData();

		for(int iter=0; iter<5; iter++) {
		//for(int iter=0; iter<0; iter++) {
			/* --- output initial fits (with all data points) --- */
			eSearcher.Output();

			float Tfactor, alpha;

			/* ---------------------------------------- Search Epic Info ---------------------------------------- */
			/* search for a better location (simulated annealing with both R and L data) */
			/* redefine searching space after 2 iterations */
			bool isInitial = false; // initial search for location: with Love Group only!
			Tfactor = 10.;
			int nsearchL = 1500;
			if(iter >= 2) {
				isInitial = false;
				Tfactor = 0.;
				nsearchL = 800;
				eSearcher.Set("Rs 10.");
				EpicInfo eicur = eSearcher.EInfo();
				eSearcher.Set( std::string("clon " + std::to_string(eicur.lon)).c_str() );
				eSearcher.Set( std::string("clat " + std::to_string(eicur.lat)).c_str() );
			}
			/* This is a linear problem. At alpha=0.99, the temperature decays down to 0 
			 * in the first 500 steps allowing fast convergence to the optimal location */
			eSearcher.SearchLocation(nsearchL, 0.99, Tfactor, isInitial);


			/* ---------------------------------------- Search Focal Info ---------------------------------------- */
			/* prepare data for the FocalSearcher */
			//eSearcher.PrepareFocalData(); // this is now called inside EQKSearcher::SearchFocal() !

			/* search for better focal info
			 * the focal mechanism is rather unstable. A smaller alpha and larger T0 is set for
			 * iter 1&2 so that the search result is likely to converge to the global minimum */
			int nsearchF;
			if(iter==0) { 
				//nsearchF = 6000; alpha = 0.9990; Tfactor = 10.;
				nsearchF = 30000; alpha = 0.9998; Tfactor = 10.;
			} else if(iter<2) { 
				//nsearchF = 5000; alpha = 0.9985; Tfactor = 20. ;
				nsearchF = 10000; alpha = 0.9995; Tfactor = 20.;
			} else { 
				nsearchF = 1000, alpha = 1., Tfactor = 0.; 
			}
			eSearcher.SearchFocal( nsearchF, alpha, Tfactor );

		}

		/* --- fits after simulated annealing --- */
		eSearcher.Output(true);

		std::cout<<"*** Result from SA: Epic = ("<<eSearcher.EInfo()<<")  Focal = ("<<eSearcher.FInfo()<<") ***"<<std::endl;

		/* now search for the posterior distribution in the surrounding space 
			search 3000 steps initially to stablize, then estimate proper perturb stepsizes and search again */
		if( argc==3 && strcmp(argv[2],"freeFocal")==0 ) {
			eSearcher.SearchPosterior( 5000, 10000, 50 ); // search in the entire focal space
		} else {
			eSearcher.SearchPosterior( 3000, 100000 );
		}

		/* --- final fits after Monte Carlo --- */
		eSearcher.Output(true);

		/* --- compute and output misfits, separately, for group, phase, and amplitudes --- */
		eSearcher.ComputeMisfitsAll();

	} catch(std::exception& e) {
		std::cerr<<e.what()<<std::endl;
		return -1;
	} catch(...) {
		std::cerr<<"Unknown Exception!"<<std::endl;
		return -2;
	}

	return 0;
}

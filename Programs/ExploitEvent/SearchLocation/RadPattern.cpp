#include "RadPattern.h"
#include <fstream>

/* FORTRAN entrance */
extern"C" {
   void rad_pattern_r_(char *feig_buff, int *eig_len, int *phvnper, int *phvdper,
                       const float *strike, const float *dip, const float *rake, const float *depth,
		       const float *per, int *nper,
                       float *azi, float grT[][181], float phT[][181], float amp[][181]);
   void rad_pattern_l_(char *feig_buff, int *eig_len, int *phvnper, int *phvdper,
                       const float *strike, const float *dip, const float *rake, const float *depth,
		       const float *per, int *nper,
                       float *azi, float grT[][181], float phT[][181], float amp[][181]);
}


/* ---------- implimentation ---------- */
struct RadPattern::Rimpl {
   //FocalInfo<ftype> finfo, finfoold;
   //std::string outname_mis;
   std::string feignmem, fphvnmem; // name of files of the currently-in-the-memory contents

   int phvnper, phvdper;
   int feig_len;
   char *feig_buff;

   /* ---------- con/destructors ---------- */
   Rimpl() {
      phvnper = -12345; phvdper = -12345;
      feig_buff = NULL; feig_len = -12345;
   }
   ~Rimpl() { if(feig_buff) delete [] feig_buff; }

};


/* con/destructors and operators */
RadPattern::RadPattern()
   : pimplR( new Rimpl ) {}

RadPattern::RadPattern( const RadPattern& rp2 )
   : pimplR( new Rimpl(*(rp2.pimplR)) ) {}

RadPattern::RadPattern( RadPattern&& rp2 )
   : pimplR( std::move(rp2.pimplR) ) {}

RadPattern& RadPattern::operator= ( const RadPattern& rp2 ) {
   pimplR.reset( new Rimpl(*(rp2.pimplR)) );
}

RadPattern& RadPattern::operator= ( RadPattern&& rp2 ){
   pimplR = std::move(rp2.pimplR);
}

RadPattern::~RadPattern() {}

/* predict radpattern for rayleigh and love waves */
void RadPattern::Predict( char type, const std::string& feigname, const std::string& fphvname,
			  const ftype strike, const ftype dip, const ftype rake, const ftype depth,
			  const std::vector<float>& perlst, std::vector< std::vector<AziData> >& per_azi_pred ) {
   if( type!='R' && type!='L' )
      throw ErrorRP::BadParam(FuncName, "unknown type = "+type);
   int nper = perlst.size();
   //float strike = finfo.strike, dip = finfo.dip, rake = finfo.rake, depth = finfo.depth;
   float azi[181], grT[nper][181], phT[nper][181], amp[nper][181];

  #pragma omp critical
  { // omp critical begins
   // read feig into memory
   if( pimplR->feig_buff == NULL || feigname != pimplR->feignmem ) {
      if( feigname.empty() ) throw ErrorRP::BadParam(FuncName, "empty feigname");
      std::ifstream fin( feigname.c_str() );
      if( ! fin ) throw ErrorRP::BadFile(FuncName, feigname);
      fin.seekg(0, std::ios::end);
      pimplR->feig_len = fin.tellg();
      if( pimplR->feig_buff ) {
	 delete [] pimplR->feig_buff;
	 pimplR->feig_buff = NULL;
      }
      pimplR->feig_buff = new char[pimplR->feig_len];
      fin.seekg(0,std::ios::beg);
      fin.read(pimplR->feig_buff, pimplR->feig_len);
      fin.close();
      pimplR->feignmem = feigname;
   }

   // read in nper and dper from fphv
   if( pimplR->phvnper < 0 || fphvname != pimplR->fphvnmem )  {
      if( fphvname.empty() ) throw ErrorRP::BadParam(FuncName, "empty fphvname");
      std::ifstream fin( fphvname.c_str() );
      if( ! fin ) throw ErrorRP::BadFile(FuncName, fphvname);
      pimplR->phvnper = 0;
      for( std::string line; std::getline(fin, line); ) {
         float ftmp1, ftmp2, ftmp3;
         if( sscanf(line.c_str(), "%f %f %f", &ftmp1, &ftmp2, &ftmp3) != 3 ) continue;
         if( pimplR->phvnper == 0 ) pimplR->phvdper = ftmp1;
         else if( pimplR->phvnper == 1 ) pimplR->phvdper = ftmp1 - pimplR->phvdper;
         (pimplR->phvnper)++;
      }
      fin.close();
      pimplR->fphvnmem = fphvname;
   }
  } // omp critical ends

   // check if feig and fphv contents are modified
   if( pimplR->feig_buff == NULL || feigname != pimplR->feignmem ) 
      throw ErrorRP::BadBuff(FuncName, feigname + " != " + pimplR->feignmem);
   if( pimplR->phvnper < 0 || fphvname != pimplR->fphvnmem ) 
      throw ErrorRP::BadBuff(FuncName, fphvname + " != " + pimplR->fphvnmem);

   // run rad_pattern
   if( type == 'R' ) {
      rad_pattern_r_( pimplR->feig_buff, &(pimplR->feig_len), &(pimplR->phvnper), &(pimplR->phvdper),
                      &(strike), &(dip), &(rake), &(depth), &(perlst.at(0)), &nper, azi, grT, phT, amp );
   } else if( type == 'L' ) {
      rad_pattern_l_( pimplR->feig_buff, &(pimplR->feig_len), &(pimplR->phvnper), &(pimplR->phvdper),
                      &(strike), &(dip), &(rake), &(depth), &(perlst.at(0)), &nper, azi, grT, phT, amp );
   }

   // check if feig and fphv contents are modified
   if( pimplR->feig_buff == NULL || feigname != pimplR->feignmem ) 
      throw ErrorRP::BadBuff(FuncName, feigname + " != " + pimplR->feignmem);
   if( pimplR->phvnper < 0 || fphvname != pimplR->fphvnmem ) 
      throw ErrorRP::BadBuff(FuncName, fphvname + " != " + pimplR->fphvnmem);

   // copy results into prediction vectors
   per_azi_pred.clear(); per_azi_pred.resize(nper);
   for(int i=0; i<nper; i++) {
      per_azi_pred.at(i).resize(181);
      for(int iazi=0; iazi<181; iazi++) {
         if( azi[iazi] != iazi*2 )
	    throw ErrorRP::BadAzi(FuncName, std::to_string(azi[iazi])+" != 2*"+std::to_string(iazi));
         per_azi_pred[i][iazi] = AziData( azi[iazi], grT[i][iazi], phT[i][iazi], amp[i][iazi] );
      }
   }

}

#ifndef FOCALSEARCHER_H
#define FOCALSEARCHER_H
#include "RadPattern.h"
#include "StackTrace.h"
#include <cstdio>
#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include <memory>
#include <random>
#include <chrono>
#include <stdexcept>

/* allowed min number of measurements */
#define MIN_AZI_SIZE 10
/* number of iterations in excluding bad (out of 2sigma) data */
#define NEX 1
/* weighting between Rayleigh and Love data for Focal searching */
#define weightR_Foc 0.5
#define weightL_Foc 0.5


/* -------------------- warning/exceptions -------------------- */
#ifndef FuncName
//#define FuncName __PRETTY_FUNCTION__
#define FuncName __FUNCTION__
//#define FuncName __func__
#endif


namespace WarningFS {
   class Base {
   public:
      Base(const std::string message) {
	 std::cerr<<message<<std::endl;
      }
   };

   class MoveExistFile : public Base {
   public:
      MoveExistFile(const std::string funcname, const std::string info = "")
         : Base("Warning("+funcname+"): Moving existing file ("+info+").") {}
   };

   class Other : public Base {
   public:
      Other(const std::string funcname, const std::string info = "")
         : Base("Warning("+funcname+"): "+info) {}
   };

};

namespace ErrorFS {

   class Base : public std::runtime_error {
   public:
      Base(const std::string message)
	 : runtime_error(message) {
	 PrintStacktrace();
      }
   };

   class BadFile : public Base {
   public:
      BadFile(const std::string funcname, const std::string info = "")
         : Base("Error("+funcname+"): Cannot access file ("+info+").") {}
   };

   class BadParam : public Base {
   public:
      BadParam(const std::string funcname, const std::string info = "")
         : Base("Error("+funcname+"): Bad parameters ("+info+").") {}
   };

   class SizeMismatch : public Base {
   public:
      SizeMismatch(const std::string funcname, const std::string info = "")
         : Base("Error("+funcname+"): Incompatible sizes ("+info+").") {}
   };

   class BadAzi : public Base {
   public:
      BadAzi(const std::string funcname, const std::string info = "")
         : Base("Error("+funcname+"): Bad azi triplet ("+info+").") {}
   };

   class EmptyData : public Base {
   public:
      EmptyData(const std::string funcname, const std::string info = "")
         : Base("Error("+funcname+"): Empty data input ("+info+").") {}
   };

   class InsufData : public Base {
   public:
      InsufData(const std::string funcname, const std::string info = "")
         : Base("Error("+funcname+"): Insufficient data points ("+info+").") {}
   };

};


/* -------------------- RNG class-------------------- */
class Rand {
   std::default_random_engine generator1;
   std::uniform_real_distribution<float> d_uniform;
   std::normal_distribution<float> d_normal;
public:
   Rand()
      : generator1( std::chrono::system_clock::now().time_since_epoch().count() )
      , d_uniform(0., 1.)
      , d_normal(0., 1.) {}

   ~Rand() {}

   inline float Uniform() { return d_uniform(generator1); }
   inline float Normal() { return d_normal(generator1); }

};


/* -------------------- data structures -------------------- */
struct PerDazi {
   float per, dazi;
   PerDazi( float perin = -12345., float daziin = -12345. )
      : per(perin), dazi(daziin) {}
};

/*
struct AziData {
   float azi;
   float misG, varG;
   float misP, varP;
   float A, varA;
   AziData( float aziin = -12345., float misGin = -12345., 
	    float misPin = -12345., float ampin = -12345. ) 
      : azi(aziin), misG(misGin), misP(misPin), A(ampin) {}

   friend std::ostream& operator<< ( std::ostream& o, const AziData& ad ) {
      o<<"( "<<ad.azi<<"  "<<ad.misG<<" "<<ad.varG<<"  "<<ad.misP<<" "<<ad.varP
       <<"  "<<ad.A<<" "<<ad.varA<<" )"; 
      return o; 
   }

};

struct FocalInfo {
   int strike, dip, rake;
   int depth;
   FocalInfo( int strikein = 180, int dipin = 45, int rakein = 0, int depthin = 10 )
      : strike(strikein), dip(dipin), rake(rakein), depth(depthin) {}
   friend std::ostream& operator<< ( std::ostream& o, const FocalInfo& f ) {
      o<<"( "<<std::setw(3)<<f.strike<<" "<<std::setw(2)<<f.dip<<" "<<std::setw(4)<<f.rake<<"  "<<std::setw(2)<<f.depth<<" )"; 
      return o; 
   }
};
*/


class FocalSearcher {
protected:
   struct FSimpl;
   std::unique_ptr<FSimpl> pimplFS;

public:
   /* con/destructors */
   FocalSearcher();
   FocalSearcher( const FocalInfo<ftype> &finfoin,
		  const std::vector<PerDazi> &perRlistin, 
		  const std::vector<PerDazi> &perLlistin, 
		  const std::vector< std::vector<AziData> > &per_R_azi_data_in,
		  const std::vector< std::vector<AziData> > &per_L_azi_data_in,
		  const char *fReignamein, const char *fRphvnamein,
		  const char *fLeignamein, const char *fLphvnamein );

   ~FocalSearcher();

   /* pimplFS-member getters/setters */
   const std::string& FMisF() const;
	 std::string& FMisF();
   const FocalInfo<ftype>& FInfo() const;
	 FocalInfo<ftype>& FInfo();
   const FocalInfo<ftype>& FInfoOld() const;
	 FocalInfo<ftype>& FInfoOld();

   const bool& RFlag() const;
	 bool& RFlag();
   const bool& LFlag() const;
	 bool& LFlag();


   const double& AFactorR() const;
	 double& AFactorR();
   const double& AFactorL() const;
	 double& AFactorL();

   const std::string& FREigName() const;
	 std::string& FREigName();
   const std::string& FRPhvName() const;
	 std::string& FRPhvName();

   const std::string& FLEigName() const;
	 std::string& FLEigName();
   const std::string& FLPhvName() const;
	 std::string& FLPhvName();

   const std::vector<PerDazi>& PerRList() const;
	 std::vector<PerDazi>& PerRList();
   const std::vector< std::vector<AziData> >& Per_R_Azi_Data() const;
	 std::vector< std::vector<AziData> >& Per_R_Azi_Data();

   const std::vector<PerDazi>& PerLList() const;
	 std::vector<PerDazi>& PerLList();
   const std::vector< std::vector<AziData> >& Per_L_Azi_Data() const;
	 std::vector< std::vector<AziData> >& Per_L_Azi_Data();


   /* Predict Rayleigh wave radiation patterns */
//   bool RadPatternR( const std::string& feigname, const std::string& fphvname, const FocalInfo& finfo,
//		     std::vector<float>& perlst, std::vector< std::vector<AziData> >& per_azi_pred );


   void EnergyF( const FocalInfo<ftype>& finfo, float &E, double& AfactorR, double& AfactorL );
   void chiSquareF( std::vector< std::vector<AziData> >& Rdata, std::vector<PerDazi>& perRlist,
                    std::vector< std::vector<AziData> >& Ldata, std::vector<PerDazi>& perLlist,
                    const FocalInfo<ftype>& finfo, float& chiS, float& wSum, int& N, 
                    double& AfactorR, double& AfactorL );

   /* the searcher */
   void SearchFocal( int, float, float );
      
};


#endif

#include "FocalSearcher.h"
#include "MyOMP.h"
#include <chrono>
#include <thread>

/* earthquake epicenter information */
struct EpicInfo {
   float lon, lat, t0;

   EpicInfo( float lonin = -12345., float latin = -12345., float t0in = -12345. )
      : lon(lonin), lat(latin), t0(t0in) {}

   friend std::ostream& operator<< ( std::ostream& o, const EpicInfo& e ) {
      o.precision(6);
      o<<std::setw(6)<<e.lon<<" "<<std::setw(6)<<e.lat<<"  "<<std::setw(6)<<e.t0; 
      return o; 
   }

   friend bool operator== ( const EpicInfo& ei1, const EpicInfo& ei2 ) {
      float dis_lon = fabs(ei1.lon - ei2.lon) * 100.;
      float dis_lat = fabs(ei1.lat - ei2.lat) * 100.;
      float dis_t = fabs(ei1.t0 - ei2.t0);
      return (dis_lon<0.01 && dis_lat<0.01 && dis_t<0.01);
   }
};


/* model space */
class ModelInfo : public FocalInfo<ftype>, public EpicInfo {
   public:
      ModelInfo() {}

      ModelInfo( const float lonin, const float latin, const float timin,
	    const float stkin, const float dipin, const float rakin, const float depin )
	 : EpicInfo(lonin, latin, timin)
	   , FocalInfo(stkin, dipin, rakin, depin) {}

      ModelInfo( const EpicInfo& einfo, const FocalInfo& finfo )
	 : EpicInfo(einfo), FocalInfo(finfo) {}

      friend std::ostream& operator<< ( std::ostream& o, const ModelInfo& m ) {
	 o<< static_cast< const FocalInfo<ftype>& >(m) << "   " << static_cast< const EpicInfo& >(m);
	 return o;
      }

      friend bool operator== ( const ModelInfo& ms1, const ModelInfo& ms2 ) {
	 return ( ( static_cast< const FocalInfo<ftype>& >(ms1) == static_cast< const FocalInfo<ftype>& >(ms2) )
	       && ( static_cast< const EpicInfo& >(ms1) == static_cast< const EpicInfo& >(ms2) ) );
      }
};

class ModelSpace : public ModelInfo {
   public:
      ModelSpace()
	 : validS(false), validP(false)
	   , Rlon(-12345), Rlat(-12345), Rtim(-12345)
	   , Plon(-12345), Plat(-12345), Ptim(-12345)
	   , Rstk(-12345), Rdip(-12345), Rrak(-12345), Rdep(-12345)
	   , Pstk(-12345), Pdip(-12345), Prak(-12345), Pdep(-12345) {
	 // produce Rand object for each thread
	 for(int i=0; i<omp_get_max_threads(); i++) {
	    // apply separated seed by sleeping
	    randO.push_back( Rand() );
	    std::this_thread::sleep_for(std::chrono::milliseconds(100));
	 }
      }

      ModelSpace( const ModelInfo& mi ) 
	 : ModelSpace() {
	 strike = mi.strike;
	 dip = mi.dip;
	 rake = mi.rake;
	 depth = mi.depth;
	 lon = mi.lon;
	 lat = mi.lat;
	 t0 = mi.t0;
      }

      inline void SetMState( const ModelInfo& mi ) {
	 *( static_cast< ModelInfo* >(this) ) = mi;
      }

      void SetSpace( const float Clonin, const float Clatin, const float Ctimin,
	    const float Cstkin, const float Cdipin, const float Crakin, const float Cdepin,
	    const float Rlonin, const float Rlatin, const float Rtimin,
	    const float Rstkin, const float Rdipin, const float Rrakin, const float Rdepin ) {
	 Clon = Clonin; Clat = Clatin; Ctim = Ctimin;
	 Cstk = Cstkin; Cdip = Cdipin; Crak = Crakin; Cdep = Cdepin;
	 if( Clon<0. ) Clon+=360.;
	 if( Clon<0||Clon>=360. || Clat<-90.||Clat>90. ||
	       Cstk<0||Cstk>=360. || Cdip<0.||Cdip>90. || Crak<-180.||Crak>=180. || Cdep<0. )
	    throw std::runtime_error("SetC");
	 Rlon = Rlonin; Rlat = Rlatin; Rtim = Rtimin;
	 Rstk = Rstkin; Rdip = Rdipin; Rrak = Rrakin; Rdep = Rdepin;
	 if( Rlon<=0. || Rlat<=0. || Rtim<=0. || Rstk<=0. || Rdip<=0. || Rrak<=0. || Rdep<=0. )
	    throw std::runtime_error("SetR");
	 validS = true;
      }

      void SetPerturb( const float Plonin, const float Platin, const float Ptimin,
	    const float Pstkin, const float Pdipin, const float Prakin, const float Pdepin ) {
	 Plon = Plonin; Plat = Platin; Ptim = Ptimin;
	 Pstk = Pstkin; Pdip = Pdipin; Prak = Prakin; Pdep = Pdepin;
	 if( Plon<=0. || Plat<=0. || Ptim<=0. || Pstk<=0. || Pdip<=0. || Prak<=0. || Pdep<=0. )
	    throw std::runtime_error("SetP");
	 validP = true;
      }

      inline float Neighbour_Reflect( float valold, float hlen, float lb, float ub ) {
	 float range = ub - lb;
	 float shift = randO[omp_get_thread_num()].Normal() * hlen;
	 if( shift > range ) shift = range;
	 else if( shift < -range ) shift = -range;
	 float valnew = valold + shift;
	 if( valnew >= ub ) { valnew = 2.*ub-valnew; }
	 else if( valnew < lb ) { valnew = 2.*lb-valnew; }
	 return valnew;
      }

      void Perturb( ModelInfo& minew ) {
	 if( ! (validS && validP) ) throw std::runtime_error("invalid");

	 minew.strike = Neighbour_Reflect(this->strike, Pstk, Cstk-Rstk, Cstk+Rstk);
	 while( minew.strike >= 360. ) minew.strike -= 360.;
	 while( minew.strike < 0. ) minew.strike += 360.;

	 float lb = Cdip-Rdip, ub = Cdip+Rdip;
	 if( lb < 0. ) lb = 0.;
	 if( ub > 90. ) ub = 90.;
	 minew.dip = Neighbour_Reflect(this->dip, Pdip, lb, ub);

	 minew.rake = Neighbour_Reflect(this->rake, Prak, Crak-Rrak, Crak+Rrak);
	 while( minew.rake >= 180. ) minew.rake -= 360.;
	 while( minew.rake < -180. ) minew.rake += 360.;

	 lb = Cdep-Rdep; ub = Cdep+Rdep;
	 if( lb < 0. ) lb = 0.;
	 minew.depth = Neighbour_Reflect(this->depth, Pdep, lb, ub);

	 minew.lon = Neighbour_Reflect(this->lon, Plon, Clon-Rlon, Clon+Rlon);

	 minew.lat = Neighbour_Reflect(this->lat, Plat, Clat-Rlat, Clat+Rlat);

	 minew.t0 = Neighbour_Reflect(this->t0, Ptim, Ctim-Rtim, Ctim+Rtim);
      }

   private:
      bool validS, validP;
      float Clon, Clat, Ctim, Cstk, Cdip, Crak, Cdep; // model center
      float Rlon, Rlat, Rtim, Rstk, Rdip, Rrak, Rdep; // model param radius
      float Plon, Plat, Ptim, Pstk, Pdip, Prak, Pdep; // perturb length ( gaussian half length )
      std::vector<Rand> randO;
};


template < class T >
struct SearchInfo {
   int isearch;
   float E;
   T info;
};

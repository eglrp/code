#ifndef RADPATTERN_H
#define RADPATTERN_H

#include <cmath>
#include <memory>
#include <iostream>
#include <iomanip>
#include <vector>
#include <string>


/* ---------- exceptions ---------- */
//#define FuncName __PRETTY_FUNCTION__
#define FuncName __FUNCTION__
namespace ErrorRP {
   class BadFile : public std::runtime_error {
   public:
      BadFile(const std::string funcname, const std::string info = "")
	 : runtime_error("Error("+funcname+"): Cannot access file ("+info+").") {}
   };

   class BadParam : public std::runtime_error {
   public:
      BadParam(const std::string funcname, const std::string info = "")
        : runtime_error("Error("+funcname+"): Bad parameters ("+info+").") {}
   };

   class BadAzi : public std::runtime_error {
   public:
      BadAzi(const std::string funcname, const std::string info = "")
        : runtime_error("Error("+funcname+"): Unexpected azimuths ("+info+").") {}
   };

   class BadBuff : public std::runtime_error {
   public:
      BadBuff(const std::string funcname, const std::string info = "")
        : runtime_error("Error("+funcname+"): Internal buffer modified ("+info+"). The RadPattern class is not yet thread-safe!") {}
   };

};



template< class T >
struct FocalInfo {
   T strike, dip, rake, depth;

   FocalInfo( T strikein = 180, T dipin = 45, T rakein = 0, T depthin = 10 )
      : strike(strikein), dip(dipin), rake(rakein), depth(depthin) {}

   friend std::ostream& operator<< ( std::ostream& o, const FocalInfo& f ) {
      o.precision(6);
      o<<std::setw(6)<<f.strike<<" "<<std::setw(6)<<f.dip<<" "<<std::setw(6)<<f.rake<<"  "<<std::setw(6)<<f.depth; 
      return o; 
   }

   friend bool operator== ( FocalInfo<T>& fi1, FocalInfo<T>& fi2 ) {
      T dis_st = fabs(fi1.strike - fi2.strike);
      T dis_di = fabs(fi1.dip - fi2.dip);
      T dis_ra = fabs(fi1.rake - fi2.rake);
      T dis_de = fabs(fi1.depth - fi2.depth);
      return (dis_st<0.1 && dis_di<0.1 && dis_ra<0.1 && dis_de<0.1);
   }

};

typedef float ftype;


struct AziData {
   bool valid;
   float azi;
   float misG, varG;
   float misP, varP;
   float A, varA;
   AziData()
      : azi(-12345.), misG(-12345.), misP(-12345.), A(-12345.) 
      , valid(false), varG(-12345.), varP(-12345.), varA(-12345.) {}

   AziData( float aziin, float misGin, float misPin, float ampin )
      : azi(aziin), misG(misGin), misP(misPin), A(ampin)
      , valid(true), varG(-12345.), varP(-12345.), varA(-12345.) {}

   friend std::ostream& operator<< ( std::ostream& o, const AziData& ad ) {
      o<<"( "<<ad.azi<<"  "<<ad.misG<<" "<<ad.varG<<"  "<<ad.misP<<" "<<ad.varP
       <<"  "<<ad.A<<" "<<ad.varA<<" )";
      return o;
   }

};


class RadPattern {
   struct Rimpl;
   std::unique_ptr<Rimpl> pimplR;

public:
   RadPattern();
   ~RadPattern();

   /* Predict Rayleigh wave radiation patterns */
   void Predict( char type, const std::string& feigname, const std::string& fphvname, const FocalInfo<ftype>&
		 finfo, const std::vector<float>& perlst, std::vector< std::vector<AziData> >& per_azi_pred );

};

#endif

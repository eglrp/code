#include "FocalSearcher.h"
#include "RadPattern.h"
#include <cstdio>
#include <unistd.h>
#include <cstring>
#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <algorithm>
//#include <functional>
//#include <sys/inotify.h>
//#include <omp.h>
#include "MyOMP.h"


struct FocalSearcher::FSimpl {

   FocalInfo<ftype> finfo, finfoold;
   std::string outname_mis;
   std::string fReigname, fRphvname;
   std::string fLeigname, fLphvname;
   bool rflag, lflag; // determine measurement type(s) to be used in the search
   std::vector<PerDazi> perRlist, perLlist;
   /* It's perfectly OK to use vector of vector here as the data for each
    * period are accessed independently. Consider changing to Array2D if 
    * the access pattern is changed somehow */
   std::vector< std::vector<AziData> > per_R_azi_data, per_L_azi_data;

   /* obj that predicts radiation patterns.
    * use 2 separate RadPattern objects for R and L data to reduce readings of feig&fphv from the disk */
   RadPattern rpR, rpL;

   double AfactorR, AfactorL;

   /* obj that generates random numbers 
    * To obtain correct randomless this obj has to be created instead of using the Rand() class locally */
   Rand randO;


   FSimpl() 
      : AfactorR(-12345.), AfactorL(-12345.) {}
   FSimpl( const FocalInfo<ftype>& finfoin,
	   const std::vector<PerDazi>& perRlistin, 
	   const std::vector<PerDazi>& perLlistin, 
	   const std::vector< std::vector<AziData> >& per_R_azi_datain,
	   const std::vector< std::vector<AziData> >& per_L_azi_datain,
	   const char* fReignamein, const char* fRphvnamein,
	   const char* fLeignamein, const char* fLphvnamein ) 
      : finfo(finfoin)
      , perRlist(perRlistin), per_R_azi_data(per_R_azi_datain) 
      , perLlist(perLlistin), per_L_azi_data(per_L_azi_datain) 
      , fReigname(fReignamein), fRphvname(fRphvnamein)
      , fLeigname(fLeignamein), fLphvname(fLphvnamein)
      , rflag(false), lflag(false)
      , AfactorR(-12345.), AfactorL(-12345.) {}
   ~FSimpl() {}

   inline bool AziFactor( AziData& dat_l, AziData& dat_m, AziData& dat_h, float& azifactor ) {
      float azi_l = dat_l.azi, azi_m = dat_m.azi, azi_h = dat_h.azi;
      if( azi_m == azi_l ) { azifactor = 0.; return true; }
      if( azi_m == azi_h ) { azifactor = 1.; return true; }
      if( azi_l > azi_h ) {
	 azi_h += 360.;
	 if( azi_m < azi_l ) azi_m += 360.;
      }
      if( azi_l>azi_m || azi_m>azi_h ) return false;
      azifactor = (dat_m.azi - dat_l.azi) / (dat_h.azi - dat_l.azi);
      return true;
   }

   void MisfitS( AziData& dat, AziData& predl, AziData& predh, float per,
		  std::vector<float>& misGV, std::vector<float>& weitGV, 
		  std::vector<float>& misPV, std::vector<float>& weitPV,
		  std::vector<float>& misAV, std::vector<float>& weitAV ) {
      float misG, misP, A;
      if( predl.azi != predh.azi ) {
         float factor = (dat.azi-predl.azi)/(predh.azi-predl.azi);
         misG = predl.misG + (predh.misG-predl.misG) * factor;
         misP = predl.misP + (predh.misP-predl.misP) * factor;
         A = predl.A + (predh.A-predl.A) * factor;
      }
      else { misG = predl.misG; misP = predl.misP; A = predl.A; }
      //abs misfit
      float mis1 = dat.misG-misG, mis2 = dat.misP-misP, mis3 = dat.A-A;
      float pero2 = 0.5 * per;
      //correct misP for 2pis
      while( mis2 > pero2 ) mis2 -= per;
      while( mis2 < -pero2 ) mis2 += per;
//if(per==10) std::cerr<<dat.azi<<" "<<mis3<<"    "<<dat.A<<" "<<A<<std::endl;
      //chi-square
      if( dat.misG!=-12345. ) { misGV.push_back( mis1*mis1 ); weitGV.push_back( 1./dat.varG ); }
      if( dat.misP!=-12345. ) { misPV.push_back( mis2*mis2 ); weitPV.push_back( 1./dat.varP ); }
      if( dat.A   !=-12345. ) { misAV.push_back( mis3*mis3 ); weitAV.push_back( 1./dat.varA ); }
//std::cerr<<mis1*mis1<<" "<<1./dat.varG<<"   "<<mis2*mis2<<" "<<1./dat.varP<<"   "<<mis3*mis3<<" "<<1./dat.varA<<std::endl;
      //mis1 = mis1*mis1/dat.varG; mis2 = mis2*mis2/dat.varP; mis3 = mis3*mis3/dat.varA;
      //return mis1*0.35+mis2*0.35+mis3*0.3;
   }

   bool Accept(float E, float Enew, double T) {
      /*
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
      std::default_random_engine generator (timeseed);
      std::uniform_real_distribution<float> distribution(0., 1.);
      auto rand = std::bind ( distribution, generator );
      */
      if(Enew<E) return true;
      if(randO.Uniform()<exp((E-Enew)/T)) return true;
      return false;
   }

   inline ftype Neighbour_Cycle( ftype valold, float hlen, float lb, float ub ) {
      ftype valnew = valold + randO.Normal()*hlen;
      while( valnew >= ub ) { valnew -= (ub-lb); }
      while( valnew < lb ) { valnew += (ub-lb); }
      return valnew;
   }
   inline ftype Neighbour_Reflect( ftype valold, float hlen, float lb, float ub ) {
      float range = ub - lb;
      ftype shift = randO.Normal() * hlen;
      if( shift > range ) shift = range;
      else if( shift < -range ) shift = -range;
      ftype valnew = valold + shift;
      if( valnew >= ub ) { valnew = 2.*ub-valnew; }
      else if( valnew < lb ) { valnew = 2.*lb-valnew; }
      return valnew;
   }
   FocalInfo<ftype> Neighbour( const FocalInfo<ftype>& finfo ) {
      /*
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
      //std::default_random_engine generator1 (timeseed);
      // random number generator 2. (apply different generator type to avoid correlated random numbers!!!)
      std::mt19937 generator2 (timeseed);
      std::normal_distribution<double> distributionN(0.0,1.0);
      auto randnorm = std::bind ( distributionN, generator2 );
      */

      FocalInfo<ftype> finfonew;// = finfo;

      float hstrike = 36., hdip = 9, hrake = 36.;
      int depthmax = 50;
      float hdep = depthmax * 0.1;

      // perturb strike
      finfonew.strike = Neighbour_Cycle(finfo.strike, hstrike, 0., 360.);
      // perturb dip
      finfonew.dip = Neighbour_Reflect(finfo.dip, hdip, 0., 90.);
      // perturb rake
      finfonew.rake = Neighbour_Cycle(finfo.rake, hrake, -180., 180.);
      // perturb dep
      finfonew.depth = Neighbour_Reflect(finfo.depth, hdep, 0., depthmax);

      return finfonew;
   }

   bool ExcludeLarge( std::vector<float>& data, std::vector<float>& weight ) {
      if( data.size() != weight.size() ) return false;
      // compute mean 1
      float V1 = 0., mean1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 mean1 += data[i] * weight[i];
	 V1 += weight[i];
      }
      mean1 /= V1;
      // compute std1
      float V2 = 0., std1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 float ftmp = data[i]-mean1;
	 std1 += ftmp * ftmp * weight[i];
	 V2 += weight[i] * weight[i];
      }
      std1 = sqrt( std1 * V1 / (V1*V1-V2) );
      // exclude larger-than-2sigma data
      float ubound = mean1 + 2.0*std1;// lbound = mean1 - 2.0*std1;
      //for(int i=0; i<data.size();) { // does this work always?
      int i=0;
      while( i < data.size() ) {
	 if( data[i]>ubound ) {
	    data.erase( data.begin() + i );
	    weight.erase( weight.begin() + i );
	 }
	 else i++;
      }

      return true;
   }

   bool ExcludeBad( std::vector<float>& data, std::vector<float>& weight ) {
      if( data.size() != weight.size() ) return false;
      // compute mean 1
      float V1 = 0., mean1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 mean1 += data[i] * weight[i];
	 V1 += weight[i];
      }
      mean1 /= V1;
      // compute std1
      float V2 = 0., std1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 float ftmp = data[i]-mean1;
	 std1 += ftmp * ftmp * weight[i];
	 V2 += weight[i] * weight[i];
      }
      std1 = sqrt( std1 * V1 / (V1*V1-V2) );
      // exclude out-of-2sigma data
      float ubound = mean1 + 2.0*std1, lbound = mean1 - 2.0*std1;
      //for(int i=0; i<data.size();) { // does this work always?
      int i=0;
      while( i < data.size() ) {
	 if( data[i]>ubound || data[i]<lbound ) {
	    data.erase( data.begin() + i );
	    weight.erase( weight.begin() + i );
	 }
	 else i++;
      }

      return true;
   }

   void ReValidate( std::vector< std::vector<AziData> >& data ) {
      for( int iper=0; iper<data.size(); iper++ ) {
	 std::vector<AziData>& data_cur = data[iper];
	 for( int ipred=0; ipred < data_cur.size(); ipred++ ) {
	    AziData &adtmp = data_cur[ipred];
	    if( ! adtmp.valid ) continue;
	    if( adtmp.misG==-12345 || adtmp.misP==-12345 || adtmp.A==-12345 ) adtmp.valid = false;
	    else if( adtmp.A < 0.01 ) {
		int jpredlow = ipred, jpredhigh = ipred;
		while( jpredlow>0 && data_cur[jpredlow].azi>adtmp.azi-8. ) jpredlow--;
		while( jpredhigh<data_cur.size() && data_cur[jpredhigh].azi<adtmp.azi+8. ) jpredhigh++;
		for(int jpred=jpredlow; jpred<jpredhigh; jpred++) data_cur[jpred].valid = false;
	    }
	 }
      }
   }


   inline static bool CompareAziA( AziData sta1, AziData sta2 ) { return (sta1.azi<sta2.azi); }
   void ReScale( std::vector< std::vector<AziData> >& data, std::vector< std::vector<AziData> >& datapred, double& Ampfactor ) {
      if( data.size() != datapred.size() ) throw ErrorFS::SizeMismatch(FuncName, "data - datapred");

      /* compute the scaling factor&weight on each data point */
      double F_sum = 0., W_sum = 0.;
      for(int iper=0; iper<data.size(); iper++) {
	 std::vector<AziData>& data_V = data[iper];
	 std::vector<AziData>& datapred_V = datapred[iper];
	 std::vector<float> ampfactor, weight;
	 for( int idat=0; idat < data_V.size(); idat++ ) {
	    // find predictions that bounds the current data
	    AziData& data_cur = data_V[idat];
	    if( (!data_cur.valid) || (data_cur.A==-12345.) ) continue;
	    std::vector<AziData>::iterator iter_predl, iter_predh;
	    int ipredh = std::lower_bound( datapred_V.begin(), datapred_V.end(), data_cur, CompareAziA ) - datapred_V.begin();
	    int ipredl = ipredh==0 ? datapred_V.size()-1 : ipredh - 1;
	    if( ipredh == datapred_V.size() ) ipredh = 0;
	    if( (!datapred_V[ipredl].valid) || (!datapred_V[ipredh].valid) ) continue;
	    // interpolate for amplitude prediction
	    float azifactor;// = (data_cur.azi - datapred_V[ipredl].azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
	    if( ! AziFactor(datapred_V[ipredl], data_cur, datapred_V[ipredh], azifactor) ) {
		std::string info = std::to_string(datapred_V[ipredl].azi) + " - " +
				   std::to_string(data_cur.azi) + " - " + std::to_string(datapred_V[ipredh].azi);
		throw ErrorFS::BadAzi(FuncName, info);
	    }
	    float amp_pred = datapred_V[ipredl].A + (datapred_V[ipredh].A-datapred_V[ipredl].A)  * azifactor;
	    ampfactor.push_back( data_cur.A / amp_pred );
	    weight.push_back( 1. ); // 1./data_cur.varA; // converges much slower with weight=1./Var!
	 }
	 for(int i=0; i<NEX; i++) 
	    if( ! ExcludeBad( ampfactor, weight ) ) throw ErrorFS::SizeMismatch(FuncName, "ampfactor - weight");
	 for(int idat=0; idat<ampfactor.size(); idat++) {
	    F_sum += ampfactor[idat] * weight[idat];
	    W_sum += weight[idat];
	 }
      }
      Ampfactor = F_sum / W_sum;
      // rescale data to order of dataref
      double factor2 = Ampfactor*Ampfactor;
      for( int iper=0; iper<datapred.size(); iper++ ) {
	 std::vector<AziData>& data_cur = datapred[iper];
	 for( int ipred=0; ipred < data_cur.size(); ipred++ ) {
	    if( data_cur[ipred].valid ) {
		data_cur[ipred].A *= Ampfactor;
		data_cur[ipred].varA *= factor2;
	    }
	 }
      }
   }

   void ComputeMisfits( std::vector<float> perlst, float weightin, std::vector< std::vector<AziData> >& data,
			std::vector< std::vector<AziData> >& datapred, float& Esum, float& Wsum, int& N ) {
      // check input data size
      if( perlst.size() != data.size() ) throw ErrorFS::SizeMismatch(FuncName, "perlst - data");
      if( data.size() != datapred.size() ) throw ErrorFS::SizeMismatch(FuncName, "data - datapred");

      // misfits
      for( int iper=0; iper<data.size(); iper++ ) {
	 // compute misfits for the current period and store them into vectors
         std::vector<float> misGV, misPV, misAV, weitGV, weitPV, weitAV;
	 std::vector<AziData>& data_cur = data[iper];
	 std::vector<AziData>& datapred_cur = datapred[iper];
	 // figure out dazi of predicted data
	 int ipred;
	 for(ipred=1; ipred<datapred_cur.size(); ipred++) {
	    if( datapred_cur[ipred].valid && datapred_cur[ipred-1].valid ) break;
	 }
	 if( ipred >= datapred_cur.size() ) {
	    WarningFS::Other(FuncName, "invalid radpattern predictions!");
            continue;
	 }
	 float dazi = datapred_cur.at(ipred).azi - datapred_cur.at(ipred-1).azi;
	 for( int idata=0; idata<data_cur.size(); idata++ ) {
 	    AziData adtmp = data_cur[idata];
	    if( ! adtmp.valid ) { continue; }
	    int ninvalid = 0;
	    int ipredlow = (int)floor(adtmp.azi/dazi);
	    while( ipredlow>=0 && (!datapred_cur[ipredlow].valid) ) { ipredlow--; ninvalid++; }
	    int ipredhigh = (int)ceil(adtmp.azi/dazi);
	    while( ipredhigh<datapred_cur.size() && (!datapred_cur[ipredhigh].valid) ) { ipredhigh++; ninvalid++; }
	    if( ipredlow < 0 || ipredhigh >= datapred_cur.size() || ninvalid>5 ) continue;
	    MisfitS( adtmp, datapred_cur[ipredlow], datapred_cur[ipredhigh], perlst.at(iper), misGV, weitGV, misPV, weitPV, misAV, weitAV );
         }
	 // check if there're enough misfits
	 if( misGV.size() < MIN_AZI_SIZE || misPV.size() < MIN_AZI_SIZE || misAV.size() < MIN_AZI_SIZE ) {
	    WarningFS::Other(FuncName, "no enough data point for the current period!");
	    continue;
	 } else { // exclude bad data and compute chi-squre misfit
	    //std::vector<float> weit( misV.size(), 1. );
	    for(int i=0; i<NEX; i++) 
		if( ! ExcludeLarge( misGV, weitGV ) ) throw ErrorFS::SizeMismatch(FuncName, "misGV - weitGV");
	    for(int i=0; i<NEX; i++) 
		if( ! ExcludeLarge( misPV, weitPV ) ) throw ErrorFS::SizeMismatch(FuncName, "misPV - weitPV");
	    for(int i=0; i<NEX; i++) 
		if( ! ExcludeLarge( misAV, weitAV ) ) throw ErrorFS::SizeMismatch(FuncName, "misAV - weitAV");
	    for(int idat=0; idat<misGV.size(); idat++) { float wtmp=weitGV[idat]*weightin; Esum+=misGV[idat]*wtmp; Wsum+=wtmp; }// std::cerr<<"weitG = "<<wtmp<<"  misG = "<<misGV[idat]<<std::endl;}
	    for(int idat=0; idat<misPV.size(); idat++) { float wtmp=weitPV[idat]*weightin; Esum+=misPV[idat]*wtmp; Wsum+=wtmp; }// std::cerr<<"weitP = "<<wtmp<<"  misP = "<<misPV[idat]<<std::endl;}
	    for(int idat=0; idat<misAV.size(); idat++) { float wtmp=weitAV[idat]*weightin; Esum+=misAV[idat]*wtmp; Wsum+=wtmp; }// std::cerr<<"weitA = "<<wtmp<<"  misA = "<<misAV[idat]<<std::endl;}
	    N += (misGV.size() + misPV.size() + misAV.size());
//	    float Ecur=0., Wcur=0.;
//	    for(int idat=0; idat<misGV.size(); idat++) { Ecur += misGV[idat]*weitGV[idat]; Wcur += weitGV[idat]; }
//	    for(int idat=0; idat<misPV.size(); idat++) { Ecur += misPV[idat]*weitPV[idat]; Wcur += weitPV[idat]; }
//	    for(int idat=0; idat<misAV.size(); idat++) { Ecur += misAV[idat]*weitAV[idat]; Wcur += weitAV[idat]; }
//	    Esum += Ecur/Wcur; Wsum += 1;
         }
      }
   }

};


FocalSearcher::FocalSearcher()
   : pimplFS(new FSimpl) {}

FocalSearcher::FocalSearcher( const FocalInfo<ftype> &finfoin,
			      const std::vector<PerDazi> &perRlistin, 
			      const std::vector<PerDazi> &perLlistin, 
			      const std::vector< std::vector<AziData> > &per_R_azi_data_in,
			      const std::vector< std::vector<AziData> > &per_L_azi_data_in,
			      const char *fReignamein, const char *fRphvnamein,
			      const char *fLeignamein, const char *fLphvnamein )
   : pimplFS(new FSimpl(finfoin, perRlistin, perLlistin, per_R_azi_data_in, per_L_azi_data_in,
			fReignamein, fRphvnamein, fLeignamein, fLphvnamein) ) {
   // check input data size
   int Rsize = pimplFS->perRlist.size(), Lsize = pimplFS->perLlist.size();
   if( Rsize==0 && Lsize==0 ) {
      std::cerr<<"Error(FocalSearcher::FocalSearcher): Empty data input!"<<std::endl;
      exit(0);
   }
   if( Rsize != pimplFS->per_R_azi_data.size() ||
       Lsize != pimplFS->per_L_azi_data.size() ) {
      std::cerr<<"Error(FocalSearcher::FocalSearcher): size of perlist and per_azi_data doesn't match!"<<std::endl;
      exit(0);
   }

   // azi size R
   for(int iper=0; iper<Rsize; iper++) { 
      int nazi = 0;
      for(int iazi=0; iazi<pimplFS->per_R_azi_data.at(iper).size(); iazi++) {
	 if( pimplFS->per_R_azi_data[iper][iazi].valid ) nazi++;
      }
      if( nazi < MIN_AZI_SIZE ) {
	 pimplFS->perRlist.erase( pimplFS->perRlist.begin() + iper );
	 pimplFS->per_R_azi_data.erase( pimplFS->per_R_azi_data.begin() + iper );
      }
   }
   // azi size L
   for(int iper=0; iper<Lsize; iper++) { 
      int nazi = 0;
      for(int iazi=0; iazi<pimplFS->per_L_azi_data.at(iper).size(); iazi++) {
	 if( pimplFS->per_L_azi_data[iper][iazi].valid ) nazi++;
      }
      if( nazi < MIN_AZI_SIZE ) {
	 pimplFS->perLlist.erase( pimplFS->perLlist.begin() + iper );
	 pimplFS->per_L_azi_data.erase( pimplFS->per_L_azi_data.begin() + iper );
      }
   }
   Rsize = pimplFS->perRlist.size();
   Lsize = pimplFS->perLlist.size();

   if( Rsize==0 && Lsize==0 ) {
      std::cerr<<"Error(FocalSearcher::FocalSearcher): data matrix is empty after erasing!"<<std::endl;
      exit(0);
   }

   // insert sort perlist and per_azi_data for R
   for(int i=1; i<Rsize; i++) {
      if( pimplFS->perRlist.at(i).per >= pimplFS->perRlist.at(i-1).per ) continue;
      PerDazi pdtmp = pimplFS->perRlist[i];
      std::vector<AziData> Vadtmp = pimplFS->per_R_azi_data.at(i);
      int j;
      for(j=i; j>0 && pdtmp.per<pimplFS->perRlist.at(j-1).per; j--) {
	 pimplFS->perRlist.at(j) = pimplFS->perRlist.at(j-1);
	 pimplFS->per_R_azi_data.at(j) = pimplFS->per_R_azi_data.at(j-1);
      }
      pimplFS->perRlist.at(j) = pdtmp;
      pimplFS->per_R_azi_data.at(j) = Vadtmp;
   }
   // insert sort perlist and per_azi_data for L
   for(int i=1; i<Lsize; i++) {
      if( pimplFS->perLlist.at(i).per >= pimplFS->perLlist.at(i-1).per ) continue;
      PerDazi pdtmp = pimplFS->perLlist[i];
      std::vector<AziData> Vadtmp = pimplFS->per_L_azi_data.at(i);
      int j;
      for(j=i; j>0 && pdtmp.per<pimplFS->perLlist.at(j-1).per; j--) {
	 pimplFS->perLlist.at(j) = pimplFS->perLlist.at(j-1);
	 pimplFS->per_L_azi_data.at(j) = pimplFS->per_L_azi_data.at(j-1);
      }
      pimplFS->perLlist.at(j) = pdtmp;
      pimplFS->per_L_azi_data.at(j) = Vadtmp;
   }

}

FocalSearcher::~FocalSearcher() {}


const FocalInfo<ftype>& FocalSearcher::FInfo() const { return pimplFS->finfo; }
      FocalInfo<ftype>& FocalSearcher::FInfo() { return pimplFS->finfo; }
const FocalInfo<ftype>& FocalSearcher::FInfoOld() const { return pimplFS->finfoold; }
      FocalInfo<ftype>& FocalSearcher::FInfoOld() { return pimplFS->finfoold; }

const bool& FocalSearcher::RFlag() const { return pimplFS->rflag; }
      bool& FocalSearcher::RFlag() { return pimplFS->rflag; }
const bool& FocalSearcher::LFlag() const { return pimplFS->lflag; }
      bool& FocalSearcher::LFlag() { return pimplFS->lflag; }

const double& FocalSearcher::AFactorR() const {return pimplFS->AfactorR; }
      double& FocalSearcher::AFactorR() {return pimplFS->AfactorR; }
const double& FocalSearcher::AFactorL() const {return pimplFS->AfactorL; }
      double& FocalSearcher::AFactorL() {return pimplFS->AfactorL; }

const std::string& FocalSearcher::FMisF() const { return pimplFS->outname_mis; }
      std::string& FocalSearcher::FMisF() { return pimplFS->outname_mis; }

const std::string& FocalSearcher::FREigName() const { return pimplFS->fReigname; }
      std::string& FocalSearcher::FREigName() { return pimplFS->fReigname; }
const std::string& FocalSearcher::FRPhvName() const { return pimplFS->fRphvname; }
      std::string& FocalSearcher::FRPhvName() { return pimplFS->fRphvname; }

const std::string& FocalSearcher::FLEigName() const { return pimplFS->fLeigname; }
      std::string& FocalSearcher::FLEigName() { return pimplFS->fLeigname; }
const std::string& FocalSearcher::FLPhvName() const { return pimplFS->fLphvname; }
      std::string& FocalSearcher::FLPhvName() { return pimplFS->fLphvname; }

const std::vector<PerDazi>& FocalSearcher::PerRList() const { return pimplFS->perRlist; }
      std::vector<PerDazi>& FocalSearcher::PerRList() { return pimplFS->perRlist; }
const std::vector< std::vector<AziData> >& FocalSearcher::Per_R_Azi_Data() const { return pimplFS->per_R_azi_data; }
      std::vector< std::vector<AziData> >& FocalSearcher::Per_R_Azi_Data() { return pimplFS->per_R_azi_data; }

const std::vector<PerDazi>& FocalSearcher::PerLList() const { return pimplFS->perLlist; }
      std::vector<PerDazi>& FocalSearcher::PerLList() { return pimplFS->perLlist; }
const std::vector< std::vector<AziData> >& FocalSearcher::Per_L_Azi_Data() const { return pimplFS->per_L_azi_data; }
      std::vector< std::vector<AziData> >& FocalSearcher::Per_L_Azi_Data() { return pimplFS->per_L_azi_data; }

/* search the focal info with a simulated annealing algorithm.
 * nsearch: number of search iterations
 * alpha: controls how fast temperature decays
 * Tfactor: factor of initial temperature */
void FocalSearcher::SearchFocal( int nsearch, float alpha, float Tfactor ) {
   // check input data size
   if( !RFlag() && !LFlag() ) throw ErrorFS::EmptyData(FuncName, "RFlag && LFlag");
   int Rsize = pimplFS->perRlist.size(), Lsize = pimplFS->perLlist.size();
   if( Rsize==0 && Lsize==0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
   if( Rsize!=pimplFS->per_R_azi_data.size() || Lsize!=pimplFS->per_L_azi_data.size() )
      throw ErrorFS::SizeMismatch(FuncName, "pimplFS->per_R_azi_data - pimplFS->per_L_azi_data");
//    || pimplFS->feigname.empty() || pimplFS->fphvname.empty() ) return false;
   // simulated annealing parameters
   float E;
   //pimplFS->finfo = FocalInfo( 217, 34, -88, 11 );
   // start search
   double Af_best_R, Af_best_L;
   EnergyF(pimplFS->finfo, E, Af_best_R, Af_best_L);
   // save old focal info
   pimplFS->finfoold = pimplFS->finfo;
   //int nsearch = 20000;
   float T = E * Tfactor;// alpha=0.999;
   std::cout<<"### SearchFocal: Initial Misfit**2 for "<<pimplFS->finfo<<" = "<<E<<" T="<<T<<" ###"<<std::endl;
   FocalInfo<ftype> finfobest = pimplFS->finfo;
   float Ebest = E;
   int nrej = 0;
   int isearch = 0;
   std::ofstream fout;
   bool output_mis = ! pimplFS->outname_mis.empty();
   if( output_mis ) fout.open(  pimplFS->outname_mis.c_str(), std::ofstream::app );
   fout<<"# [ focal = "<<FInfo()<<" ]"<<std::endl;
   fout<< "-1\t" << E << "\t" << T << std::endl;
   char type = RFlag()&&LFlag() ? 'B' : (RFlag()?'R':'L');
   #pragma omp parallel for schedule (dynamic, 1)
   for( int i=0; i<nsearch; i++ ) {
      FocalInfo<ftype> finfonew = pimplFS->Neighbour( pimplFS->finfo );
      float Enew = -12345.; 
      double AfactorR = 1., AfactorL = 1.;
      EnergyF( finfonew, Enew, AfactorR, AfactorL );
      if( pimplFS->Accept(E, Enew, T) ) {
	 pimplFS->finfo = finfonew;
	 E = Enew;
	 if( output_mis ) {
	#pragma omp critical
	{ // critical start
	    fout<< std::setw(4)<<isearch << " " << std::setw(8)<<Enew << " " 
		<< std::setw(8)<<T << "\t" << pimplFS->finfo << std::endl;
	    fout.flush();
	} // critical end
	 }
         std::cout<<"   Misfit**2 for "<<finfonew<<" = "<<Enew<<" (accepted)  T="
		  <<T<<"  isearch="<<isearch<<"/"<<nsearch<<"  type="<<type<<std::endl;
	 nrej = 0;
      }
      else { nrej++; std::cout<<"( nrejects = "<<nrej<<" )"<<"  ithread="<<omp_get_thread_num()<<"                 "<<std::endl<<"\x1b[A"; }
     #pragma omp critical
     { // critical start
      T *= alpha;
      if( Enew < Ebest ) {
	 finfobest = finfonew;
	 Ebest = Enew;
	 Af_best_R = AfactorR;
	 Af_best_L = AfactorL;
      }
      isearch++;
     } // critical end
   }
   fout<< isearch << "\t" << Ebest << "\t" << T << "\t" << finfobest << std::endl;
   fout<<std::endl<<std::endl; fout.close();
   std::cout<<"                                   "<<std::endl;
   pimplFS->finfo = finfobest; 
   pimplFS->AfactorR = Af_best_R;
   pimplFS->AfactorL = Af_best_L;
}

void FocalSearcher::EnergyF( const FocalInfo<ftype>& finfo, float& E, double& AfactorR, double& AfactorL ) {
   int N;
   float chiS, wSum;
   FocalSearcher::chiSquareF(pimplFS->per_R_azi_data, pimplFS->perRlist, pimplFS->per_L_azi_data, pimplFS->perLlist,
			     finfo, chiS, wSum, N, AfactorR, AfactorL);
   if( N < MIN_AZI_SIZE ) 
      throw ErrorFS::InsufData(FuncName, "N="+std::to_string(N)+" < "+std::to_string(MIN_AZI_SIZE));
   //E = chiS / wSum;
   E = chiS / (N-5.); // reduced chi-square
}
void FocalSearcher::chiSquareF( std::vector< std::vector<AziData> >& Rdata, std::vector<PerDazi>& perRlist,
				std::vector< std::vector<AziData> >& Ldata, std::vector<PerDazi>& perLlist,
				const FocalInfo<ftype>& finfo, float& chiS, float& wSum, int& N, 
				double& AfactorR, double& AfactorL ) {
   // check feigname & fphvname accessibilities
   int Rsize = perRlist.size(), Lsize = perLlist.size();
   if( Rsize > 0 ) {
      if( access( pimplFS->fReigname.c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, pimplFS->fReigname);
      if( access( pimplFS->fRphvname.c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, pimplFS->fRphvname);
   }
   if( Lsize > 0 ) {
      if( access( pimplFS->fLeigname.c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, pimplFS->fLeigname);
      if( access( pimplFS->fLphvname.c_str(), F_OK) == -1 ) throw ErrorFS::BadFile(FuncName, pimplFS->fLphvname);
   }

   // chi-square total and weight
   chiS = 0.; wSum = 0.; N = 0;
   // chi-square misfit from Rayleigh wave
   if( Rsize > 0 && RFlag() ) {
      // perlst from perlist
      std::vector<float> perRlst;
      for(int i=0; i<perRlist.size(); i++) perRlst.push_back(perRlist[i].per);

      // initialize prediction matrix
      std::vector< std::vector<AziData> > per_R_azi_pred;

      // run rad_pattern_r
      pimplFS->rpR.Predict( 'R', pimplFS->fReigname, pimplFS->fRphvname, finfo, perRlst, per_R_azi_pred );

      // invalidate incomplete azimuths and points around 0 amplitudes
      pimplFS->ReValidate( per_R_azi_pred );

      // rescale predicted amplitude by observed average
      pimplFS->ReScale( Rdata, per_R_azi_pred, AfactorR );

      // compute misfit at each period
      pimplFS->ComputeMisfits( perRlst, weightR_Foc, Rdata, per_R_azi_pred, chiS, wSum, N );
   }

   // chi-square misfit from Love wave
   if( Lsize > 0 && LFlag() ) {
      // perlst from perlist
      std::vector<float> perLlst;
      for(int i=0; i<perLlist.size(); i++) perLlst.push_back(perLlist[i].per);

      // initialize prediction matrix
      std::vector< std::vector<AziData> > per_L_azi_pred;

      // run rad_pattern_l
      pimplFS->rpL.Predict( 'L', pimplFS->fLeigname, pimplFS->fLphvname, finfo, perLlst, per_L_azi_pred );

      // invalidate incomplete azimuths and points around 0 amplitudes
      pimplFS->ReValidate( per_L_azi_pred );
 
      // rescale predicted amplitude by observed average
      pimplFS->ReScale( Ldata, per_L_azi_pred, AfactorL );

      // compute misfit at each period
      pimplFS->ComputeMisfits( perLlst, weightL_Foc, Ldata, per_L_azi_pred, chiS, wSum, N );
   }

   // final chi-square
   //E = ( ER + EL ) / ( nRvalid + nLvalid );
   //E = Esum / Wsum;

}



#include "FocalSearcher.h"
#include <cstdio>
#include <unistd.h>
#include <cstring>
#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <chrono>
#include <random>
#include <functional>
//#include <sys/inotify.h>
#include <omp.h>

#define MIN_AZI_SIZE 10
#define MAX_EVENTS 64 /*Max. number of events to process at one go*/

extern"C" {
   void rad_pattern_r_(char *feig_buff, int *eig_len, int *phvnper, int *phvdper,
                       float *strike, float *dip, float *rake, float *depth, float *per, int *nper,
                       float *azi, float grT[][181], float phT[][181], float amp[][181]);
}

struct FocalSearcher::FSimpl {

   FocalInfo finfo;
   std::string feigname, fphvname;
   std::vector<PerDazi> perlist;
   std::vector< std::vector<AziData> > per_azi_data;

   int phvnper, phvdper;
   int feig_len;
   char *feig_buff;

   FSimpl() { 
      phvnper = -12345; phvdper = -12345;
      feig_buff = NULL; feig_len = -12345; 
   }

   FSimpl( const FocalInfo& finfoin, const std::vector<PerDazi>& perlistin, 
	   const std::vector< std::vector<AziData> >& per_azi_datain,
	   const char* feignamein, const char* fphvnamein ) 
      : finfo(finfoin), perlist(perlistin), per_azi_data(per_azi_datain) 
      , feigname(feignamein), fphvname(fphvnamein) { 
      phvnper = -12345; phvdper = -12345;
      feig_buff = NULL; feig_len = -12345; 
   }
   ~FSimpl() { if(feig_buff) free(feig_buff); }

   float MisfitS( AziData& dat, AziData& predl, AziData& predh, float per ) {
      float misG, misP, A;
      if( predl.azi != predh.azi ) {
         float factor = (dat.azi-predl.azi)/(predh.azi-predl.azi);
         misG = predl.misG + (predh.misG-predl.misG) * factor;
         misP = predl.misP + (predh.misP-predl.misP) * factor;
         A = predl.A + (predh.A-predl.A) * factor;
      }
      else { misG = predl.misG; misP = predl.misP; A = predl.A; }
      //abs misfit
      float mis1 = dat.misG-misG, mis2 = dat.misP-misP, mis3 = dat.A-A;
    //if(per==20) std::cerr<<dat.azi<<" "<<mis1<<"  "<<dat.misG<<" "<<predl.misG<<" "<<predh.misG<<std::endl;
      //correct misP for 2pis
      mis2 = fabs(mis2);
      while( mis2 > per ) mis2 -= per;
      //chi-square
      mis1 = mis1*mis1/dat.varG; mis2 = mis2*mis2/dat.varP; mis3 = mis3*mis3/dat.varA;
      //std::cerr<<mis1<<" "<<dat.varG<<"  "<<mis2<<" "<<dat.varP<<"  "<<mis3<<" "<<dat.varA<<std::endl;
      //std::cerr<<mis1<<" "<<mis2<<" "<<mis3<<std::endl;
      return mis1*0.35+mis2*0.35+mis3*0.3;
   }

   bool Accept(float E, float Enew, double T) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
      std::default_random_engine generator (timeseed);
      std::uniform_real_distribution<float> distribution(0., 1.);
      auto rand = std::bind ( distribution, generator );
      if(Enew<E) return true;
      if(rand()<exp((E-Enew)/T)) return true;
      return false;
   }

   FocalInfo Neighbour( const FocalInfo& finfo ) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
/*
      // random number generator 1
      std::default_random_engine generator1 (timeseed);
      std::uniform_int_distribution<int> distributionU(0, 3);
      auto randintu3 = std::bind ( distributionU, generator1 );
*/
      // random number generator 2. (apply different generator type to avoid correlated random numbers!!!)
      std::mt19937 generator2 (timeseed);
      std::normal_distribution<double> distributionN(0.0,1.0);
      auto randnorm = std::bind ( distributionN, generator2 );
   
      FocalInfo finfonew = finfo;
      int depthmax = 60;

      float hstrike = 18, hdip = 4.5, hrake = 18;
      float hdep = depthmax * 0.05;

      // perturb strike
      finfonew.strike += (int)floor(randnorm()*hstrike+0.5);
      if( finfonew.strike < 0 ) finfonew.strike += 360;
      if( finfonew.strike >= 360 ) finfonew.strike -= 360;
      // perturb dip
      while( float dltdip = (int)floor(randnorm()*hdip+0.5) ) {
	 float dipnew = finfonew.dip + dltdip;
	 if( dipnew <= 90 && dipnew >= 0 ) {
	    finfonew.dip = dipnew;
	    break;
	 }
      }
      // perturb rake
      finfonew.rake += (int)floor(randnorm()*18+0.5);
      if( finfonew.rake < -180 ) finfonew.rake += 360;
      if( finfonew.rake > 180 ) finfonew.rake -= 360;
      // perturb dep
      while( float dltdep = (int)floor(randnorm()*hdep+0.5) ) {
	 float depnew = finfonew.depth + dltdep;
	 if( depnew < depthmax && depnew >= 0 ) {
	    finfonew.depth = depnew;
	    break;
	 }
      }

/*
      int shift = 0;
      switch( randintu3() ) {
         case 0:
	    while( shift == 0 ) shift = (int)floor(randnorm()*36+0.5);
	    finfonew.strike += shift;
	    if( finfonew.strike < 0 ) finfonew.strike += 360;
	    if( finfonew.strike >= 360 ) finfonew.strike -= 360;
	    break;
         case 1:
	    while( shift == 0 ) shift = (int)floor(randnorm()*9+0.5);
	    finfonew.dip += shift;
            if( finfonew.dip < 0 ) finfonew.dip = 0;
            if( finfonew.dip > 90 ) finfonew.dip = 90;
            break;
         case 2:
	    while( shift == 0 ) shift = (int)floor(randnorm()*36+0.5);
	    finfonew.rake += shift;
            if( finfonew.rake < -180 ) finfonew.rake += 360;
            if( finfonew.rake > 180 ) finfonew.rake -= 360;
            break;
         case 3:
	    while( shift == 0 ) shift = (int)floor(randnorm()*0.1*depthmax+0.5);
	    finfonew.depth += shift;
            if( finfonew.depth < 0 ) finfonew.depth = 0;
            if( finfonew.depth >= depthmax ) finfonew.depth = depthmax;
            break;
         defalut:
	    std::cerr<<"Error(Neighbour) !!!"<<std::endl;
	    exit(0);
      }
*/
      return finfonew;
   }

};


FocalSearcher::FocalSearcher()
   : pimplFS(new FSimpl) {}

FocalSearcher::FocalSearcher( const FocalInfo &finfoin, const std::vector<PerDazi> &perlistin, 
			      const std::vector< std::vector<AziData> > &per_azi_data_in,
			      const char *feignamein, const char *fphvnamein )
   : pimplFS(new FSimpl(finfoin, perlistin, per_azi_data_in, feignamein, fphvnamein) ) {
   // check per size
   if( pimplFS->perlist.size() != pimplFS->per_azi_data.size() ) {
      std::cerr<<"Error(FocalSearcher::FocalSearcher): size of perlist and per_azi_data doesn't match!"<<std::endl;
      exit(0);
   }

   // azi size
   for(int iper=0; iper<pimplFS->perlist.size(); iper++) { 
      int nazi = 0;
      for(int iazi=0; iazi<pimplFS->per_azi_data.at(iper).size(); iazi++) {
	 if( pimplFS->per_azi_data.at(iper).at(iazi).azi != -12345. ) nazi++;
      }
      if( nazi < MIN_AZI_SIZE ) {
	 pimplFS->perlist.erase( pimplFS->perlist.begin() + iper );
	 pimplFS->per_azi_data.erase( pimplFS->per_azi_data.begin() + iper );
      }
   }
   if( pimplFS->perlist.size() == 0 ) {
      std::cerr<<"Error(FocalSearcher::FocalSearcher): data matrix is empty after erasing!"<<std::endl;
      exit(0);
   }

   // insert sort perlist and per_azi_data
   //for(int i=0; i<perlist.size(); i++) std::cerr<<perlist.at(i).per<<" "<<per_azi_data.at(i).at(0).amp<<std::endl;
   for(int i=1; i<pimplFS->perlist.size(); i++) {
      if( pimplFS->perlist.at(i).per >= pimplFS->perlist.at(i-1).per ) continue;
      PerDazi pdtmp = pimplFS->perlist.at(i);
      std::vector<AziData> Vadtmp = pimplFS->per_azi_data.at(i);
      int j;
      for(j=i; j>0 && pdtmp.per<pimplFS->perlist.at(j-1).per; j--) {
	 pimplFS->perlist.at(j) = pimplFS->perlist.at(j-1);
	 pimplFS->per_azi_data.at(j) = pimplFS->per_azi_data.at(j-1);
      }
      pimplFS->perlist.at(j) = pdtmp;
      pimplFS->per_azi_data.at(j) = Vadtmp;
   }

}

FocalSearcher::~FocalSearcher() {}


const FocalInfo& FocalSearcher::FInfo() const { return pimplFS->finfo; }
      FocalInfo& FocalSearcher::FInfo() { return pimplFS->finfo; }


const std::string& FocalSearcher::FEigName() const { return pimplFS->feigname; }
      std::string& FocalSearcher::FEigName() { return pimplFS->feigname; }

const std::string& FocalSearcher::FPhvName() const { return pimplFS->fphvname; }
      std::string& FocalSearcher::FPhvName() { return pimplFS->fphvname; }

/* search the focal info with a simulated annealing algorithm.
 * nsearch: number of search iterations
 * alpha: controls how fast temperature decays
 * Tfactor: factor of initial temperature */
bool FocalSearcher::SearchFocal( int nsearch, float alpha, float Tfactor ) {
   // check input data
   if( pimplFS->perlist.size() == 0 || pimplFS->per_azi_data.size() == 0
    || pimplFS->feigname.empty() || pimplFS->fphvname.empty() ) return false;
   // simulated annealing parameters
   float E;
   //pimplFS->finfo = FocalInfo( 217, 34, -88, 11 );
   // start search
   if( ! Energy(pimplFS->finfo, E) ) return false;
   //int nsearch = 20000;
   float T = E * Tfactor;// alpha=0.999;
   std::cout<<"### SearchFocal: Initial Misfit**2 for "<<pimplFS->finfo<<" = "<<E<<" T="<<T<<" ###"<<std::endl;
   FocalInfo finfobest = pimplFS->finfo;
   float Ebest = E;
   int nrej = 0;
   int isearch = 0;
   #pragma omp parallel for
   for( int i=0; i<nsearch; i++ ) {
      FocalInfo finfonew = pimplFS->Neighbour( pimplFS->finfo );
      float Enew = -12345.;
      if( ! Energy( finfonew, Enew ) ) continue;//return false;
      if( pimplFS->Accept(E, Enew, T) ) {
	 pimplFS->finfo = finfonew;
	 E = Enew;
         std::cout<<"   Misfit**2 for "<<finfonew<<" = "<<Enew<<" (accepted)  T="
		  <<T<<"  isearch="<<isearch<<"/"<<nsearch<<std::endl;
	 nrej = 0;
      }
      else { nrej++; std::cout<<"( nrejects = "<<nrej<<" )"<<"  ithread="<<omp_get_thread_num()<<"   "<<std::endl<<"\x1b[A"; }
     #pragma omp critical
     { // critical start
      T *= alpha;
      if( Enew < Ebest ) {
	 finfobest = finfonew;
	 Ebest = Enew;
      }
      isearch++;
     } // critical end
   }
   pimplFS->finfo = finfobest;
}


bool FocalSearcher::RadPatternR( const std::string& feigname, const std::string& fphvname, const FocalInfo& finfo,
				 std::vector<float>& perlst, std::vector< std::vector<AziData> >& per_azi_pred ) {
   int nper = perlst.size();
   float strike = finfo.strike, dip = finfo.dip, rake = finfo.rake, depth = finfo.depth;
   float azi[181], grT[nper][181], phT[nper][181], amp[nper][181];

   // read feig into memory
   if( pimplFS->feig_buff == NULL ) {
      std::ifstream fin( feigname.c_str() );
      fin.seekg(0, std::ios::end);
      pimplFS->feig_len = fin.tellg();
      pimplFS->feig_buff = new char[pimplFS->feig_len];
      fin.seekg(0,std::ios::beg);
      fin.read(pimplFS->feig_buff, pimplFS->feig_len);
      fin.close();
   }

   // read in nper and dper from fphv
   if( pimplFS->phvnper < 0 )  {
      std::ifstream fin( fphvname.c_str() );
      pimplFS->phvnper = 0;
      for( std::string line; std::getline(fin, line); ) {
         float ftmp1, ftmp2, ftmp3;
         if( sscanf(line.c_str(), "%f %f %f", &ftmp1, &ftmp2, &ftmp3) != 3 ) continue;
         if( pimplFS->phvnper == 0 ) pimplFS->phvdper = ftmp1;
         else if( pimplFS->phvnper == 1 ) pimplFS->phvdper = ftmp1 - pimplFS->phvdper;
         (pimplFS->phvnper)++;
      }
      fin.close();
   }

   // run rad_pattern_r
   rad_pattern_r_( pimplFS->feig_buff, &(pimplFS->feig_len), &(pimplFS->phvnper), &(pimplFS->phvdper),
                   &(strike), &(dip), &(rake), &(depth), &(perlst.at(0)), &nper, azi, grT, phT, amp );

   for(int i=0; i<per_azi_pred.size(); i++) {
      per_azi_pred.at(i).resize(181);
      for(int iazi=0; iazi<181; iazi++) {
         if( azi[iazi] != iazi*2 ) return false;
         per_azi_pred[i][iazi] = AziData( azi[iazi], grT[i][iazi], phT[i][iazi], amp[i][iazi] );
      }
   }

   return true;
}


bool FocalSearcher::Energy( const FocalInfo& finfo, float& E ) {
   // check feigname
   if( access( pimplFS->feigname.c_str(), F_OK) == -1 ) return false;
   if( access( pimplFS->fphvname.c_str(), F_OK) == -1 ) return false;
   //if( access( radexe.c_str(), F_OK) == -1 ) return false;

   // perlst from perlist
   std::vector<float> perlst;
   for(int i=0; i<pimplFS->perlist.size(); i++) perlst.push_back(pimplFS->perlist.at(i).per);


   // initialize prediction matrix
   std::vector< std::vector<AziData> > per_azi_pred;
   per_azi_pred.resize( pimplFS->perlist.size() );

   // run rad_pattern_r
   RadPatternR( pimplFS->feigname, pimplFS->fphvname, finfo, perlst, per_azi_pred );
   // compute dazi and resize the per_azi_pred table
   int nazi = per_azi_pred.at(0).size();
   float dazi = per_azi_pred.at(0).at(1).azi - per_azi_pred.at(0).at(0).azi;

   // invalidate incomplete azimuths and points around 0 amplitudes
   for( int iper=0; iper<perlst.size(); iper++ )
      for( int ipred=0; ipred < per_azi_pred.at(iper).size(); ipred++ ) {
	 AziData &adtmp = per_azi_pred.at(iper).at(ipred);
	 if( adtmp.azi == -12345. ) continue;
	 if( adtmp.misG==-12345 || adtmp.misP==-12345 || adtmp.A==-12345 ) adtmp.azi = -12345.;
	 else if( adtmp.A < 0.01 ) {
	    int jpredlow = ipred, jpredhigh = ipred;
	    while( jpredlow>0 && per_azi_pred.at(iper).at(jpredlow).azi>adtmp.azi-20 ) jpredlow--;
	    while( jpredhigh<per_azi_pred.at(iper).size() && per_azi_pred.at(iper).at(jpredhigh).azi<adtmp.azi+20 ) jpredhigh++;
	    for(int jpred=jpredlow; jpred<jpredhigh; jpred++) per_azi_pred.at(iper).at(jpred).azi = -12345.;
	 }
      }

 
   // rescale observed amplitude by predicted average
   long double ampD = 0., ampP = 0.;
   for( int iper=0; iper<perlst.size(); iper++ ) {
      int itmp = 0;
      long double ldtmp = 0.;
      for( int idata=0; idata < pimplFS->per_azi_data.at(iper).size(); idata++ ) {
	 if( pimplFS->per_azi_data.at(iper).at(idata).azi != -12345 ) { 
	    ldtmp += pimplFS->per_azi_data.at(iper).at(idata).A; 
	    itmp++; 
	 }
      }
      ampD += ldtmp / itmp;
      itmp = 0; ldtmp = 0.;
      for( int ipred=0; ipred < per_azi_pred.at(iper).size(); ipred++ ) 
	 if( per_azi_pred.at(iper).at(ipred).azi != -12345 ) { ldtmp += per_azi_pred.at(iper).at(ipred).A; itmp++; }
      ampP += ldtmp / itmp;
   }
   long double factor = ampP/ampD, factor2 = factor*factor;
   for( int iper=0; iper<perlst.size(); iper++ ) {
      for( int idata=0; idata < pimplFS->per_azi_data.at(iper).size(); idata++ ) 
	 if( pimplFS->per_azi_data.at(iper).at(idata).azi != -12345 ) {
	    pimplFS->per_azi_data.at(iper).at(idata).A *= factor;
	    pimplFS->per_azi_data.at(iper).at(idata).varA *= factor2;
	 }
   }

   // compute misfit at each period
   E = 0.;
   for( int iper=0; iper<perlst.size(); iper++ ) {
      int ipred = 0, nvalid=0;
      float Ecur = 0.;
      for( int idata=0; idata < pimplFS->per_azi_data.at(iper).size(); idata++ ) {
 	 AziData adtmp = pimplFS->per_azi_data.at(iper).at(idata);
         if( adtmp.azi == -12345. ) continue;
	 int ninvalid = 0;
	 int ipredlow = (int)floor(adtmp.azi/dazi);
	 while( ipredlow>=0 && per_azi_pred.at(iper).at(ipredlow).azi == -12345. ) { ipredlow--; ninvalid++; }
	 int ipredhigh = (int)ceil(adtmp.azi/dazi);
	 while( ipredhigh<per_azi_pred.at(iper).size() && per_azi_pred.at(iper).at(ipredhigh).azi == -12345. ) { ipredhigh++; ninvalid++; }
	 if( ipredlow < 0 || ipredhigh >= per_azi_pred.at(iper).size() || ninvalid>5 ) continue;
	 Ecur += pimplFS->MisfitS( adtmp, per_azi_pred.at(iper).at(ipredlow), per_azi_pred.at(iper).at(ipredhigh), perlst.at(iper) );
	 nvalid++;
      }
      if( nvalid < MIN_AZI_SIZE ) {
	 std::cerr<<"Warning(FocalSearcher::Energy): no enough data point for the current period!"<<std::endl;
	 continue;
      }
      else E += Ecur/nvalid;
   }
   return true;
}



#include "FocalSearcher.h"
#include <cstdio>
#include <unistd.h>
#include <cstring>
#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <chrono>
#include <random>
#include <functional>
//#include <sys/inotify.h>
#include <omp.h>


extern"C" {
   void rad_pattern_r_(char *feig_buff, int *eig_len, int *phvnper, int *phvdper,
                       float *strike, float *dip, float *rake, float *depth, float *per, int *nper,
                       float *azi, float grT[][181], float phT[][181], float amp[][181]);
}

struct FocalSearcher::FSimpl {

   FocalInfo finfo, finfoold;
   std::string outname_mis;
   std::string feigname, fphvname;
   std::string feignmem, fphvnmem; // name of files of the currently-in-the-memory contents
   std::vector<PerDazi> perlist;
   /* It's perfectly OK to use vector of vector here as the data for each
    * period are accessed independently. Consider changing to Array2D if 
    * the access pattern is changed somehow */
   std::vector< std::vector<AziData> > per_azi_data;

   int phvnper, phvdper;
   int feig_len;
   char *feig_buff;
   double Afactor;

   FSimpl() { 
      phvnper = -12345; phvdper = -12345;
      feig_buff = NULL; feig_len = -12345; 
   }

   FSimpl( const FocalInfo& finfoin, const std::vector<PerDazi>& perlistin, 
	   const std::vector< std::vector<AziData> >& per_azi_datain,
	   const char* feignamein, const char* fphvnamein ) 
      : finfo(finfoin), perlist(perlistin), per_azi_data(per_azi_datain) 
      , feigname(feignamein), fphvname(fphvnamein) { 
      phvnper = -12345; phvdper = -12345;
      feig_buff = NULL; feig_len = -12345; 
   }
   ~FSimpl() { if(feig_buff) free(feig_buff); }

   void MisfitS( AziData& dat, AziData& predl, AziData& predh, float per, 
		  std::vector<float>& misGV, std::vector<float>& weitGV, 
		  std::vector<float>& misPV, std::vector<float>& weitPV,
		  std::vector<float>& misAV, std::vector<float>& weitAV ) {
      float misG, misP, A;
      if( predl.azi != predh.azi ) {
         float factor = (dat.azi-predl.azi)/(predh.azi-predl.azi);
         misG = predl.misG + (predh.misG-predl.misG) * factor;
         misP = predl.misP + (predh.misP-predl.misP) * factor;
         A = predl.A + (predh.A-predl.A) * factor;
      }
      else { misG = predl.misG; misP = predl.misP; A = predl.A; }
      //abs misfit
      float mis1 = dat.misG-misG, mis2 = dat.misP-misP, mis3 = dat.A-A;
      float pero2 = 0.5 * per;
    //if(per==20) std::cerr<<dat.azi<<" "<<mis1<<"  "<<dat.misG<<" "<<predl.misG<<" "<<predh.misG<<std::endl;
      //correct misP for 2pis
      while( mis2 > pero2 ) mis2 -= per;
      while( mis2 < -pero2 ) mis2 += per;
      //chi-square
      misGV.push_back( mis1*mis1 ); weitGV.push_back( 1./dat.varG );
      misPV.push_back( mis2*mis2 ); weitPV.push_back( 1./dat.varP );
      misAV.push_back( mis3*mis3 ); weitAV.push_back( 1./dat.varA );
      //mis1 = mis1*mis1/dat.varG; mis2 = mis2*mis2/dat.varP; mis3 = mis3*mis3/dat.varA;
      //return mis1*0.35+mis2*0.35+mis3*0.3;
   }

   bool Accept(float E, float Enew, double T) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
      std::default_random_engine generator (timeseed);
      std::uniform_real_distribution<float> distribution(0., 1.);
      auto rand = std::bind ( distribution, generator );
      if(Enew<E) return true;
      if(rand()<exp((E-Enew)/T)) return true;
      return false;
   }

   FocalInfo Neighbour( const FocalInfo& finfo ) {
      unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
/*
      // random number generator 1
      std::default_random_engine generator1 (timeseed);
      std::uniform_int_distribution<int> distributionU(0, 3);
      auto randintu3 = std::bind ( distributionU, generator1 );
*/
      // random number generator 2. (apply different generator type to avoid correlated random numbers!!!)
      std::mt19937 generator2 (timeseed);
      std::normal_distribution<double> distributionN(0.0,1.0);
      auto randnorm = std::bind ( distributionN, generator2 );
   
      FocalInfo finfonew = finfo;
      int depthmax = 60;

      float hstrike = 18, hdip = 4.5, hrake = 18;
      float hdep = depthmax * 0.05;

      // perturb strike
      finfonew.strike += (int)floor(randnorm()*hstrike+0.5);
      if( finfonew.strike < 0 ) finfonew.strike += 360;
      if( finfonew.strike >= 360 ) finfonew.strike -= 360;
      // perturb dip
      while( float dltdip = (int)floor(randnorm()*hdip+0.5) ) {
	 float dipnew = finfonew.dip + dltdip;
	 if( dipnew <= 90 && dipnew >= 0 ) {
	    finfonew.dip = dipnew;
	    break;
	 }
      }
      // perturb rake
      finfonew.rake += (int)floor(randnorm()*18+0.5);
      if( finfonew.rake < -180 ) finfonew.rake += 360;
      if( finfonew.rake > 180 ) finfonew.rake -= 360;
      // perturb dep
      while( float dltdep = (int)floor(randnorm()*hdep+0.5) ) {
	 float depnew = finfonew.depth + dltdep;
	 if( depnew < depthmax && depnew >= 0 ) {
	    finfonew.depth = depnew;
	    break;
	 }
      }

/*
      int shift = 0;
      switch( randintu3() ) {
         case 0:
	    while( shift == 0 ) shift = (int)floor(randnorm()*36+0.5);
	    finfonew.strike += shift;
	    if( finfonew.strike < 0 ) finfonew.strike += 360;
	    if( finfonew.strike >= 360 ) finfonew.strike -= 360;
	    break;
         case 1:
	    while( shift == 0 ) shift = (int)floor(randnorm()*9+0.5);
	    finfonew.dip += shift;
            if( finfonew.dip < 0 ) finfonew.dip = 0;
            if( finfonew.dip > 90 ) finfonew.dip = 90;
            break;
         case 2:
	    while( shift == 0 ) shift = (int)floor(randnorm()*36+0.5);
	    finfonew.rake += shift;
            if( finfonew.rake < -180 ) finfonew.rake += 360;
            if( finfonew.rake > 180 ) finfonew.rake -= 360;
            break;
         case 3:
	    while( shift == 0 ) shift = (int)floor(randnorm()*0.1*depthmax+0.5);
	    finfonew.depth += shift;
            if( finfonew.depth < 0 ) finfonew.depth = 0;
            if( finfonew.depth >= depthmax ) finfonew.depth = depthmax;
            break;
         defalut:
	    std::cerr<<"Error(Neighbour) !!!"<<std::endl;
	    exit(0);
      }
*/
      return finfonew;
   }

   bool ExcludeLarge( std::vector<float>& data, std::vector<float>& weight ) {
      if( data.size() != weight.size() ) return false;
      // compute mean 1
      float V1 = 0., mean1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 mean1 += data[i] * weight[i];
	 V1 += weight[i];
      }
      mean1 /= V1;
      // compute std1
      float V2 = 0., std1 = 0.;
      for(int i=0; i<data.size(); i++) {
	 float ftmp = data[i]-mean1;
	 std1 += ftmp * ftmp * weight[i];
	 V2 += weight[i] * weight[i];
      }
      std1 = sqrt( std1 * V1 / (V1*V1-V2) );
      // exclude larger-than-2std data
      float ubound = mean1 + 2.*std1;// lbound = mean1 - 2.*std1;
      for(int i=0; i<data.size(); i++) {
	 if( data[i]>ubound ) {
	    data.erase( data.begin() + i );
	    weight.erase( weight.begin() + i );
	 }
      }

      return true;
   }

};


FocalSearcher::FocalSearcher()
   : pimplFS(new FSimpl) {}

FocalSearcher::FocalSearcher( const FocalInfo &finfoin, const std::vector<PerDazi> &perlistin, 
			      const std::vector< std::vector<AziData> > &per_azi_data_in,
			      const char *feignamein, const char *fphvnamein )
   : pimplFS(new FSimpl(finfoin, perlistin, per_azi_data_in, feignamein, fphvnamein) ) {
   // check per size
   if( pimplFS->perlist.size() != pimplFS->per_azi_data.size() ) {
      std::cerr<<"Error(FocalSearcher::FocalSearcher): size of perlist and per_azi_data doesn't match!"<<std::endl;
      exit(0);
   }

   // azi size
   for(int iper=0; iper<pimplFS->perlist.size(); iper++) { 
      int nazi = 0;
      for(int iazi=0; iazi<pimplFS->per_azi_data.at(iper).size(); iazi++) {
	 if( pimplFS->per_azi_data.at(iper).at(iazi).azi != -12345. ) nazi++;
      }
      if( nazi < MIN_AZI_SIZE ) {
	 pimplFS->perlist.erase( pimplFS->perlist.begin() + iper );
	 pimplFS->per_azi_data.erase( pimplFS->per_azi_data.begin() + iper );
      }
   }
   if( pimplFS->perlist.size() == 0 ) {
      std::cerr<<"Error(FocalSearcher::FocalSearcher): data matrix is empty after erasing!"<<std::endl;
      exit(0);
   }

   // insert sort perlist and per_azi_data
   //for(int i=0; i<perlist.size(); i++) std::cerr<<perlist.at(i).per<<" "<<per_azi_data.at(i).at(0).amp<<std::endl;
   for(int i=1; i<pimplFS->perlist.size(); i++) {
      if( pimplFS->perlist.at(i).per >= pimplFS->perlist.at(i-1).per ) continue;
      PerDazi pdtmp = pimplFS->perlist.at(i);
      std::vector<AziData> Vadtmp = pimplFS->per_azi_data.at(i);
      int j;
      for(j=i; j>0 && pdtmp.per<pimplFS->perlist.at(j-1).per; j--) {
	 pimplFS->perlist.at(j) = pimplFS->perlist.at(j-1);
	 pimplFS->per_azi_data.at(j) = pimplFS->per_azi_data.at(j-1);
      }
      pimplFS->perlist.at(j) = pdtmp;
      pimplFS->per_azi_data.at(j) = Vadtmp;
   }

}

FocalSearcher::~FocalSearcher() {}


const FocalInfo& FocalSearcher::FInfo() const { return pimplFS->finfo; }
      FocalInfo& FocalSearcher::FInfo() { return pimplFS->finfo; }
const FocalInfo& FocalSearcher::FInfoOld() const { return pimplFS->finfoold; }
      FocalInfo& FocalSearcher::FInfoOld() { return pimplFS->finfoold; }

const double& FocalSearcher::AFactor() const {return pimplFS->Afactor; }
      double& FocalSearcher::AFactor() {return pimplFS->Afactor; }

const std::string& FocalSearcher::FMisF() const { return pimplFS->outname_mis; }
      std::string& FocalSearcher::FMisF() { return pimplFS->outname_mis; }
const std::string& FocalSearcher::FEigName() const { return pimplFS->feigname; }
      std::string& FocalSearcher::FEigName() { return pimplFS->feigname; }
const std::string& FocalSearcher::FPhvName() const { return pimplFS->fphvname; }
      std::string& FocalSearcher::FPhvName() { return pimplFS->fphvname; }

const std::vector<PerDazi>& FocalSearcher::PerList() const { return pimplFS->perlist; }
      std::vector<PerDazi>& FocalSearcher::PerList() { return pimplFS->perlist; }
const std::vector< std::vector<AziData> >& FocalSearcher::Per_Azi_Data() const { return pimplFS->per_azi_data; }
      std::vector< std::vector<AziData> >& FocalSearcher::Per_Azi_Data() { return pimplFS->per_azi_data; }

/* search the focal info with a simulated annealing algorithm.
 * nsearch: number of search iterations
 * alpha: controls how fast temperature decays
 * Tfactor: factor of initial temperature */
bool FocalSearcher::SearchFocal( int nsearch, float alpha, float Tfactor ) {
   // check input data
   if( pimplFS->perlist.size() == 0 || pimplFS->per_azi_data.size() == 0
    || pimplFS->feigname.empty() || pimplFS->fphvname.empty() ) return false;
   // simulated annealing parameters
   float E;
   //pimplFS->finfo = FocalInfo( 217, 34, -88, 11 );
   // start search
   double Af_best;
   if( ! Energy(pimplFS->finfo, E, Af_best) ) return false;
   // save old focal info
   pimplFS->finfoold = pimplFS->finfo;
   //int nsearch = 20000;
   float T = E * Tfactor;// alpha=0.999;
   std::cout<<"### SearchFocal: Initial Misfit**2 for "<<pimplFS->finfo<<" = "<<E<<" T="<<T<<" ###"<<std::endl;
   FocalInfo finfobest = pimplFS->finfo;
   float Ebest = E;
   int nrej = 0;
   int isearch = 0;
   std::ofstream fout;
   bool output_mis = ! pimplFS->outname_mis.empty();
   if( output_mis ) fout.open(  pimplFS->outname_mis.c_str(), std::ofstream::app );
   fout<<"# [ focal = "<<FInfo()<<" ]"<<std::endl;
   fout<< "-1\t" << E << "\t" << T << std::endl;
   #pragma omp parallel for schedule (dynamic, 1)
   for( int i=0; i<nsearch; i++ ) {
      FocalInfo finfonew = pimplFS->Neighbour( pimplFS->finfo );
      float Enew = -12345.; double Afactor;
      if( ! Energy( finfonew, Enew, Afactor ) ) continue;//return false;
      if( pimplFS->Accept(E, Enew, T) ) {
	 pimplFS->finfo = finfonew;
	 E = Enew;
	 if( output_mis ) {
	#pragma omp critical
	{ // critical start
	    fout<< isearch << "\t" << Enew << "\t" << T << std::endl;
	    fout.flush();
	} // critical end
	 }
         std::cout<<"   Misfit**2 for "<<finfonew<<" = "<<Enew<<" (accepted)  T="
		  <<T<<"  isearch="<<isearch<<"/"<<nsearch<<std::endl;
	 nrej = 0;
      }
      else { nrej++; std::cout<<"( nrejects = "<<nrej<<" )"<<"  ithread="<<omp_get_thread_num()<<"                 "<<std::endl<<"\x1b[A"; }
     #pragma omp critical
     { // critical start
      T *= alpha;
      if( Enew < Ebest ) {
	 finfobest = finfonew;
	 Ebest = Enew;
	 Af_best = Afactor;
      }
      isearch++;
     } // critical end
   }
   fout<< isearch << "\t" << Ebest << "\t" << T << std::endl;
   fout<<std::endl<<std::endl; fout.close();
   std::cout<<"                                   "<<std::endl;
   pimplFS->finfo = finfobest; 
   pimplFS->Afactor = Af_best;
}


bool FocalSearcher::RadPatternR( const std::string& feigname, const std::string& fphvname, const FocalInfo& finfo,
				 std::vector<float>& perlst, std::vector< std::vector<AziData> >& per_azi_pred ) {
   int nper = perlst.size();
   float strike = finfo.strike, dip = finfo.dip, rake = finfo.rake, depth = finfo.depth;
   float azi[181], grT[nper][181], phT[nper][181], amp[nper][181];

   // read feig into memory
   if( pimplFS->feig_buff == NULL || feigname != pimplFS->feignmem ) {
      if( feigname.empty() ) return false;
      std::ifstream fin( feigname.c_str() );
      if( ! fin ) return false;
      fin.seekg(0, std::ios::end);
      pimplFS->feig_len = fin.tellg();
      pimplFS->feig_buff = new char[pimplFS->feig_len];
      fin.seekg(0,std::ios::beg);
      fin.read(pimplFS->feig_buff, pimplFS->feig_len);
      fin.close();
      pimplFS->feignmem = feigname;
   }

   // read in nper and dper from fphv
   if( pimplFS->phvnper < 0 || fphvname != pimplFS->fphvnmem )  {
      if( fphvname.empty() ) return false;
      std::ifstream fin( fphvname.c_str() );
      if( ! fin ) return false;
      pimplFS->phvnper = 0;
      for( std::string line; std::getline(fin, line); ) {
         float ftmp1, ftmp2, ftmp3;
         if( sscanf(line.c_str(), "%f %f %f", &ftmp1, &ftmp2, &ftmp3) != 3 ) continue;
         if( pimplFS->phvnper == 0 ) pimplFS->phvdper = ftmp1;
         else if( pimplFS->phvnper == 1 ) pimplFS->phvdper = ftmp1 - pimplFS->phvdper;
         (pimplFS->phvnper)++;
      }
      fin.close();
      pimplFS->fphvnmem = fphvname;
   }

   // run rad_pattern_r
   rad_pattern_r_( pimplFS->feig_buff, &(pimplFS->feig_len), &(pimplFS->phvnper), &(pimplFS->phvdper),
                   &(strike), &(dip), &(rake), &(depth), &(perlst.at(0)), &nper, azi, grT, phT, amp );

   for(int i=0; i<per_azi_pred.size(); i++) {
      per_azi_pred.at(i).resize(181);
      for(int iazi=0; iazi<181; iazi++) {
         if( azi[iazi] != iazi*2 ) return false;
         per_azi_pred[i][iazi] = AziData( azi[iazi], grT[i][iazi], phT[i][iazi], amp[i][iazi] );
      }
   }

   return true;
}


bool FocalSearcher::Energy( const FocalInfo& finfo, float& E, double& Afactor ) {
   // check feigname
   if( access( pimplFS->feigname.c_str(), F_OK) == -1 ) return false;
   if( access( pimplFS->fphvname.c_str(), F_OK) == -1 ) return false;
   //if( access( radexe.c_str(), F_OK) == -1 ) return false;

   // perlst from perlist
   std::vector<float> perlst;
   for(int i=0; i<pimplFS->perlist.size(); i++) perlst.push_back(pimplFS->perlist.at(i).per);


   // initialize prediction matrix
   std::vector< std::vector<AziData> > per_azi_pred;
   per_azi_pred.resize( pimplFS->perlist.size() );

   // run rad_pattern_r
   RadPatternR( pimplFS->feigname, pimplFS->fphvname, finfo, perlst, per_azi_pred );
   // compute dazi and resize the per_azi_pred table
   int nazi = per_azi_pred.at(0).size();
   float dazi = per_azi_pred.at(0).at(1).azi - per_azi_pred.at(0).at(0).azi;

   // invalidate incomplete azimuths and points around 0 amplitudes
   for( int iper=0; iper<perlst.size(); iper++ )
      for( int ipred=0; ipred < per_azi_pred.at(iper).size(); ipred++ ) {
	 AziData &adtmp = per_azi_pred.at(iper).at(ipred);
	 if( adtmp.azi == -12345. ) continue;
	 if( adtmp.misG==-12345 || adtmp.misP==-12345 || adtmp.A==-12345 ) adtmp.azi = -12345.;
	 else if( adtmp.A < 0.01 ) {
	    int jpredlow = ipred, jpredhigh = ipred;
	    while( jpredlow>0 && per_azi_pred.at(iper).at(jpredlow).azi>adtmp.azi-20 ) jpredlow--;
	    while( jpredhigh<per_azi_pred.at(iper).size() && per_azi_pred.at(iper).at(jpredhigh).azi<adtmp.azi+20 ) jpredhigh++;
	    for(int jpred=jpredlow; jpred<jpredhigh; jpred++) per_azi_pred.at(iper).at(jpred).azi = -12345.;
	 }
      }

 
   // rescale predicted amplitude by observed average
   long double ampD = 0., ampP = 0.;
   for( int iper=0; iper<perlst.size(); iper++ ) {
      int itmp = 0;
      long double ldtmp = 0.;
      for( int idata=0; idata < pimplFS->per_azi_data.at(iper).size(); idata++ ) {
	 if( pimplFS->per_azi_data.at(iper).at(idata).azi != -12345 ) { 
	    ldtmp += pimplFS->per_azi_data.at(iper).at(idata).A; 
	    itmp++; 
	 }
      }
      ampD += ldtmp / itmp;
      itmp = 0; ldtmp = 0.;
      for( int ipred=0; ipred < per_azi_pred.at(iper).size(); ipred++ ) 
	 if( per_azi_pred.at(iper).at(ipred).azi != -12345 ) { ldtmp += per_azi_pred.at(iper).at(ipred).A; itmp++; }
      ampP += ldtmp / itmp;
   }
   double factor = ampD/ampP, factor2 = factor*factor;
   Afactor = factor;
   for( int iper=0; iper<perlst.size(); iper++ ) {
      for( int ipred=0; ipred < per_azi_pred.at(iper).size(); ipred++ ) 
	 if( per_azi_pred.at(iper).at(ipred).azi != -12345 ) {
	    per_azi_pred.at(iper).at(ipred).A *= factor;
	    per_azi_pred.at(iper).at(ipred).varA *= factor2;
	 }
   }

   // compute misfit at each period
   E = 0.;
   int nper_valid = 0;
   for( int iper=0; iper<perlst.size(); iper++ ) {
      int ipred = 0;
      std::vector<float> misGV, misPV, misAV, weitGV, weitPV, weitAV;
      for( int idata=0; idata < pimplFS->per_azi_data.at(iper).size(); idata++ ) {
 	 AziData adtmp = pimplFS->per_azi_data.at(iper).at(idata);
         if( adtmp.azi == -12345. ) continue;
	 int ninvalid = 0;
	 int ipredlow = (int)floor(adtmp.azi/dazi);
	 while( ipredlow>=0 && per_azi_pred.at(iper).at(ipredlow).azi == -12345. ) { ipredlow--; ninvalid++; }
	 int ipredhigh = (int)ceil(adtmp.azi/dazi);
	 while( ipredhigh<per_azi_pred.at(iper).size() && per_azi_pred.at(iper).at(ipredhigh).azi == -12345. ) { ipredhigh++; ninvalid++; }
	 if( ipredlow < 0 || ipredhigh >= per_azi_pred.at(iper).size() || ninvalid>5 ) continue;
	 pimplFS->MisfitS( adtmp, per_azi_pred.at(iper).at(ipredlow), per_azi_pred.at(iper).at(ipredhigh), perlst.at(iper), misGV, weitGV, misPV, weitPV, misAV, weitAV );
      }
      if( misGV.size() < MIN_AZI_SIZE || misPV.size() < MIN_AZI_SIZE || misAV.size() < MIN_AZI_SIZE ) {
	 std::cerr<<"Warning(FocalSearcher::Energy): no enough data point for the current period!"<<std::endl;
	 continue;
      }
      else {
	 //std::vector<float> weit( misV.size(), 1. );
	 if( ! pimplFS->ExcludeLarge( misGV, weitGV ) ) return false;
	 if( ! pimplFS->ExcludeLarge( misPV, weitPV ) ) return false;
	 if( ! pimplFS->ExcludeLarge( misAV, weitAV ) ) return false;
	 float Ecur = 0., V1 = 0.;
	 for(int idat=0; idat<misGV.size(); idat++) { Ecur += misGV[idat]*weitGV[idat]; V1 += weitGV[idat]; }
	 for(int idat=0; idat<misPV.size(); idat++) { Ecur += misPV[idat]*weitPV[idat]; V1 += weitPV[idat]; }
	 for(int idat=0; idat<misAV.size(); idat++) { Ecur += misAV[idat]*weitAV[idat]; V1 += weitAV[idat]; }
	 E += Ecur / V1;
	 nper_valid++;
      }
   }
   E /= nper_valid;
   return true;
}



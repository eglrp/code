#include "FocalSearcher.h"
#include "RadPattern.h"
#include "FileName.h"
#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <algorithm>
#include "MyOMP.h"


struct FocalSearcher::FSimpl {
	/* --- data --- */
	float weightR_Foc, weightL_Foc;

	FileName outname_misF;
	FileName fReigname, fRphvname;
	FileName fLeigname, fLphvname;

	std::vector<PerDazi> perRlist, perLlist;
	/* It's perfectly OK to use vector of vector here as the data for each
	 * period are accessed independently. Consider changing to Array2D if 
	 * the access pattern is changed somehow */
	std::vector< std::vector<AziData> > per_R_azi_data, per_L_azi_data;

	/* obj that predicts radiation patterns.
	 * use 2 separate RadPattern objects for R and L data to reduce readings of feig&fphv from the disk */
	RadPattern rpR, rpL;

	double AfactorR, AfactorL;

	/* obj that generates random numbers 
	 * To obtain correct randomless this obj has to be created instead of using the Rand() class locally */
	Rand randO;

	/* --- methods --- */
	FSimpl()
		: AfactorR(-12345.), AfactorL(-12345.), weightR_Foc(-12345.), weightL_Foc(-12345.)  {}
	FSimpl( const std::vector<PerDazi>& perRlistin, 
			const std::vector<PerDazi>& perLlistin, 
			const std::vector< std::vector<AziData> >& per_R_azi_datain,
			const std::vector< std::vector<AziData> >& per_L_azi_datain,
			const char* fReignamein, const char* fRphvnamein,
			const char* fLeignamein, const char* fLphvnamein,
			const float weightR, const float weightL )
		: perRlist(perRlistin), per_R_azi_data(per_R_azi_datain)
		  , perLlist(perLlistin), per_L_azi_data(per_L_azi_datain)
		  , fReigname(fReignamein), fRphvname(fRphvnamein)
		  , fLeigname(fLeignamein), fLphvname(fLphvnamein)
		  , weightR_Foc(weightR), weightL_Foc(weightL)
		  , AfactorR(-12345.), AfactorL(-12345.) {}
	//~FSimpl() {}

	inline bool AziFactor( AziData& dat_l, AziData& dat_m, AziData& dat_h, float& azifactor ) {
		float azi_l = dat_l.azi, azi_m = dat_m.azi, azi_h = dat_h.azi;
		if( azi_m == azi_l ) { azifactor = 0.; return true; }
		if( azi_m == azi_h ) { azifactor = 1.; return true; }
		if( azi_l > azi_h ) {
			azi_h += 360.;
			if( azi_m < azi_l ) azi_m += 360.;
		}
		if( azi_l>azi_m || azi_m>azi_h ) return false;
		azifactor = (dat_m.azi - dat_l.azi) / (dat_h.azi - dat_l.azi);
		return true;
	}

	void MisfitS( AziData& dat, AziData& predl, AziData& predh, float per,
			std::vector<float>& misGV, std::vector<float>& weitGV, 
			std::vector<float>& misPV, std::vector<float>& weitPV,
			std::vector<float>& misAV, std::vector<float>& weitAV ) {
		float misG, misP, A;
		if( predl.azi != predh.azi ) {
			float factor = (dat.azi-predl.azi)/(predh.azi-predl.azi);
			misG = predl.misG + (predh.misG-predl.misG) * factor;
			misP = predl.misP + (predh.misP-predl.misP) * factor;
			A = predl.A + (predh.A-predl.A) * factor;
		}
		else { misG = predl.misG; misP = predl.misP; A = predl.A; }
		//abs misfit
		float mis1 = dat.misG-misG, mis2 = dat.misP-misP, mis3 = dat.A-A;
		float pero2 = 0.5 * per;
		//correct misP for 2pis
		while( mis2 > pero2 ) mis2 -= per;
		while( mis2 < -pero2 ) mis2 += per;
		//if(per==10) std::cerr<<dat.azi<<" "<<mis3<<"    "<<dat.A<<" "<<A<<std::endl;
		//chi-square
		if( dat.misG!=-12345. ) { misGV.push_back( mis1*mis1 ); weitGV.push_back( 1./dat.varG ); }
		if( dat.misP!=-12345. ) { misPV.push_back( mis2*mis2 ); weitPV.push_back( 1./dat.varP ); }
		if( dat.A   !=-12345. ) { misAV.push_back( mis3*mis3 ); weitAV.push_back( 1./dat.varA ); }
		//std::cerr<<mis1*mis1<<" "<<1./dat.varG<<"   "<<mis2*mis2<<" "<<1./dat.varP<<"   "<<mis3*mis3<<" "<<1./dat.varA<<std::endl;
		//mis1 = mis1*mis1/dat.varG; mis2 = mis2*mis2/dat.varP; mis3 = mis3*mis3/dat.varA;
		//return mis1*0.35+mis2*0.35+mis3*0.3;
	}

	bool Accept(float E, float Enew, double T) {
		/*
			unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
			std::default_random_engine generator (timeseed);
			std::uniform_real_distribution<float> distribution(0., 1.);
			auto rand = std::bind ( distribution, generator );
			*/
		if(Enew<E) return true;
		if(randO.Uniform()<exp((E-Enew)/T)) return true;
		return false;
	}

	inline ftype Neighbour_Cycle( ftype valold, float hlen, float lb, float ub ) {
		ftype valnew = valold + randO.Normal()*hlen;
		while( valnew >= ub ) { valnew -= (ub-lb); }
		while( valnew < lb ) { valnew += (ub-lb); }
		return valnew;
	}
	inline ftype Neighbour_Reflect( ftype valold, float hlen, float lb, float ub ) {
		float range = ub - lb;
		ftype shift = randO.Normal() * hlen;
		if( shift > range ) shift = range;
		else if( shift < -range ) shift = -range;
		ftype valnew = valold + shift;
		if( valnew >= ub ) { valnew = 2.*ub-valnew; }
		else if( valnew < lb ) { valnew = 2.*lb-valnew; }
		return valnew;
	}
	FocalInfo<ftype> Neighbour( const FocalInfo<ftype>& finfo ) {
		/*
			unsigned timeseed = std::chrono::system_clock::now().time_since_epoch().count();
		//std::default_random_engine generator1 (timeseed);
		// random number generator 2. (apply different generator type to avoid correlated random numbers!!!)
		std::mt19937 generator2 (timeseed);
		std::normal_distribution<double> distributionN(0.0,1.0);
		auto randnorm = std::bind ( distributionN, generator2 );
		*/

		FocalInfo<ftype> finfonew;// = finfo;

		float hstrike = 36., hdip = 9, hrake = 36.;
		int depthmax = 50;
		float hdep = depthmax * 0.1;

		// perturb strike
		finfonew.strike = Neighbour_Cycle(finfo.strike, hstrike, 0., 360.);
		// perturb dip
		finfonew.dip = Neighbour_Reflect(finfo.dip, hdip, 0., 90.);
		// perturb rake
		finfonew.rake = Neighbour_Cycle(finfo.rake, hrake, -180., 180.);
		// perturb dep
		finfonew.depth = Neighbour_Reflect(finfo.depth, hdep, 0., depthmax);

		return finfonew;
	}

	bool ExcludeLarge( std::vector<float>& data, std::vector<float>& weight ) {
		if( data.size() != weight.size() ) return false;
		// compute mean 1
		float V1 = 0., mean1 = 0.;
		for(int i=0; i<data.size(); i++) {
			mean1 += data[i] * weight[i];
			V1 += weight[i];
		}
		mean1 /= V1;
		// compute std1
		float V2 = 0., std1 = 0.;
		for(int i=0; i<data.size(); i++) {
			float ftmp = data[i]-mean1;
			std1 += ftmp * ftmp * weight[i];
			V2 += weight[i] * weight[i];
		}
		std1 = sqrt( std1 * V1 / (V1*V1-V2) );
		// exclude larger-than-2sigma data
		float ubound = mean1 + 2.0*std1;// lbound = mean1 - 2.0*std1;
		//for(int i=0; i<data.size();) { // does this work always?
		int i=0;
		while( i < data.size() ) {
			if( data[i]>ubound ) {
				data.erase( data.begin() + i );
				weight.erase( weight.begin() + i );
			}
			else i++;
		}

		return true;
	}

	bool ExcludeBad( std::vector<float>& data, std::vector<float>& weight ) {
		if( data.size() != weight.size() ) return false;
		// compute mean 1
		float V1 = 0., mean1 = 0.;
		for(int i=0; i<data.size(); i++) {
			mean1 += data[i] * weight[i];
			V1 += weight[i];
		}
		mean1 /= V1;
		// compute std1
		float V2 = 0., std1 = 0.;
		for(int i=0; i<data.size(); i++) {
			float ftmp = data[i]-mean1;
			std1 += ftmp * ftmp * weight[i];
			V2 += weight[i] * weight[i];
		}
		std1 = sqrt( std1 * V1 / (V1*V1-V2) );
		// exclude out-of-2sigma data
		float ubound = mean1 + 2.0*std1, lbound = mean1 - 2.0*std1;
		//for(int i=0; i<data.size();) { // does this work always?
		int i=0;
		while( i < data.size() ) {
			if( data[i]>ubound || data[i]<lbound ) {
				data.erase( data.begin() + i );
				weight.erase( weight.begin() + i );
			}
			else i++;
		}

		return true;
	}

	void ReValidate( std::vector< std::vector<AziData> >& data ) {
		for( int iper=0; iper<data.size(); iper++ ) {
			std::vector<AziData>& data_cur = data[iper];
			for( int ipred=0; ipred < data_cur.size(); ipred++ ) {
				AziData &adtmp = data_cur[ipred];
				if( ! adtmp.valid ) continue;
				if( adtmp.misG==-12345 || adtmp.misP==-12345 || adtmp.A==-12345 ) adtmp.valid = false;
				else if( adtmp.A < 0.01 ) {
					int jpredlow = ipred, jpredhigh = ipred;
					while( jpredlow>0 && data_cur[jpredlow].azi>adtmp.azi-8. ) jpredlow--;
					while( jpredhigh<data_cur.size() && data_cur[jpredhigh].azi<adtmp.azi+8. ) jpredhigh++;
					for(int jpred=jpredlow; jpred<jpredhigh; jpred++) data_cur[jpred].valid = false;
				}
			}
		}
	}


	inline static bool CompareAziA( AziData sta1, AziData sta2 ) { return (sta1.azi<sta2.azi); }
	void ReScale( std::vector< std::vector<AziData> >& data, std::vector< std::vector<AziData> >& datapred, double& Ampfactor ) {
		if( data.size() != datapred.size() ) throw ErrorFS::SizeMismatch(FuncName, "data - datapred");

		/* compute the scaling factor&weight on each data point */
		double F_sum = 0., W_sum = 0.;
		for(int iper=0; iper<data.size(); iper++) {
			std::vector<AziData>& data_V = data[iper];
			std::vector<AziData>& datapred_V = datapred[iper];
			std::vector<float> ampfactor, weight;
			for( int idat=0; idat < data_V.size(); idat++ ) {
				// find predictions that bounds the current data
				AziData& data_cur = data_V[idat];
				if( (!data_cur.valid) || (data_cur.A==-12345.) ) continue;
				std::vector<AziData>::iterator iter_predl, iter_predh;
				int ipredh = std::lower_bound( datapred_V.begin(), datapred_V.end(), data_cur, CompareAziA ) - datapred_V.begin();
				int ipredl = ipredh==0 ? datapred_V.size()-1 : ipredh - 1;
				if( ipredh == datapred_V.size() ) ipredh = 0;
				if( (!datapred_V[ipredl].valid) || (!datapred_V[ipredh].valid) ) continue;
				// interpolate for amplitude prediction
				float azifactor;// = (data_cur.azi - datapred_V[ipredl].azi) / (adlist.at(ipredh).azi - adlist.at(ipredl).azi);
				if( ! AziFactor(datapred_V[ipredl], data_cur, datapred_V[ipredh], azifactor) ) {
					std::string info = std::to_string(datapred_V[ipredl].azi) + " - " +
						std::to_string(data_cur.azi) + " - " + std::to_string(datapred_V[ipredh].azi);
					throw ErrorFS::BadAzi(FuncName, info);
				}
				float amp_pred = datapred_V[ipredl].A + (datapred_V[ipredh].A-datapred_V[ipredl].A)  * azifactor;
				ampfactor.push_back( data_cur.A / amp_pred );
				weight.push_back( 1. ); // 1./data_cur.varA; // converges much slower with weight=1./Var!
			}
			for(int i=0; i<NEX; i++) 
				if( ! ExcludeBad( ampfactor, weight ) ) throw ErrorFS::SizeMismatch(FuncName, "ampfactor - weight");
			for(int idat=0; idat<ampfactor.size(); idat++) {
				F_sum += ampfactor[idat] * weight[idat];
				W_sum += weight[idat];
			}
		}
		Ampfactor = F_sum / W_sum;
		// rescale data to order of dataref
		double factor2 = Ampfactor*Ampfactor;
		for( int iper=0; iper<datapred.size(); iper++ ) {
			std::vector<AziData>& data_cur = datapred[iper];
			for( int ipred=0; ipred < data_cur.size(); ipred++ ) {
				if( data_cur[ipred].valid ) {
					data_cur[ipred].A *= Ampfactor;
					data_cur[ipred].varA *= factor2;
				}
			}
		}
	}

	void ComputeMisfits( std::vector<float> perlst, float weightin, std::vector< std::vector<AziData> >& data,
			std::vector< std::vector<AziData> >& datapred, float& Esum, float& Wsum, int& N, char type ) {
		// check input data size
		if( perlst.size() != data.size() ) throw ErrorFS::SizeMismatch(FuncName, "perlst - data");
		if( data.size() != datapred.size() ) throw ErrorFS::SizeMismatch(FuncName, "data - datapred");

		// misfits
		for( int iper=0; iper<data.size(); iper++ ) {
			std::vector<AziData>& data_cur = data[iper];
			std::vector<AziData>& datapred_cur = datapred[iper];
			// figure out dazi of predicted data
			int ipred;
			for(ipred=1; ipred<datapred_cur.size(); ipred++) {
				if( datapred_cur[ipred].valid && datapred_cur[ipred-1].valid ) break;
			}
			if( ipred >= datapred_cur.size() ) {
				WarningFS::Other(FuncName, "invalid radpattern prediction for iper=" + 
						std::to_string(iper) + " and type=" + type );
				continue;
			}
			float dazi = datapred_cur.at(ipred).azi - datapred_cur.at(ipred-1).azi;
			// compute misfits for the current period and store them into vectors
			std::vector<float> misGV, misPV, misAV, weitGV, weitPV, weitAV;
			for( int idata=0; idata<data_cur.size(); idata++ ) {
				AziData adtmp = data_cur[idata];
				if( ! adtmp.valid ) { continue; }
				int ninvalid = 0;
				int ipredlow = (int)floor(adtmp.azi/dazi);
				while( ipredlow>=0 && (!datapred_cur[ipredlow].valid) ) { ipredlow--; ninvalid++; }
				int ipredhigh = (int)ceil(adtmp.azi/dazi);
				while( ipredhigh<datapred_cur.size() && (!datapred_cur[ipredhigh].valid) ) { ipredhigh++; ninvalid++; }
				if( ipredlow < 0 || ipredhigh >= datapred_cur.size() || ninvalid>5 ) continue;
				MisfitS( adtmp, datapred_cur[ipredlow], datapred_cur[ipredhigh], perlst.at(iper), misGV, weitGV, misPV, weitPV, misAV, weitAV );
			}
			// check if there're enough misfits
			float minSize = MIN_AZI_PERC * float(data_cur.size());
			if( misGV.size() < minSize || misPV.size() < minSize || misAV.size() < minSize ) {
				WarningFS::Other(FuncName, "no enough data point for iper=" + 
						std::to_string(iper) + " and type=" + type );
				continue;
			} else { // exclude bad data and compute chi-squre misfit
				//std::vector<float> weit( misV.size(), 1. );
				for(int i=0; i<NEX; i++) 
					if( ! ExcludeLarge( misGV, weitGV ) ) throw ErrorFS::SizeMismatch(FuncName, "misGV - weitGV");
				for(int i=0; i<NEX; i++) 
					if( ! ExcludeLarge( misPV, weitPV ) ) throw ErrorFS::SizeMismatch(FuncName, "misPV - weitPV");
				for(int i=0; i<NEX; i++) 
					if( ! ExcludeLarge( misAV, weitAV ) ) throw ErrorFS::SizeMismatch(FuncName, "misAV - weitAV");
				float Gsum=0., Psum=0., Asum=0.;
				for(int idat=0; idat<misGV.size(); idat++) { float wtmp=weitGV[idat]*weightin; Esum+=misGV[idat]*wtmp; Wsum+=wtmp; Gsum+=misGV[idat]*wtmp;}// std::cerr<<"weitG = "<<wtmp<<"  misG*weitG = "<<misGV[idat]*wtmp<<std::endl;}
				for(int idat=0; idat<misPV.size(); idat++) { float wtmp=weitPV[idat]*weightin; Esum+=misPV[idat]*wtmp; Wsum+=wtmp; Psum+=misPV[idat]*wtmp;}// std::cerr<<"weitP = "<<wtmp<<"  misP*weitP = "<<misPV[idat]*wtmp<<std::endl;}
				for(int idat=0; idat<misAV.size(); idat++) { float wtmp=weitAV[idat]*weightin; Esum+=misAV[idat]*wtmp; Wsum+=wtmp; Asum+=misAV[idat]*wtmp;}// std::cerr<<"weitA = "<<wtmp<<"  misA*weitA = "<<misAV[idat]*wtmp<<std::endl;}
				N += (misGV.size() + misPV.size() + misAV.size());
				//	    float Ecur=0., Wcur=0.;
				//	    for(int idat=0; idat<misGV.size(); idat++) { Ecur += misGV[idat]*weitGV[idat]; Wcur += weitGV[idat]; }
				//	    for(int idat=0; idat<misPV.size(); idat++) { Ecur += misPV[idat]*weitPV[idat]; Wcur += weitPV[idat]; }
				//	    for(int idat=0; idat<misAV.size(); idat++) { Ecur += misAV[idat]*weitAV[idat]; Wcur += weitAV[idat]; }
				//	    Esum += Ecur/Wcur; Wsum += 1;
			}
	}
}

};


FocalSearcher::FocalSearcher()
	: pimplFS( new FSimpl ) {}

FocalSearcher::FocalSearcher( const FocalSearcher& fs2 ) 
	: pimplFS( new FSimpl( *(fs2.pimplFS) ) ) {}

FocalSearcher::FocalSearcher( FocalSearcher&& fs2 ) 
	: pimplFS( std::move(fs2.pimplFS) ) {}

	FocalSearcher& FocalSearcher::operator= ( const FocalSearcher& fs2 ) {
		pimplFS.reset( new FSimpl(*(fs2.pimplFS)) );
		return *this;
	}

FocalSearcher& FocalSearcher::operator= ( FocalSearcher&& fs2 ) {
	pimplFS = std::move(fs2.pimplFS);
	return *this;
}

FocalSearcher::~FocalSearcher() {}


FocalSearcher::FocalSearcher( const std::vector<PerDazi> &perRlistin, 
		const std::vector<PerDazi> &perLlistin, 
		const std::vector< std::vector<AziData> > &per_R_azi_data_in,
		const std::vector< std::vector<AziData> > &per_L_azi_data_in,
		const char *fReignamein, const char *fRphvnamein,
		const char *fLeignamein, const char *fLphvnamein )
: pimplFS(new FSimpl(perRlistin, perLlistin, per_R_azi_data_in, per_L_azi_data_in,
			fReignamein, fRphvnamein, fLeignamein, fLphvnamein, 0.5, 0.5) ) {
	// check input data size
	int Rsize = pimplFS->perRlist.size(), Lsize = pimplFS->perLlist.size();
	if( Rsize==0 && Lsize==0 ) {
		std::cerr<<"Error(FocalSearcher::FocalSearcher): Empty data input!"<<std::endl;
		exit(0);
	}
	if( Rsize != pimplFS->per_R_azi_data.size() ||
			Lsize != pimplFS->per_L_azi_data.size() ) {
		std::cerr<<"Error(FocalSearcher::FocalSearcher): size of perlist and per_azi_data doesn't match!"<<std::endl;
		exit(0);
	}

	// azi size R
	for(int iper=0; iper<Rsize; iper++) { 
		int nazi = 0, aSize = pimplFS->per_R_azi_data.at(iper).size();
		for(int iazi=0; iazi<aSize; iazi++) {
			if( pimplFS->per_R_azi_data[iper][iazi].valid ) nazi++;
		}
		if( nazi < MIN_AZI_PERC*float(aSize) ) {
			pimplFS->perRlist.erase( pimplFS->perRlist.begin() + iper );
			pimplFS->per_R_azi_data.erase( pimplFS->per_R_azi_data.begin() + iper );
		}
	}
	// azi size L
	for(int iper=0; iper<Lsize; iper++) { 
		int nazi = 0, aSize = pimplFS->per_L_azi_data.at(iper).size();
		for(int iazi=0; iazi<aSize; iazi++) {
			if( pimplFS->per_L_azi_data[iper][iazi].valid ) nazi++;
		}
		if( nazi < MIN_AZI_PERC*float(aSize) ) {
			pimplFS->perLlist.erase( pimplFS->perLlist.begin() + iper );
			pimplFS->per_L_azi_data.erase( pimplFS->per_L_azi_data.begin() + iper );
		}
	}
	Rsize = pimplFS->perRlist.size();
	Lsize = pimplFS->perLlist.size();

	if( Rsize==0 && Lsize==0 ) {
		std::cerr<<"Error(FocalSearcher::FocalSearcher): data matrix is empty after erasing!"<<std::endl;
		exit(0);
	}

	// insert sort perlist and per_azi_data for R
	for(int i=1; i<Rsize; i++) {
		if( pimplFS->perRlist.at(i).per >= pimplFS->perRlist.at(i-1).per ) continue;
		PerDazi pdtmp = pimplFS->perRlist[i];
		std::vector<AziData> Vadtmp = pimplFS->per_R_azi_data.at(i);
		int j;
		for(j=i; j>0 && pdtmp.per<pimplFS->perRlist.at(j-1).per; j--) {
			pimplFS->perRlist.at(j) = pimplFS->perRlist.at(j-1);
			pimplFS->per_R_azi_data.at(j) = pimplFS->per_R_azi_data.at(j-1);
		}
		pimplFS->perRlist.at(j) = pdtmp;
		pimplFS->per_R_azi_data.at(j) = Vadtmp;
	}
	// insert sort perlist and per_azi_data for L
	for(int i=1; i<Lsize; i++) {
		if( pimplFS->perLlist.at(i).per >= pimplFS->perLlist.at(i-1).per ) continue;
		PerDazi pdtmp = pimplFS->perLlist[i];
		std::vector<AziData> Vadtmp = pimplFS->per_L_azi_data.at(i);
		int j;
		for(j=i; j>0 && pdtmp.per<pimplFS->perLlist.at(j-1).per; j--) {
			pimplFS->perLlist.at(j) = pimplFS->perLlist.at(j-1);
			pimplFS->per_L_azi_data.at(j) = pimplFS->per_L_azi_data.at(j-1);
		}
		pimplFS->perLlist.at(j) = pdtmp;
		pimplFS->per_L_azi_data.at(j) = Vadtmp;
	}

}


/* reset/fill in the FocalSearcher 
 * by getting file names and moving in data matrices from outside */
void FocalSearcher::FSreset( const FileName& outname_misFin,
		const FileName& fReignamein, const FileName& fRphvnamein,
		const FileName& fLeignamein, const FileName& fLphvnamein,
		const float weightR_Foc_in, const float weightL_Foc_in ) {
	//outname_misFin.CheckEmpty();
	fReignamein.CheckAccess();
	fRphvnamein.CheckAccess();
	fLeignamein.CheckAccess();
	fLphvnamein.CheckAccess();
	pimplFS->outname_misF = outname_misFin;
	pimplFS->fReigname = fReignamein;
	pimplFS->fRphvname = fRphvnamein;
	pimplFS->fLeigname = fLeignamein;
	pimplFS->fLphvname = fLphvnamein;
	pimplFS->weightR_Foc = weightR_Foc_in;
	pimplFS->weightL_Foc = weightL_Foc_in;
}
void FocalSearcher::FSreset( const FileName& outname_misFin,
		const FileName& fReignamein, const FileName& fRphvnamein,
		const FileName& fLeignamein, const FileName& fLphvnamein,
		const float weightR_Foc_in, const float weightL_Foc_in,
		std::vector<PerDazi> &&perRlistin,
		std::vector<PerDazi> &&perLlistin,
		std::vector< std::vector<AziData> > &&per_R_azi_data_in,
		std::vector< std::vector<AziData> > &&per_L_azi_data_in ) {
	FSreset( outname_misFin, fReignamein, fRphvnamein, fLeignamein, fLphvnamein, weightR_Foc_in, weightL_Foc_in );

	const size_t Rsize = perRlistin.size(), Lsize = perLlistin.size();
	if( Rsize == 0 && Lsize == 0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
	if( Rsize != per_R_azi_data_in.size() || Lsize != per_L_azi_data_in.size() )
		throw ErrorFS::SizeMismatch(FuncName, "perLlist - per_R_azi_data_in || perLlist - per_L_azi_data_in");

	pimplFS->perRlist = std::move(perRlistin);
	pimplFS->perLlist = std::move(perLlistin);
	pimplFS->per_R_azi_data = std::move(per_R_azi_data_in);
	pimplFS->per_L_azi_data = std::move(per_L_azi_data_in);
}


//const double& FocalSearcher::AFactorR() const {return pimplFS->AfactorR; }
//const double& FocalSearcher::AFactorL() const {return pimplFS->AfactorL; }


/* rescale the amplitudes of datapred based on data */
void FocalSearcher::ReScalePred( std::vector< std::vector<AziData> >& data, std::vector< std::vector<AziData> >& datapred, double& Ampfactor ) {
	pimplFS->ReScale( data, datapred, Ampfactor );
}


/* search the focal info with a simulated annealing algorithm.
 * nsearch: number of search iterations
 * alpha: controls how fast temperature decays
 * Tfactor: factor of initial temperature */
FocalInfo<ftype> FocalSearcher::SearchFocal( const FocalInfo<ftype>& finfoin, const Dtype datatype, 
		int nsearch, float alpha, float Tfactor ) {
	// check input data size
	if( datatype == Undefined ) throw ErrorFS::BadParam(FuncName, "Undefined datatype");
	int Rsize = pimplFS->perRlist.size(), Lsize = pimplFS->perLlist.size();
	if( Rsize==0 && Lsize==0 ) throw ErrorFS::EmptyData(FuncName, "Rsize && Lsize");
	if( Rsize!=pimplFS->per_R_azi_data.size() || Lsize!=pimplFS->per_L_azi_data.size() )
		throw ErrorFS::SizeMismatch(FuncName, "pimplFS->per_R_azi_data - pimplFS->per_L_azi_data");
	//    || pimplFS->feigname.empty() || pimplFS->fphvname.empty() ) return false;
	// simulated annealing parameters
	float E;
	// start search
	double Af_best_R, Af_best_L;
	FocalInfo<ftype> finfo = finfoin;
	EnergyF(finfo, datatype, E, Af_best_R, Af_best_L);
	//int nsearch = 20000;
	float T = E * Tfactor;// alpha=0.999;
	std::cout<<"### SearchFocal: Initial Misfit**2 for ("<<finfo<<") = "<<E<<" T="<<T<<" ###"<<std::endl;
	FocalInfo<ftype> finfobest = finfo;
	float Ebest = E;
	int nrej = 0;
	int isearch = 0;
	std::ofstream fout;
	bool output_mis = ! pimplFS->outname_misF.empty();
	if( output_mis ) fout.open(  pimplFS->outname_misF.c_str(), std::ofstream::app );
	fout<<"# [ focal = "<<finfo<<" ]"<<std::endl;
	fout<< "-1\t" << E << "\t" << T << std::endl;
	char datatype_name = datatype==B ? 'B' : (datatype==R?'R':'L');
#pragma omp parallel for schedule (dynamic, 1)
	for( int i=0; i<nsearch; i++ ) {
		FocalInfo<ftype> finfonew = pimplFS->Neighbour( finfo );
		float Enew = -12345.; 
		double AfactorR = 1., AfactorL = 1.;
		EnergyF( finfonew, datatype, Enew, AfactorR, AfactorL );
		if( pimplFS->Accept(E, Enew, T) ) {
			finfo = finfonew;
			E = Enew;
			if( output_mis ) {
#pragma omp critical
				{ // critical start
					fout<< std::setw(4)<<isearch << " " << std::setw(8)<<Enew << " " 
						<< std::setw(8)<<T << "\t" << finfo << std::endl;
					fout.flush();
				} // critical end
			}
			std::cout<<"   Misfit**2 for ("<<finfonew<<") = "<<Enew<<" (accepted)  T="<<T
				<<"  isearch="<<isearch<<"/"<<nsearch<<"  datatype="<<datatype_name<<std::endl;
			nrej = 0;
		}
		else { nrej++; std::cout<<"( nrejects = "<<nrej<<" )"<<"  ithread="<<omp_get_thread_num()<<"                 "<<std::endl<<"\x1b[A"; }
#pragma omp critical
		{ // critical start
			T *= alpha;
			if( Enew < Ebest ) {
				finfobest = finfonew;
				Ebest = Enew;
				Af_best_R = AfactorR;
				Af_best_L = AfactorL;
			}
			isearch++;
		} // critical end
	}
	fout<< isearch << "\t" << Ebest << "\t" << T << "\t" << finfobest << std::endl;
	fout<<std::endl<<std::endl; fout.close();
	std::cout<<"                                   "<<std::endl;
	finfo = finfobest; 
	pimplFS->AfactorR = Af_best_R;
	pimplFS->AfactorL = Af_best_L;
	return finfo;
}

void FocalSearcher::EnergyF( const FocalInfo<ftype>& finfo, const Dtype datatype,
		float& E, double& AfactorR, double& AfactorL ) {
	int N;
	float chiS, wSum;
	FocalSearcher::chiSquareF(pimplFS->per_R_azi_data, pimplFS->perRlist, pimplFS->per_L_azi_data, pimplFS->perLlist,
			finfo, datatype, chiS, wSum, N, AfactorR, AfactorL);
	if( N <= 0 ) 
		throw ErrorFS::InsufData(FuncName, "N="+std::to_string(N));
	//E = chiS / wSum;
	E = chiS / (N-5.); // reduced chi-square
}
void FocalSearcher::chiSquareF( std::vector< std::vector<AziData> >& Rdata, std::vector<PerDazi>& perRlist,
		std::vector< std::vector<AziData> >& Ldata, std::vector<PerDazi>& perLlist,
		const FocalInfo<ftype>& finfo, const Dtype datatype, 
		float& chiS, float& wSum, int& N, double& AfactorR, double& AfactorL ) const {
	// check feigname & fphvname accessibilities
	int Rsize = perRlist.size(), Lsize = perLlist.size();
	if( Rsize > 0 ) {
		pimplFS->fReigname.CheckAccess();
		pimplFS->fRphvname.CheckAccess();
	}
	if( Lsize > 0 ) {
		pimplFS->fLeigname.CheckAccess();
		pimplFS->fLphvname.CheckAccess();
	}

	// flags
	bool RFlag = false, LFlag = false;
	switch( datatype ) {
		case B: LFlag = true;
		case R: RFlag = true;
				  break;
		case L: LFlag = true;
	}
	// chi-square total and weight
	chiS = 0.; wSum = 0.; N = 0;
	// chi-square misfit from Rayleigh wave
	if( Rsize > 0 && RFlag ) {
		// perlst from perlist
		std::vector<float> perRlst;
		for(int i=0; i<perRlist.size(); i++) perRlst.push_back(perRlist[i].per);

		// initialize prediction matrix
		std::vector< std::vector<AziData> > per_R_azi_pred;

		// run rad_pattern_r
		pimplFS->rpR.Predict( 'R', pimplFS->fReigname, pimplFS->fRphvname, finfo.strike, finfo.dip, 
				finfo.rake, finfo.depth, perRlst, per_R_azi_pred );

		// invalidate incomplete azimuths and points around 0 amplitudes
		pimplFS->ReValidate( per_R_azi_pred );

		// rescale predicted amplitude by observed average
		pimplFS->ReScale( Rdata, per_R_azi_pred, AfactorR );

		// compute misfit at each period
		pimplFS->ComputeMisfits( perRlst, pimplFS->weightR_Foc, Rdata, per_R_azi_pred, chiS, wSum, N, 'R' );
	}

	// chi-square misfit from Love wave
	if( Lsize > 0 && LFlag ) {
		// perlst from perlist
		std::vector<float> perLlst;
		for(int i=0; i<perLlist.size(); i++) perLlst.push_back(perLlist[i].per);

		// initialize prediction matrix
		std::vector< std::vector<AziData> > per_L_azi_pred;

		// run rad_pattern_l
		pimplFS->rpL.Predict( 'L', pimplFS->fLeigname, pimplFS->fLphvname, finfo.strike, finfo.dip,
				finfo.rake, finfo.depth, perLlst, per_L_azi_pred );

		// invalidate incomplete azimuths and points around 0 amplitudes
		pimplFS->ReValidate( per_L_azi_pred );

		// rescale predicted amplitude by observed average
		pimplFS->ReScale( Ldata, per_L_azi_pred, AfactorL );

		// compute misfit at each period
		pimplFS->ComputeMisfits( perLlst, pimplFS->weightL_Foc, Ldata, per_L_azi_pred, chiS, wSum, N, 'L' );
	}

	// final chi-square
	//E = ( ER + EL ) / ( nRvalid + nLvalid );
	//E = Esum / Wsum;

}


